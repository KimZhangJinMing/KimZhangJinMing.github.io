<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/11/21/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/world/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词</th>
<th>词义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>absolutely integral</td>
<td>绝对完整</td>
<td></td>
</tr>
<tr>
<td>Foremost amongst</td>
<td>其中最重要的</td>
<td>formost adj/adv 最重要的 amongst 其中</td>
</tr>
<tr>
<td>comprehensive coverage</td>
<td>全面覆盖</td>
<td></td>
</tr>
<tr>
<td>be closely followed by</td>
<td>紧随其后</td>
<td></td>
</tr>
<tr>
<td>thorough</td>
<td>彻底</td>
<td>adv</td>
</tr>
<tr>
<td>conceptually</td>
<td>从概念上讲</td>
<td></td>
</tr>
<tr>
<td>sweet spot</td>
<td>难题</td>
<td></td>
</tr>
<tr>
<td>in terms of</td>
<td>就…而言</td>
<td></td>
</tr>
<tr>
<td>mature</td>
<td>成熟</td>
<td></td>
</tr>
<tr>
<td>principle</td>
<td>原理</td>
<td></td>
</tr>
<tr>
<td>fundamentally</td>
<td>从根本上</td>
<td></td>
</tr>
<tr>
<td>instantiation</td>
<td>实例化</td>
<td>n   instantiated  v. instantiate</td>
</tr>
<tr>
<td>mechanism</td>
<td>机制</td>
<td></td>
</tr>
<tr>
<td>capable of</td>
<td>能够</td>
<td></td>
</tr>
<tr>
<td>internationalization</td>
<td>国际化</td>
<td></td>
</tr>
<tr>
<td>specific</td>
<td>具体的，特殊的</td>
<td></td>
</tr>
<tr>
<td>exclusively</td>
<td>仅仅，只</td>
<td>adv</td>
</tr>
<tr>
<td>backbone</td>
<td>骨干</td>
<td></td>
</tr>
<tr>
<td>assembled</td>
<td>组装好的</td>
<td>assembl v.组装</td>
</tr>
<tr>
<td>responsible for</td>
<td>负责</td>
<td></td>
</tr>
<tr>
<td>represent</td>
<td>代表，表示</td>
<td></td>
</tr>
<tr>
<td>compose</td>
<td>组成，撰写</td>
<td>component 组件</td>
</tr>
<tr>
<td>instruct</td>
<td>指导，指示</td>
<td>instruction</td>
</tr>
<tr>
<td>declaratively</td>
<td>声明性地</td>
<td></td>
</tr>
<tr>
<td>scenarios</td>
<td>情景</td>
<td></td>
</tr>
<tr>
<td>explicit</td>
<td>明确的，显性的</td>
<td></td>
</tr>
<tr>
<td>typically suffices</td>
<td>通常就足够了</td>
<td>typically 通常地  suffice   suffical adj</td>
</tr>
<tr>
<td>intuitive</td>
<td>直觉的</td>
<td></td>
</tr>
<tr>
<td>convey</td>
<td>传达</td>
<td></td>
</tr>
<tr>
<td>decoupled</td>
<td>解耦的</td>
<td>decoupled from 与…分离</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-<span class="function">Oriented <span class="title">Programming</span> <span class="params">(AOP)</span> technologies.</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> 对 Spring 框架的 IoC 容器进行彻底处理之后，紧随其后的是Spring 的面向方面编程<span class="params">(AOP)</span>技术。</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99/Eureka%E6%90%AD%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h3 id="1-搭建工程"><a href="#1-搭建工程" class="headerlink" title="1. 搭建工程"></a>1. 搭建工程</h3><h4 id="1-1-报错信息"><a href="#1-1-报错信息" class="headerlink" title="1.1 报错信息"></a>1.1 报错信息</h4><p>如果@EnableEurekaServer找不到,可能是因为maven版本冲突的原因。</p>
<p>如使用SpringBoot2.2.2.RELEASE版本,SpringCloud的版本是Hoxton.RELEASE,eureka-server的版本应该是2.2.2.RELEASE,而不是自动导入的2.2.0.RELEASE.</p>
<p>如果启动报错以下信息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryClient_EUREKASERVER/ming:EurekaServer:<span class="number">8001</span> - was unable to refresh its cache! status = Cannot execute request on any known server</span><br></pre></td></tr></table></figure>

<p>启动服务后报错，添加以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-mybatis-generator"><a href="#1-2-mybatis-generator" class="headerlink" title="1.2 mybatis-generator"></a>1.2 mybatis-generator</h4><p>首先,在父POM中添加mybatis-generator的插件,并添加mysql的驱动作为依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 指定generator配置文件的路径 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">               	<span class="comment">&lt;!-- 添加mysql驱动 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在src/main/resources/generator/generatorConfig.xml添加配置文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span> <span class="attr">defaultModelType</span>=<span class="string">&quot;flat&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--生成的实体类自带toString方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--覆盖xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不生成注释--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/cloud-course&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--实体类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.imooc.domain&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--mapper.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--mapper接口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.imooc.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src\main\java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>配置文件中property,plugin,commentGenerator是有顺序的,如果顺序没有按照规定的来,会报错<code>元素类型为 &quot;context&quot; 的内容必须匹配</code></li>
<li>targerProject中要使用,而不是/</li>
</ol>
<p>添加完配置文件后,有两种使用方法:</p>
<p>1.在Maven的命令行中执行：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210424203023538.png" alt="在maven命令中使用"></p>
<p>2.配置一个maven命令:</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210424203153345.png" alt="配置一个maven命令"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><h4 id="1-1-交换两个数字"><a href="#1-1-交换两个数字" class="headerlink" title="1.1 交换两个数字"></a>1.1 交换两个数字</h4><blockquote>
<p>两数相加保存和值—-中规中矩的办法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b; <span class="comment">// b = (a + b) - b;实际上就是b = a</span></span><br><span class="line">    a = a - b; <span class="comment">// a = a - (a - b);实际上就是a = b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两数异或保存两数状态—-高大上的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个数对其他数异或两次,该数本身不变。一个数对其自身异或,结果为0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b; <span class="comment">// b = (a ^ b) ^ b;实际上就是b = a</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = a ^ (a ^ b);实际上就是a = b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-try-finally返回值"><a href="#1-2-try-finally返回值" class="headerlink" title="1.2 try..finally返回值"></a>1.2 try..finally返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 这里已经确定了返回值,即使在finally块中修改了a的值,也是返回3</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 如果finally块中有返回值,返回4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-StringBuffer、StringBuilder"><a href="#1-3-StringBuffer、StringBuilder" class="headerlink" title="1.3 StringBuffer、StringBuilder"></a>1.3 StringBuffer、StringBuilder</h4><p>相同点:</p>
<ol>
<li>三者都是final,不允许被继承</li>
<li>都是char[]数组实现的</li>
</ol>
<p>不同点：</p>
<ol>
<li>String是不可变对象,其他两者是可变的</li>
<li>StringBuilder效率快,不加锁,线程不安全。StringBuffer加锁,保证线程安全。</li>
<li>String适合操作少量字符串。StringBuilder适合单线程下大量字符串操作。StringBuffer适合多线程下大量字符串操作。</li>
</ol>
<h3 id="2-集合"><a href="#2-集合" class="headerlink" title="2.集合"></a>2.集合</h3><h4 id="2-1-Vector-List的区别"><a href="#2-1-Vector-List的区别" class="headerlink" title="2.1 Vector,List的区别"></a>2.1 Vector,List的区别</h4><p>线程安全：</p>
<ul>
<li>ArrayList:底层是基于数组实现,线程不安全,查询和修改快,插入和删除慢</li>
<li>LinkedList:底层是基于双向链表实现,线程不安全,查询和修改慢,插入和删除快</li>
<li>Vector:底层是基于数组实现,线程安全,使用Synchronized加锁</li>
</ul>
<p>使用场景：</p>
<ul>
<li>Vector已经很少使用了</li>
<li>增加和删除场景多,使用LinkedList</li>
<li>查询和修改场景多,使用ArrayList</li>
</ul>
<h4 id="2-2-ArrayList保证线程安全"><a href="#2-2-ArrayList保证线程安全" class="headerlink" title="2.2 ArrayList保证线程安全"></a>2.2 ArrayList保证线程安全</h4><ol>
<li>自己封装一个类,进行加锁操作</li>
<li>使用Collections.synchronizedList,使用synchronized加锁</li>
<li>使用CopyOnWriteArrayList,使用ReenterLock加锁</li>
</ol>
<h4 id="2-3-CopyOnWriteArrayList"><a href="#2-3-CopyOnWriteArrayList" class="headerlink" title="2.3 CopyOnWriteArrayList"></a>2.3 CopyOnWriteArrayList</h4><ul>
<li>CopyOnWriteArrayList适用于读多写少的场景。读操作是不需要加锁的,写操作需要加锁。</li>
<li>SynchronizedLock读写操作都使用synchronized加锁,写的性能比CopyOnWriteArrayList好，但是读的操作比CopyOnWriteArrayList差</li>
<li>CopyOnWriteArrayList的设计思想:读写分离 + 最终一致。读操作的时候,读取的是旧的数组。而写数据的时候是加锁的,只有把新的数组引用赋值后,才能读取到新的数据,这就保证了最终一致性。</li>
<li>缺点：内存占用问题,由于写时复制,内存里面同时存在两个对象占用的空间,如果对象大则容易发生YoungGC和FullGC</li>
</ul>
<h4 id="2-4-List扩容机制"><a href="#2-4-List扩容机制" class="headerlink" title="2.4 List扩容机制"></a>2.4 List扩容机制</h4><p>JDK1.7之前默认容量是10,JDK1.7之后默认容量是0.</p>
<ul>
<li><p>未指定集合容量,默认是0,若已经指定大小则集合大小为指定大小。</p>
</li>
<li><p>当集合第一次添加元素时,集合容量扩容为10。当集合容量超过10的时候,扩容的计算方法为<code>原始容量 + 原始容量 / 2</code>.</p>
</li>
</ul>
<h4 id="2-5-HashMap、TreeMap"><a href="#2-5-HashMap、TreeMap" class="headerlink" title="2.5 HashMap、TreeMap"></a>2.5 HashMap、TreeMap</h4><p>HashMap是基于数组和链表实现的,可以实现快速的存储和检索,但是元素是无序的。适合插入、删除和定位元素。</p>
<p>TreeMap使用存储结构是平衡二叉树,可以通过Comparator接口实现自定义排序,但是一般性能比HashMap差。</p>
<h4 id="2-6-线程安全的HashMap"><a href="#2-6-线程安全的HashMap" class="headerlink" title="2.6 线程安全的HashMap"></a>2.6 线程安全的HashMap</h4><ol>
<li>使用Collections.synchronizedMap</li>
<li>使用ConcurrentHashMap</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/%E5%B9%B6%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><blockquote>
<p>1.进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>2.进程可以看作独立应用，线程不能看作独立应用。</p>
<p>3.进程独占内存空间，保存各自的运行状态，相互之间互不干扰且可以互相切换。线程共享进程的内存资源，相互之间切换更加快捷，支持更细粒度的任务控制</p>
<p>4.多进程的程序比多线程的程序更加健壮，但是进程的切换开销比线程大</p>
</blockquote>
<h4 id="2-run和start"><a href="#2-run和start" class="headerlink" title="2. run和start"></a>2. run和start</h4><p>start()方法的执行流程:</p>
<ol>
<li>检查线程状态是不是NEW(线程刚创建未启动的状态)，如果不是抛出异常(如果调用多次start方法会抛出IllegalThreadStateException的异常)</li>
<li>加入线程组</li>
<li>调用native的start0方法</li>
</ol>
<p>而run方法只是一个普通的方法。只有调用start方法启动线程才算是真正的启动线程，线程才会有生命周期。</p>
<h4 id="3-Thread类的方法"><a href="#3-Thread类的方法" class="headerlink" title="3.Thread类的方法"></a>3.Thread类的方法</h4><p>特别要注意的是<code>run()</code>和<code>exit()</code>都是Thread类的方法。虽然run()在Runnable接口中也有。</p>
<p>此外，Thread类有一个native的notify/notifyAll方法，但是没有wait方法。(注意wait/notify/notifyAll都是Object的方法)</p>
<h4 id="4-线程返回值处理"><a href="#4-线程返回值处理" class="headerlink" title="4.线程返回值处理"></a>4.线程返回值处理</h4><blockquote>
<p>1.主线程等待法(while循环等待)，等待子线程执行完成返回结果</p>
<p>2.使用Thread类的join方法阻塞当前线程，等待子线程执行完成返回结果</p>
<p>3.实现Callbale接口实现，通过FutureTask或线程池submit之后接收的Futre。FutureTask/Future的get()会阻塞直到子线程执行完成返回结果。如果子线程发生异常且没有捕获,get()不再阻塞。</p>
</blockquote>
<h5 id="4-1-主线程等待法"><a href="#4-1-主线程等待法" class="headerlink" title="4.1 主线程等待法"></a>4.1 主线程等待法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">        <span class="comment">// 这里如果是空的方法体，就会陷入死循环。如果加入sleep，就轮询直到子线程返回结果</span></span><br><span class="line">        <span class="keyword">while</span>(myThread.getStr() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程接收到结果,result is &quot;</span> + myThread.getStr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnable的run方法没有返回值，只能通过成员变量返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.str = <span class="string">&quot;i am result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-使用join"><a href="#4-2-使用join" class="headerlink" title="4.2 使用join()"></a>4.2 使用join()</h5><p>使用4.1中的MyThread，改变main方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程接收到结果,result is &quot;</span> + myThread.getStr());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-通过FutureTask接收返回值"><a href="#4-3-通过FutureTask接收返回值" class="headerlink" title="4.3 通过FutureTask接收返回值"></a>4.3 通过FutureTask接收返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="comment">// 启动线程,FutureTask实现了Runnable接口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程接收到结果,result is &quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i am result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-通过线程池和Futrue接收返回值"><a href="#4-4-通过线程池和Futrue接收返回值" class="headerlink" title="4.4 通过线程池和Futrue接收返回值"></a>4.4 通过线程池和Futrue接收返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">if</span>(!future.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程接收到结果,result is &quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i am result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-notify-notifyAll"><a href="#5-notify-notifyAll" class="headerlink" title="5.notify/notifyAll"></a>5.notify/notifyAll</h4><p>锁池:两个线程竞争同一把锁，没有竞争到锁的线程将进入<code>锁池</code>。锁池可以竞争锁。</p>
<p>等待池:在等待池的线程等待着被唤醒进入锁池竞争锁。</p>
<blockquote>
<p>1.notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。notifyAll会让所有处于等待池中的线程全部进入锁池中去竞争获取锁的机会。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Runnable waitRunnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在等待...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前线程进入等待池，等待notify/notifyAll通知进入锁池竞争锁</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable notifyRunnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在唤醒线程...&quot;</span>);</span><br><span class="line">                <span class="comment">// 通知等待池中所有锁进入锁池去竞争锁</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                <span class="comment">// 随机选择等待池中的一个锁进入锁池去竞争锁</span></span><br><span class="line">                <span class="comment">//lock.notify();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(waitRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(waitRunnable);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(waitRunnable);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(notifyRunnable);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 确保t1,t2,t3先启动</span></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-停止线程"><a href="#6-停止线程" class="headerlink" title="6.停止线程"></a>6.停止线程</h4><blockquote>
<p>错误的停止方法：</p>
<p>1.stop:stop非常粗暴，被stop的线程会释放所有的锁并停止线程执行，即使它并没有执行完成。stop不能完成一个完整单位的停止。</p>
<p>2.resume:resume会将当前的线程挂起，但并没有释放锁。这有可能会导致其他需要这把锁的线程发生死锁。</p>
<p>3.volatile修饰的成员变量控制停止：在某些情况下，volatile修饰的成员变量去控制线程的停止是可行的。但在线程阻塞的时候，线程有可能检测不到成员变量的改变，导致线程停止失败。</p>
</blockquote>
<p>例子中，生产者往queue中生产数据，消费者从queue中消费数据。当消费者消费完成后，希望生产者停止线程。</p>
<p>使用volatile修饰的canceled变量控制线程的停止，当生产者的线程阻塞时，无法检测到外界canceled变量的改变，而无法正确停止线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Thread customerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(queue));</span><br><span class="line">        producerThread.start();</span><br><span class="line">        <span class="comment">// 生产者先生产1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        customerThread.start();</span><br><span class="line">        <span class="comment">// 1s后消费者不再消费</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止生产者</span></span><br><span class="line">        producer.cancel();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不再消费,请求生产者停止生产...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">10000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当消费者cancel的时候，生产者阻塞在了这里，检测不到canceled的改变，也就导致了不能正确停止线程</span></span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者停止生产...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (needMore()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer ele = queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费&quot;</span> + ele);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.75</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正确的停止方法：</p>
<p>使用Thread.interrupt停止线程</p>
</blockquote>
<p>将上面的例子修改为使用interrupt来停止线程，当调用interrupt方法时，isInterrupted方法可以检测到线程的中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Thread customerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(queue));</span><br><span class="line">        producerThread.start();</span><br><span class="line">        <span class="comment">// 生产者先生产1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        customerThread.start();</span><br><span class="line">        <span class="comment">// 1s后消费者不再消费</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止生产者</span></span><br><span class="line">        producerThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不再消费,请求生产者停止生产...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// isInterrupted()检测线程是否中断</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者停止生产...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (needMore()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer ele = queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费&quot;</span> + ele);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.75</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Vue/menu/</url>
    <content><![CDATA[<p>在做这个菜单功能的时候，花了好几天。现在终于做出来了。但是还是有好多的疑问。</p>
<p><code>松哥有时间教教我这个菜鸟..</code></p>
<p>这里先给出完整的<code>menu.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./api&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initMenu = <span class="function">(<span class="params">router, store</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (store.state.routes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	getRequest(<span class="string">&quot;/system/menus&quot;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (data) &#123;</span><br><span class="line">			<span class="keyword">let</span> fmtRoutes = formatRoutes(data.data);</span><br><span class="line">			<span class="comment">// 不加这行代码,addRoute无效</span></span><br><span class="line">			router.options.routes = fmtRoutes;</span><br><span class="line">			fmtRoutes.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">				router.addRoute(item)</span><br><span class="line">			&#125;)</span><br><span class="line">			store.commit(<span class="string">&#x27;initRoutes&#x27;</span>, fmtRoutes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formatRoutes = <span class="function">(<span class="params">routes</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> fmRoutes = [];</span><br><span class="line">	routes.forEach(<span class="function"><span class="params">router</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> &#123;</span><br><span class="line">			path,</span><br><span class="line">			component,</span><br><span class="line">			name,</span><br><span class="line">			meta,</span><br><span class="line">			iconCls,</span><br><span class="line">			children</span><br><span class="line">		&#125; = router;</span><br><span class="line">		<span class="keyword">if</span> (children) &#123;</span><br><span class="line">			children = formatRoutes(children);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">let</span> fmRouter = &#123;</span><br><span class="line">			<span class="attr">path</span>:path,</span><br><span class="line">			name,</span><br><span class="line">			iconCls,</span><br><span class="line">			meta,</span><br><span class="line">			<span class="attr">children</span>:children,</span><br><span class="line">			<span class="attr">component</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Home&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Home&#x27;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Emp&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/emp/<span class="subst">$&#123;component&#125;</span>`</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Per&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/per/<span class="subst">$&#123;component&#125;</span>`</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Sal&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/sal/<span class="subst">$&#123;component&#125;</span>`</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Sta&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/sta/<span class="subst">$&#123;component&#125;</span>`</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.startsWith(<span class="string">&quot;Sys&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/sys/<span class="subst">$&#123;component&#125;</span>`</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmRoutes.push(fmRouter);</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> fmRoutes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-动态加载路由"><a href="#1-动态加载路由" class="headerlink" title="1.动态加载路由"></a>1.动态加载路由</h3><p>如果使用以下代码动态加载路由:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">component</span>(<span class="params">resolv</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(..)&#123;</span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&#x27;../views/emp&#x27;</span>+component+<span class="string">&#x27;.vue&#x27;</span>],resolve)  <span class="comment">// 使用这种方式..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器会报错如下:</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210120212655214.png" alt="image-20210120212655214"></p>
<h3 id="2-addRoutes"><a href="#2-addRoutes" class="headerlink" title="2.addRoutes()"></a>2.addRoutes()</h3><p>我使用的是vue-router4.0,好像是没用addRoutes()这个方法的。我在控制台打印出router对象，只看到了addRoute方法？ </p>
<p>官方文档中好像也没看到由addRoutes()的方法？</p>
<h3 id="3-addRoute-无效"><a href="#3-addRoute-无效" class="headerlink" title="3. addRoute()无效"></a>3. addRoute()无效</h3><p>既然没有addRoutes(),我就尝试着使用循环addRoute的方式添加路由，发现也无效。</p>
<p>后来，加上下面一句代码就可以了，原因不详…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.options.routes = fmtRoutes;</span><br><span class="line">fmtRoutes.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    router.addRoute(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-‘员工资料’菜单不能正确跳转-已解决"><a href="#4-‘员工资料’菜单不能正确跳转-已解决" class="headerlink" title="4. ‘员工资料’菜单不能正确跳转(已解决)"></a>4. ‘员工资料’菜单不能正确跳转(已解决)</h3><p>数据库中存在两个<code>员工资料</code>的菜单，一个是一级菜单，一个是二级菜单。</p>
<p>当我使用addRoute添加路由的时候,一级菜单不能正确跳转。</p>
<p>查阅官方文档知道，addRoute在name相同的时候，会先移除第一个。由于这里是先加载一级菜单，后添加二级菜单，当添加二级菜单的<code>员工资料</code>时,一级菜单的<code>员工资料</code>就被移除了。导致一级菜单不能正确跳转。</p>
<h3 id="5-ES6语法问题"><a href="#5-ES6语法问题" class="headerlink" title="5. ES6语法问题"></a>5. ES6语法问题</h3><p>在ES6语法的时候，我记得当key和value的名称一样的时候，可以不写value。比如name:name简写为name.</p>
<p>但是在这里，我省略name,iconCls,meta属性的时候是可以的，但是path，children简写的时候就出问题了。</p>
<p>如果简写了path,children，有时候会出问题，有时候又可以？ </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fmRouter = &#123;</span><br><span class="line">    <span class="attr">path</span>:path,</span><br><span class="line">    name,</span><br><span class="line">    iconCls,</span><br><span class="line">    meta,</span><br><span class="line">    <span class="attr">children</span>:children,</span><br></pre></td></tr></table></figure>



<h3 id="6-登录进去首页的时候，有时候不加载菜单"><a href="#6-登录进去首页的时候，有时候不加载菜单" class="headerlink" title="6.登录进去首页的时候，有时候不加载菜单"></a>6.登录进去首页的时候，有时候不加载菜单</h3><p>这种情况偶尔才会出现，重新刷新就不会了，也是想不懂。。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210120214223398.png" alt="image-20210120214223398"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Vue/vhr/</url>
    <content><![CDATA[<h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><h4 id="1-1-下载npm和node"><a href="#1-1-下载npm和node" class="headerlink" title="1.1 下载npm和node"></a>1.1 下载npm和node</h4><h4 id="1-2-修改npm源"><a href="#1-2-修改npm源" class="headerlink" title="1.2 修改npm源"></a>1.2 修改npm源</h4><h4 id="1-3-安装ElementUI"><a href="#1-3-安装ElementUI" class="headerlink" title="1.3 安装ElementUI"></a>1.3 安装ElementUI</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save element-plus</span><br></pre></td></tr></table></figure>

<p>在main.js引入elementUI,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App from <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router from <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store from <span class="string">&quot;./store&quot;</span></span><br><span class="line"><span class="keyword">import</span> ElementPlus from <span class="string">&#x27;element-plus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createApp(App).use(ElementPlus).use(router).use(store).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-axios"><a href="#2-axios" class="headerlink" title="2.axios"></a>2.axios</h3><h4 id="2-1-封装请求，拦截响应对错误统一处理"><a href="#2-1-封装请求，拦截响应对错误统一处理" class="headerlink" title="2.1 封装请求，拦截响应对错误统一处理"></a>2.1 封装请求，拦截响应对错误统一处理</h4><p>通过拦截器拦截response，对服务器返回的错误信息统一处理。</p>
<p><code>api.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ElMessage&#125; <span class="keyword">from</span> <span class="string">&quot;element-plus&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;baseUrl&#125; <span class="keyword">from</span> <span class="string">&quot;../../config&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截axios响应，对错误统一处理</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// data为后端返回的数据</span></span><br><span class="line">	<span class="keyword">const</span> data = result.data;</span><br><span class="line">	<span class="comment">// 业务的错误，直接显示后端返回的错误信息</span></span><br><span class="line">	<span class="keyword">if</span> (result.status &amp;&amp; result.status === <span class="number">200</span> &amp;&amp; data.status === <span class="number">500</span>) &#123;</span><br><span class="line">		ElMessage.error(data.message)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 请求状态码不是200，有可能后端返回了错误信息</span></span><br><span class="line">	<span class="keyword">const</span> data = error.response;</span><br><span class="line">	<span class="keyword">if</span> (data.message) &#123;</span><br><span class="line">		ElMessage.error(data.error)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.status === <span class="number">404</span>) &#123;</span><br><span class="line">		ElMessage.error(<span class="string">&quot;您访问的页面可能在火星...&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.status === <span class="number">500</span>) &#123;</span><br><span class="line">		ElMessage.error(<span class="string">&quot;服务器内部错误...&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ElMessage.error(<span class="string">&quot;未知错误...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对键值对的POST请求进行封装：</p>
<p><code>api.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装键值对的POST请求</span></span><br><span class="line"><span class="keyword">const</span> postKeyValueRequest = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> axios(&#123;</span><br><span class="line">		<span class="attr">url</span>: <span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">		<span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">		data,</span><br><span class="line">		<span class="attr">headers</span>:&#123;</span><br><span class="line">			<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">transformRequest</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> transformData = <span class="string">&quot;&quot;</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">				transformData += <span class="built_in">encodeURIComponent</span>(key) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(data[key]) + <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> transformData;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRequest=<span class="function">(<span class="params">url,data</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> axios(&#123;</span><br><span class="line">		<span class="attr">url</span>:<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">		<span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">		data</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postRequest=<span class="function">(<span class="params">url,data</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> axios(&#123;</span><br><span class="line">		<span class="attr">url</span>:<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">		<span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">		data</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> putRequest=<span class="function">(<span class="params">url,data</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> axios(&#123;</span><br><span class="line">		<span class="attr">url</span>:<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">		<span class="attr">method</span>:<span class="string">&quot;put&quot;</span>,</span><br><span class="line">		data</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deleteRequest=<span class="function">(<span class="params">url,data</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> axios(&#123;</span><br><span class="line">		<span class="attr">url</span>:<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">		<span class="attr">method</span>:<span class="string">&quot;delete&quot;</span>,</span><br><span class="line">		data</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">	postKeyValueRequest,</span><br><span class="line">	getRequest,</span><br><span class="line">	postRequest,</span><br><span class="line">	putRequest,</span><br><span class="line">	deleteRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>封装之后，要想使用还得在使用的页面导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;postKeyValueRequest&#125; <span class="keyword">from</span> <span class="string">&quot;../util/api&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样太麻烦了，可以把它们定义成全局的插件使用，使用的时候无需导入，通过this去调用。</p>
<p><code>mian.js</code>定义成全局属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"><span class="keyword">import</span> ElementPlus <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="comment">// 这里开始</span></span><br><span class="line"><span class="keyword">import</span> &#123;postKeyValueRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./util/api&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./util/api&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;postRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./util/api&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;putRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./util/api&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;deleteRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./util/api&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line"><span class="comment">// 自定义全局组件</span></span><br><span class="line">app.config.globalProperties.postKeyValueRequest = postKeyValueRequest</span><br><span class="line">app.config.globalProperties.getRequest = getRequest</span><br><span class="line">app.config.globalProperties.postRequest = postRequest</span><br><span class="line">app.config.globalProperties.putRequest = putRequest</span><br><span class="line">app.config.globalProperties.deleteRequest = deleteRequest</span><br><span class="line">app.use(ElementPlus)</span><br><span class="line">	.use(router)</span><br><span class="line">	.use(store)</span><br><span class="line">	.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用的时候:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无需导入，通过this调用</span></span><br><span class="line"><span class="built_in">this</span>.postKeyValueRequest(<span class="string">&quot;/doLogin&quot;</span>,<span class="built_in">this</span>.user).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data) &#123;</span><br><span class="line">        ElMessage.success(data.message)</span><br><span class="line">        <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-跨域"><a href="#2-2-跨域" class="headerlink" title="2.2 跨域"></a>2.2 跨域</h4><p>前端是在8080端口启动，后端是在8081端口启动，在开发的时候，当前端去访问后端的时候，由于端口不一致，会导致跨域问题。</p>
<p>需要配置代理，在根目录下创建<code>vue.config.js</code>文件(文件名称固定),</p>
<p>代理和baseUrl不能同时设置，否则代理不生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">	<span class="comment">// 设置监听的别名，下面替换掉</span></span><br><span class="line">	<span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">		<span class="comment">// 服务器接口</span></span><br><span class="line">		<span class="attr">target</span>: <span class="string">&quot;http://localhost:8081&quot;</span>,</span><br><span class="line">		<span class="comment">// 是否代理websocket</span></span><br><span class="line">		<span class="attr">ws</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="comment">// 是否使用https</span></span><br><span class="line">		<span class="attr">secure</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="comment">// 是否跨域</span></span><br><span class="line">		<span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="comment">// 替换别名</span></span><br><span class="line">		<span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">			<span class="string">&#x27;^/&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是exports</span></span><br><span class="line"><span class="built_in">module</span>.exports= &#123;</span><br><span class="line">    <span class="comment">// 开发服务器,前端使用的端口</span></span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">		<span class="attr">host</span>:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">		<span class="attr">port</span>:<span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">		proxy</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-3-页面跳转"><a href="#2-3-页面跳转" class="headerlink" title="2.3 页面跳转"></a>2.3 页面跳转</h4><p>使用路由进行页面跳转有两种方式：</p>
<ul>
<li>replace:不能返回跳转前的页面</li>
<li>push:可以通过浏览器返回跳转前的页面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.replace(<span class="string">&quot;/home&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-4-session操作"><a href="#2-4-session操作" class="headerlink" title="2.4 session操作"></a>2.4 session操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到session,数据只能是String类型</span></span><br><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&quot;user&quot;</span>,<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line"><span class="comment">// 从session中获取,解析json字符串</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&quot;user&quot;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="2-5-获取路由参数"><a href="#2-5-获取路由参数" class="headerlink" title="2.5 获取路由参数"></a>2.5 获取路由参数</h4><p>children中的路由只能在它父级路由的<router-view>才能使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Login,</span><br><span class="line">    <span class="attr">hidden</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;菜单&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/test1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;选项一&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Test1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/test2&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;选项二&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Test2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从路由中获取参数，动态渲染菜单：</p>
<p>注意this.$router在setup函数中是不能使用this的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">default-active</span>=<span class="string">&quot;1&quot;</span> <span class="attr">router</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in routers&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!item.hidden&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">							<span class="tag">&lt;<span class="name">template</span> #<span class="attr">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">								<span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">								<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">							<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">							<span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">:index</span>=<span class="string">&quot;children.path&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(children,index) in item.children&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;children.name&#125;&#125;<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">el-main</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">name</span>: <span class="string">&quot;Menu&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="attr">routers</span>:<span class="built_in">this</span>.$router.options.routes</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><h4 id="处理后端返回数据"><a href="#处理后端返回数据" class="headerlink" title="处理后端返回数据"></a>处理后端返回数据</h4><p>从服务器端返回的数据中，component是字符串类型的，而router中的component是对象类型，需要进行转换。</p>
<p>我们封装一个<code>menu.js</code>来进行转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getRequest&#125; <span class="keyword">from</span> <span class="string">&quot;./api&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initMenu = <span class="function">(<span class="params">router, store</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 已经有数据了，不再渲染</span></span><br><span class="line">	<span class="keyword">if</span> (store.state.routes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向服务器请求菜单数据</span></span><br><span class="line">	getRequest(<span class="string">&quot;/system/menus&quot;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (data) &#123;</span><br><span class="line">			<span class="keyword">let</span> routers = data.data;</span><br><span class="line">			routers = trans(routers);</span><br><span class="line">			<span class="built_in">console</span>.log(routers)</span><br><span class="line">			<span class="comment">// todo addRoutes is not defined</span></span><br><span class="line">			<span class="comment">// router.addRoutes(routers);</span></span><br><span class="line">			<span class="comment">// 保存到store</span></span><br><span class="line">			store.commit(<span class="string">&#x27;initRouters&#x27;</span>, routers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将服务器返回的菜单数据转换成router,并返回格式化后的router</span></span><br><span class="line"><span class="keyword">const</span> trans = <span class="function">(<span class="params">routers</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> formatRouters = []</span><br><span class="line">	routers.forEach( <span class="function"><span class="params">router</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> &#123;path, name, component, iconCls, children, meta&#125; = router;</span><br><span class="line">		<span class="comment">// 如果有children,递归处理</span></span><br><span class="line">		<span class="keyword">if</span> (children) &#123;</span><br><span class="line">			children = trans(children);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> formatRouter = &#123;</span><br><span class="line">			path,</span><br><span class="line">			name,</span><br><span class="line">			iconCls,</span><br><span class="line">			meta,</span><br><span class="line">			children,</span><br><span class="line">			<span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">`@/views<span class="subst">$&#123;component&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		formatRouters.push(formatRouter);</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> formatRouters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">	initMenu</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，需要把数据保存在store中，这样才能全局使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">routes</span>:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">initRouters</span>(<span class="params">state,data</span>)</span> &#123;</span><br><span class="line">      state.routes = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="加载菜单的时机"><a href="#加载菜单的时机" class="headerlink" title="加载菜单的时机"></a>加载菜单的时机</h4><p>我们可以在加载Home页面的时候初始化菜单数据，但是如果采用这种方式，跳转到别的页面，又需要加载多一次菜单，这就不得不在每个页面都写上initMenu的方法。</p>
<p>可以使用<code>导航守卫</code>来监控路由，由跳转的路由来决定是否加载菜单数据。</p>
<p><code>mian.js</code>中注册前置导航守卫：</p>
<ul>
<li>to:对象类型,代表即将跳转的路由</li>
<li>from:对象类型,代表从哪个路由过来的</li>
<li>next:是一个函数，只有执行next()才会往下继续执行，关键所在</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.beforeEach( <span class="function">(<span class="params">to, <span class="keyword">from</span> ,next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 跳转到登录页</span></span><br><span class="line">	<span class="keyword">if</span>(to.path === <span class="string">&quot;/&quot;</span> )&#123;</span><br><span class="line">		next();</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		initMenu(router,store);</span><br><span class="line">		next();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然，在注销登录的时候也需要清空store.state.routes的值，否则退出登录后，看到的还是上一个人的菜单数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">logout</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$confirm(<span class="string">&#x27;确认注销登录吗?&#x27;</span>, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ElMessage.success(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 清除路由数据</span></span><br><span class="line">        <span class="built_in">this</span>.$store.state.routes = []</span><br><span class="line">        <span class="comment">// 返回到登录页面</span></span><br><span class="line">        <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ElMessage.success(<span class="string">&quot;撤销操作&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="使用图标库"><a href="#使用图标库" class="headerlink" title="使用图标库"></a>使用图标库</h4><p>使用font-awesome的图标库需要先安装，然后在main.js中导入对应的css文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install font-awesome</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;font-awesome/css/font-awesome.min.css&#x27;</span>;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/SpringBoot/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="1-Spring异步任务"><a href="#1-Spring异步任务" class="headerlink" title="1.Spring异步任务"></a>1.Spring异步任务</h3><p>Spring的异步任务使用步骤:</p>
<ol>
<li>通常是在service层的某个方法中需要使用异步操作，且方法通常返回CompletableFuture<T>类型。在方法上标注@Async注解表示该方法以异步执行。(标注@Async的类必须加入到Spring IOC容器中才有效)</li>
<li>在配置类上添加@EnableAsync,开启允许异步操作的开关。(也可以在主启动类上添加@EnableAsync注解,因为主启动类也是一个配置类)。<code>经过测试,如果不添加该注解,会以同步的方式执行。</code></li>
<li>(可选)可以配置一个Executor的bean来配置线程池的参数,且bean的方法名称为taskExecutor(官方好像有要求,但是换成其他名字好像也ok)。如果不自定义配置,Spring会提供一个默认的SimpleSyncTaskExecutor.</li>
<li>在Spring启动的时候(实现CommandLineRunner接口)或在定时器中调用需要执行的异步方法。</li>
</ol>
<p><code>经过测试,最简单的使用异步任务的方法是编写一个方法,在方法上添加@Async,开启@EnableAsync,通过定时器或者容器启动时执行该异步方法。</code></p>
<h3 id="2-DEMO"><a href="#2-DEMO" class="headerlink" title="2.DEMO"></a>2.DEMO</h3><p>在service中,异步调用Github的api查找用户信息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookupService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LookupService.class);</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LookupService</span><span class="params">(RestTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;User&gt; <span class="title">findUser</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start aysnc to Looking up user: []&quot;</span> , name);</span><br><span class="line">        String url = String.format(<span class="string">&quot;https://api.github.com/users/%s&quot;</span>, name);</span><br><span class="line">        User user = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            user = restTemplate.getForObject(url, User.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;remote call is encounter a issue...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;query user:&quot;</span> + user);</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配置类配置Executor,@EnableSync开启异步执行任务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;GithubLookup-&quot;</span>);</span><br><span class="line">        <span class="comment">// if add @Bean annotation,it is no longer necessary to manually call the executor.initialize() method</span></span><br><span class="line">        <span class="comment">// as this will be invoked automatically when the bean is initialized.</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在容器启动的时候,执行异步任务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LookupService lookupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;application start and run the AppRunner class..&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to lookup github user info</span></span><br><span class="line">        CompletableFuture&lt;User&gt; user1 = lookupService.findUser(<span class="string">&quot;kim.zhang&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;User&gt; user2 = lookupService.findUser(<span class="string">&quot;PivotalSoftware&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;User&gt; user3 = lookupService.findUser(<span class="string">&quot;Spring-Projects&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waiting all aysnc task executors finished</span></span><br><span class="line">        CompletableFuture.allOf(user1, user2, user3);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;finished find user,elapsed time is []&quot;</span>, System.currentTimeMillis() - start);</span><br><span class="line">        log.info(<span class="string">&quot;user1 is []&quot;</span>, user1.get());</span><br><span class="line">        log.info(<span class="string">&quot;user2 is []&quot;</span>, user2.get());</span><br><span class="line">        log.info(<span class="string">&quot;user3 is []&quot;</span>, user3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-Executor"><a href="#3-Executor" class="headerlink" title="3.Executor"></a>3.Executor</h3><p>Spring异步线程池的接口类，其实质是java.util.concurrent.Executor。</p>
<p>Spring 已经实现的异常线程池：</p>
<ol>
<li><p>SimpleAsyncTaskExecutor：<br>不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</p>
</li>
<li><p>SyncTaskExecutor:</p>
<p>这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方</p>
</li>
<li><p>ConcurrentTaskExecutor：</p>
<p>Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类</p>
</li>
<li><p>SimpleThreadPoolTaskExecutor：</p>
<p>是Quartz的SimpleThreadPool的类。线程池同时被quartz和非quartz使用，才需要使用此类</p>
</li>
<li><p>ThreadPoolTaskExecutor：</p>
<p>最常使用，推荐。其实质是对java.util.concurrent.ThreadPoolExecutor的包装。</p>
</li>
</ol>
<p><strong>需要特别注意的是Executor的initialize方法,如果添加了@Bean注解,是可以不调用这个方法的。但如果是通过实现AsyncConfigurer的方式来创建Executor,就需要调用initialize().</strong></p>
<h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h3><ul>
<li>对于异步方法返回值是Future的情况:<ul>
<li>方法一是在异步方法中捕获异常进行处理</li>
<li>方法二是在调用future.get()方法时捕获异常进行处理</li>
</ul>
</li>
<li>对于异步方法返回值是void的情况:<ul>
<li>通过自定义的AsyncUncaughtExceptionHandler处理异常</li>
</ul>
</li>
</ul>
<p>异步方法返回值是void:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserNoReturn</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;start aysnc to Looking up user: []&quot;</span> , name);</span><br><span class="line">    String url = String.format(<span class="string">&quot;https://api.github.com/users/%s&quot;</span>, name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里会抛出异常</span></span><br><span class="line">    User user = restTemplate.getForObject(url, User.class);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;query user:&quot;</span> + user);</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用异步方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LookupService lookupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;application start and run the AppRunner class..&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        lookupService.findUserNoReturn(<span class="string">&quot;kim.zhang&quot;</span>);</span><br><span class="line">        lookupService.findUserNoReturn(<span class="string">&quot;PivotalSoftware&quot;</span>);</span><br><span class="line">        lookupService.findUserNoReturn(<span class="string">&quot;Spring-Projects&quot;</span>);</span><br><span class="line">     </span><br><span class="line">        log.info(<span class="string">&quot;finished find user,elapsed time is []&quot;</span>, System.currentTimeMillis() - start);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>异步方法返回值是void,处理需要以下两个步骤：</p>
<ul>
<li>实现AsyncConfigurer接口,并实现该接口的方法,并将其加入到IOC容器</li>
<li>自定义一个类实现AsyncUncaughtExceptionHandler接口,处理异常处理的逻辑</li>
</ul>
<p><code>AsyncUncaughtExceptionHandler只会处理异步方法返回值是void的异常,不会处理返回值是Future的异常。</code></p>
<p>AsyncConfig:(不一定要是配置类，只要将实现AsyncConfigurer接口的类加入到IOC容器,并开启@EnableSync即可)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;GithubLookup-&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里没有添加@Bean注解,需要执行initialize方法</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AsyncExceptionHandler:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AsyncExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable ex, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;ex: &#123;&#125;&quot;</span> , ex);</span><br><span class="line">        log.error(<span class="string">&quot;method: &#123;&#125;&quot;</span>, method);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;params : &#123;&#125;&quot;</span>, params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/SpringBoot/%E6%8C%81%E4%B9%85%E5%B1%82/</url>
    <content><![CDATA[<h3 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1. JDBC"></a>1. JDBC</h3><hr>
<h4 id="1-1-整合JDBC"><a href="#1-1-整合JDBC" class="headerlink" title="1.1 整合JDBC"></a>1.1 整合JDBC</h4><ol>
<li>引入依赖</li>
</ol>
<p>这里需要注意的是mysql驱动的版本，springboot使用的mysql驱动默认版本是8，由于使用5.7版本的mysql，指定mysql驱动的版本。</p>
<p>druid数据库连接池不受springboot版本的管理，需要自己指定版本号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--myql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置文件，配置datasource</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>然后直接在类中注入JdbcTemplate即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-JDBC多数据源"><a href="#1-2-JDBC多数据源" class="headerlink" title="1.2 JDBC多数据源"></a>1.2 JDBC多数据源</h4><p>一个JdbcTemplate创建的时候需要一个datasource.</p>
<ol>
<li>在配置文件中配置多个datasource</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">one:</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">        <span class="attr">two:</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://47.96.224.198:3306/seata?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置类配置JdbcTemplate</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;datasourceOne&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSourceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSourceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplateOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSourceOne());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplateTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSourceTwo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用的时候注意注入的方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;jdbcTemplateOne&quot;)</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplateOne;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;jdbcTemplateTwo&quot;)</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplateTwo;</span><br></pre></td></tr></table></figure>



<h3 id="2-Mybatis"><a href="#2-Mybatis" class="headerlink" title="2.Mybatis"></a>2.Mybatis</h3><hr>
<h4 id="2-1-整合Mybatis"><a href="#2-1-整合Mybatis" class="headerlink" title="2.1 整合Mybatis"></a>2.1 整合Mybatis</h4><ol>
<li>引入依赖</li>
</ol>
<p>mybatis不是springBoot官方提供的，需要指定版本号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--myql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件配置datasource</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写Mapper interface</li>
</ol>
<p>为了让Springboot扫描到，可以在每个接口上都标记@Mapper注解，也可以在启动上标注@MapperScan扫描接口所在的包。<code>但两种方式只能选择其中一种。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; getAllStudent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.sise.demo.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写mapper文件</li>
</ol>
<p>mapper文件要注意的细节比较多。</p>
<p>mapper文件的存放位置可以在resources目录下，也可以在src目录下。</p>
<blockquote>
<p>resources目录下</p>
</blockquote>
<p>mapper.xml放在目录下</p>
<ul>
<li>检查xml文件所在package名称是否和Mapper interface所在的包名一一对应</li>
<li>xml文件的命名必须和Mapper interface的接口名称一一对应</li>
</ul>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210111215029252.png" alt="mapper.xml存放位置"></p>
<p>如果想自定义mapper.xml配置文件的名称和存放位置，可以在配置文件中指定：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>

<p>这样mapper.xml就可以存放在resources/mapper/目录下，且xml文件的命名随意了。</p>
<blockquote>
<p>src目录下</p>
</blockquote>
<p>将mapper.xml放在与StudentDao的相同目录下，报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invalid bound statement (not found): com.sise.demo.dao.StudentDao.getAllStudent</span><br></pre></td></tr></table></figure>

<p>这是由于maven打包的时候不会打包mapper.xml文件</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210111215523171.png" alt="mapper.xml在src目录下" style="zoom: 67%;" /><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210111215659819.png" alt="target目录下" style="zoom:67%;" /></p>
<p>因此我们需要在pom文件中指定该目录的资源文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--为了别人导入你的jar包能正常运行，也需要指定resources目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-MyBatis多数据源"><a href="#2-2-MyBatis多数据源" class="headerlink" title="2.2 MyBatis多数据源"></a>2.2 MyBatis多数据源</h4><ol>
<li>编写配置文件datasource</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">one:</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">        <span class="attr">two:</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://47.96.224.198:3306/seata?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置类</li>
</ol>
<p>Mybatis的配置需要SqlSessionFactory、SqlSessionTemplate.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.sise.demo.dao1&quot;,</span></span><br><span class="line"><span class="meta">        sqlSessionFactoryRef = &quot;sqlSessionFactoryOne&quot;,</span></span><br><span class="line"><span class="meta">        sqlSessionTemplateRef = &quot;sqlSessionTemplateOne&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigurationOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplateOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactoryOne());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactoryOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceOne());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span></span><br><span class="line">    <span class="function">DruidDataSource <span class="title">dataSourceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.sise.demo.dao2&quot;,</span></span><br><span class="line"><span class="meta">        sqlSessionFactoryRef = &quot;sqlSessionFactoryTwo&quot;,</span></span><br><span class="line"><span class="meta">        sqlSessionTemplateRef = &quot;sqlSessionTemplateTwo&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigurationTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplateTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactoryTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactoryTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceTwo());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span></span><br><span class="line">    <span class="function">DruidDataSource <span class="title">dataSourceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-打印sql"><a href="#2-3-打印sql" class="headerlink" title="2.3 打印sql"></a>2.3 打印sql</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">serialization:</span></span><br><span class="line">    <span class="attr">indent-output:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">    <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.ming.vhr.mapper:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-子查询映射"><a href="#2-4-子查询映射" class="headerlink" title="2.4 子查询映射"></a>2.4 子查询映射</h4><p>继承自BaseResultMap,Collections中对column取别名就可以，别名和sql中的别名一致。</p>
<p>查询的结果，由于resultMap的映射后，可能会与数据库中查询的行数不同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.ming.vhr.model.Menu&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;url&quot;</span> <span class="attr">property</span>=<span class="string">&quot;url&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;path&quot;</span> <span class="attr">property</span>=<span class="string">&quot;path&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;component&quot;</span> <span class="attr">property</span>=<span class="string">&quot;component&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;iconCls&quot;</span> <span class="attr">property</span>=<span class="string">&quot;iconCls&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;parentId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;parentId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;meta&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;keepalive&quot;</span> <span class="attr">property</span>=<span class="string">&quot;keepAlive&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;requireauth&quot;</span> <span class="attr">property</span>=<span class="string">&quot;requireAuth&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;menuTree&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.ming.vhr.model.Menu&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;children&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.ming.vhr.model.Menu&quot;</span> <span class="attr">column</span>=<span class="string">&quot;parentId&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;url2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;url&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;path2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;path&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;component2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;component&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;iconCls2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;iconCls&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;parentId2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;parentId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enabled2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;meta&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;keepalive2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;keepAlive&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;requireauth2&quot;</span> <span class="attr">property</span>=<span class="string">&quot;requireAuth&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;parent_menu_List&quot;</span> &gt;</span></span><br><span class="line">    menu.id,</span><br><span class="line">    menu.url,</span><br><span class="line">    menu.path,</span><br><span class="line">    menu.component,</span><br><span class="line">    menu.`name`,</span><br><span class="line">    menu.iconCls,</span><br><span class="line">    menu.keepAlive,</span><br><span class="line">    menu.requireAuth,</span><br><span class="line">    menu.enabled</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;children_menu_List&quot;</span> &gt;</span></span><br><span class="line">    sub_menu.id AS id2,</span><br><span class="line">    sub_menu.url AS url2,</span><br><span class="line">    sub_menu.path AS path2,</span><br><span class="line">    sub_menu.component AS component2,</span><br><span class="line">    sub_menu.`name` AS name2,</span><br><span class="line">    sub_menu.iconCls AS iconCls2,</span><br><span class="line">    sub_menu.keepAlive AS keepAlive2,</span><br><span class="line">    sub_menu.requireAuth AS requireAuth2,</span><br><span class="line">    sub_menu.parentId AS parentId2,</span><br><span class="line">    sub_menu.enabled AS enable2</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getMenuListByHrid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;menuTree&quot;</span>&gt;</span></span><br><span class="line">    select DISTINCT <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;parent_menu_List&quot;</span>/&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;children_menu_List&quot;</span>/&gt;</span></span><br><span class="line">    from menu</span><br><span class="line">    INNER JOIN menu sub_menu ON menu.id = sub_menu.parentId</span><br><span class="line">    INNER JOIN menu_role ON menu_role.mid = sub_menu.id</span><br><span class="line">    INNER JOIN hr_role ON hr_role.rid = menu_role.rid</span><br><span class="line">    INNER JOIN hr ON hr.id = hr_role.hrid</span><br><span class="line">    where hr.id = #&#123;hrid&#125;</span><br><span class="line">    and sub_menu.enabled = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="3-JPA"><a href="#3-JPA" class="headerlink" title="3.JPA"></a>3.JPA</h3><hr>
<h4 id="3-1-整合JPA"><a href="#3-1-整合JPA" class="headerlink" title="3.1 整合JPA"></a>3.1 整合JPA</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--myql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br></pre></td></tr></table></figure>

<p>如果不配置Dialect会出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;entityManagerFactory&#x27; defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.service.spi.ServiceException: Unable to create requested service [org.hibernate.engine.jdbc.env.spi.JdbcEnvironment]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提供实体类，提供接口继承JpaRepository</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;login&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;loginname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loninName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name =&quot;loginpassword&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型的第一个参数是操作的实体类型，第二个参数是操作的实体类型的主键类型。</p>
<p>接口不需要加@Repository注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-JPA多数据源的配置"><a href="#3-2-JPA多数据源的配置" class="headerlink" title="3.2 JPA多数据源的配置"></a>3.2 JPA多数据源的配置</h4><ol>
<li>配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">one:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">two:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://47.96.224.198:3306/bzbh?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.sise.demo.dao1&quot;,</span></span><br><span class="line"><span class="meta">entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanOne&quot;,</span></span><br><span class="line"><span class="meta">transactionManagerRef = &quot;platformTransactionManagerOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfigurationOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function">PlatformTransactionManager <span class="title">platformTransactionManagerOne</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(localContainerEntityManagerFactoryBeanOne(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LocalContainerEntityManagerFactoryBean <span class="title">localContainerEntityManagerFactoryBeanOne</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.dataSource(dataSourceOne())</span><br><span class="line">                .packages(<span class="string">&quot;com.sise.demo.model&quot;</span>)</span><br><span class="line">                .persistenceUnit(<span class="string">&quot;persistenceUnit1&quot;</span>)</span><br><span class="line">                .properties(jpaProperties.getProperties())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span></span><br><span class="line">    <span class="function">DruidDataSource <span class="title">dataSourceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.sise.demo.dao2&quot;,</span></span><br><span class="line"><span class="meta">entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanTwo&quot;,</span></span><br><span class="line"><span class="meta">transactionManagerRef = &quot;platformTransactionManagerTwo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfigurationTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PlatformTransactionManager <span class="title">platformTransactionManagerTwo</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(localContainerEntityManagerFactoryBeanTwo(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LocalContainerEntityManagerFactoryBean <span class="title">localContainerEntityManagerFactoryBeanTwo</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.dataSource(dataSourceTwo())</span><br><span class="line">                .packages(<span class="string">&quot;com.sise.demo.model&quot;</span>)</span><br><span class="line">                .persistenceUnit(<span class="string">&quot;persistenceUnit2&quot;</span>)</span><br><span class="line">                .properties(jpaProperties.getProperties())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span></span><br><span class="line">    <span class="function">DruidDataSource <span class="title">dataSourceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果出现以下错误,可能是多个数据源未加@Primary注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter 0 of method localContainerEntityManagerFactoryBeanOne in com.sise.demo.configuration.JpaConfigurationOne required a bean of type &#x27;org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder&#x27; that could not be found.</span><br></pre></td></tr></table></figure>



<h3 id="4-Redis"><a href="#4-Redis" class="headerlink" title="4.Redis"></a>4.Redis</h3><hr>
<h4 id="4-1-整合Redis"><a href="#4-1-整合Redis" class="headerlink" title="4.1 整合Redis"></a>4.1 整合Redis</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/SpringBoot/SpringBoot/</url>
    <content><![CDATA[<h3 id="3-整合视图层"><a href="#3-整合视图层" class="headerlink" title="3.整合视图层"></a>3.整合视图层</h3><hr>
<h4 id="3-1-整合Freemarker"><a href="#3-1-整合Freemarker" class="headerlink" title="3.1 整合Freemarker"></a>3.1 整合Freemarker</h4><p>SpringBoot提供了Freemarker的自动配置类。只需要将freemark依赖导入，就可以使用freemarker.</p>
<p>查看<code>FreeMarkerProperties</code>,只需要把模板文件放在templates目录下，且文件以.ftlh结尾就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.freemarker&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerProperties</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">&quot;.ftlh&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以通过配置文件修改默认的配置，如以下将文件后缀名修改为ftl：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-整合Thymeleaf"><a href="#3-2-整合Thymeleaf" class="headerlink" title="3.2 整合Thymeleaf"></a>3.2 整合Thymeleaf</h4><h3 id="4-JSON"><a href="#4-JSON" class="headerlink" title="4.JSON"></a>4.JSON</h3><hr>
<p>所有的JSON生成都离不开相关的HttpMessageConverter.</p>
<p>HttpMessageConverter主要有两大功能：</p>
<ul>
<li>将服务端返回的对象序列化成JSON字符串</li>
<li>将前端传来的JSON字符串反序列化成Java对象</li>
</ul>
<p>SpringBoot中自动配置了Jackson和Gson的HttpMessageConverter.</p>
<p>所以，如果用户使用Jackson和Gson的话，如果没有其他额外的配置，则只需要添加依赖即可。</p>
<h4 id="4-1-Jackson"><a href="#4-1-Jackson" class="headerlink" title="4.1 Jackson"></a>4.1 Jackson</h4><p>如果引入了spring-boot-starter-web模块的话，SpringBoot默认会引入Jackson依赖。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210107214534564.png" alt="Jackson依赖"></p>
<p>Jackson的自动配置类：<code>JacksonHttpMessageConvertersConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JacksonHttpMessageConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="comment">// 如果导入了jsckson的依赖，条件成立，SpringBoot会自动配置一个MaapingJackson2HttpMessageConverter</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(ObjectMapper.class)</span> </span><br><span class="line">	<span class="meta">@ConditionalOnBean(ObjectMapper.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(name = HttpMessageConvertersAutoConfiguration.PREFERRED_MAPPER_PROPERTY,</span></span><br><span class="line"><span class="meta">			havingValue = &quot;jackson&quot;, matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingJackson2HttpMessageConverterConfiguration</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有提供MappingJackson2HttpMessageConverter的类,SpringBoot默认为我们提供MappingJackson2HttpMessageConverter，它注入一个ObjectMapper,而ObjectMapper是由JacksonAutoConfiguration类提供的</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class,</span></span><br><span class="line"><span class="meta">				ignoredType = &#123;			&quot;org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter&quot;,</span></span><br><span class="line"><span class="meta">						&quot;org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter&quot; &#125;)</span></span><br><span class="line">		<span class="function">MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MappingJackson2HttpMessageConverter(objectMapper);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试小栗子：只需要引入jackson依赖，如果没有其他额外的配置，则可直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; json() &#123;</span><br><span class="line">        ArrayList&lt;Map&lt;String,Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>,i);</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>+i);</span><br><span class="line">            map.put(<span class="string">&quot;date&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">            list.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07T14:00:00.094+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07T14:00:00.094+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07T14:00:00.094+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07T14:00:00.094+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07T14:00:00.094+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日期格式化</p>
</blockquote>
<p>1.如果是在实体类中，可以使用@JsonFormat(pattern=”yyyy-MM-dd”)标记在实体属性上。这种方式有一个弊端，如果有多个实体类，需要在每一个实体类的属性上都添加注解</p>
<p>2.自动提供一个MappingJackson2HttpMessageConverter,提供日期格式化的功能</p>
<p>3.自己提供一个ObjectMapper,提供日期格式化的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一:自己提供一个mappingJackson2HttpMessageConverter，本质上也就是设置了ObjectMapper</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MappingJackson2HttpMessageConverter(objectMapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二: 既然mappingJackson2HttpMessageConverter也是设置ObjectMapper,那我提供一个自己的ObjectMapper即可</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式三： 结合方式一和方式二</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用注入的objectMapper来构建MappingJackson2HttpMessageConverter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MappingJackson2HttpMessageConverter(objectMapper);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 自己构建ObjectMapper</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07 22:16:57&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07 22:16:57&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07 22:16:57&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07 22:16:57&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-01-07 22:16:57&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoming4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="4-2-Gson"><a href="#4-2-Gson" class="headerlink" title="4.2 Gson"></a>4.2 Gson</h4><p>SpringBoot也提供了Gson的<code>GsonHttpMessageConverter</code></p>
<p>如果无需其他的配置,只要排除默认的Jackson依赖，引入Gson依赖即可使用。</p>
<p>Gson版本无需指定，由SpringBoot控制。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>GsonHttpMessageConverter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 如果不存在Gson的类话，自动配置生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Gson.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GsonHttpMessageConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(Gson.class)</span></span><br><span class="line">    <span class="meta">@Conditional(PreferGsonOrJacksonAndJsonbUnavailableCondition.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonHttpMessageConverterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供GsonHttpMessageConverter</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function">GsonHttpMessageConverter <span class="title">gsonHttpMessageConverter</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">            GsonHttpMessageConverter converter = <span class="keyword">new</span> GsonHttpMessageConverter();</span><br><span class="line">            converter.setGson(gson);</span><br><span class="line">            <span class="keyword">return</span> converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日期格式化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GsonHttpMessageConverter <span class="title">gsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().setDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).create();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GsonHttpMessageConverter(gson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-3-FastJson"><a href="#4-3-FastJson" class="headerlink" title="4.3 FastJson"></a>4.3 FastJson</h4><p>SpringBoot没有提供FastJsonHttpMessageConverter，如果需要使用FastJson,需要自己提供HttpMessageConverter.</p>
<p>排除默认的Jackson依赖，引入FastJson依赖。</p>
<p>FastJson版本不受SpringBoot控制，需要自己引入版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.73<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写FastJson的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastJsonHttpMessageConverter <span class="title">fastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日期格式化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastJsonHttpMessageConverter <span class="title">fastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        config.setDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        converter.setFastJsonConfig(config);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在测试3中JSON格式化的过程中，发现每一种JSON对日期的默认处理方式都不同。</strong></p>
<h3 id="5-静态资源访问"><a href="#5-静态资源访问" class="headerlink" title="5.静态资源访问"></a>5.静态资源访问</h3><hr>
<h4 id="5-1-默认的静态资源访问规则"><a href="#5-1-默认的静态资源访问规则" class="headerlink" title="5.1 默认的静态资源访问规则"></a>5.1 默认的静态资源访问规则</h4><p>SpirngBoot中，和Web有关的配置类是<code>WebMvcAutoConfiguration</code></p>
<p>其中，和静态资源访问有关的方法是addResourceHandlers</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存相关</span></span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点，这里返回的staticPathPattern是/**</span></span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this.resourceProperties.getStaticLocations()返回的是静态资源存放的位置：<br>在ResourceProperties类中定义的常量数组，也就是说，放在这4个目录下的静态资源，SpringBoot可以直接访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>getResourceLocations()方法将默认的4个目录作为参数传递进去，加上SERVLET_LOCATIONS这么一个路径返回。</p>
<p>SERVLET_LOCATIONS是定义的一个常量/，代表着webapp的目录，也就是说，现在springboot默认能访问到的存放静态资源的路径有5个。</p>
<p>且它们的优先级是按照数组的顺序。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210107232317191.png" alt="image-静态资源优先级"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String[] getResourceLocations(String[] staticLocations) &#123;</span><br><span class="line">    String[] locations = <span class="keyword">new</span> String[staticLocations.length + SERVLET_LOCATIONS.length];</span><br><span class="line">    System.arraycopy(staticLocations, <span class="number">0</span>, locations, <span class="number">0</span>, staticLocations.length);</span><br><span class="line">    System.arraycopy(SERVLET_LOCATIONS, <span class="number">0</span>, locations, staticLocations.length, SERVLET_LOCATIONS.length);</span><br><span class="line">    <span class="keyword">return</span> locations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-自定义资源位置"><a href="#5-2-自定义资源位置" class="headerlink" title="5.2 自定义资源位置"></a>5.2 自定义资源位置</h4><blockquote>
<p>通过配置文件指定</p>
</blockquote>
<p>一旦在配置文件中指定了static-locations，springboot默认的4个目录下的位置会被配置文件中指定的替换，也就是说CLASSPATH_RESOURCE_LOCATIONS数组下指定的静态资源文件存放路径不再生效。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 指定静态资源存放路径</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> <span class="string">classpath:/ming/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过配置类指定</p>
</blockquote>
<p>需要实现WebMvcConfigurer接口，重写addResourceHandlers方法。</p>
<p>addResourceHandler对应着配置文件中的spring.mvc.static-pattern。</p>
<p>addResourceLocations对应着配置文件中的spring.resource.static-location。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">        .addResourceLocations(<span class="string">&quot;classpath:/ming/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-文件上传"><a href="#6-文件上传" class="headerlink" title="6. 文件上传"></a>6. 文件上传</h3><hr>
<p>Web文件上传通常有2种方案：</p>
<ul>
<li><p>CommonMultipartResolver(需要引入common-fileupload组件)</p>
</li>
<li><p>StandardServletMultipartResolver(需要Servlet 3.0以上才支持)</p>
</li>
</ul>
<p>SpringBoot使用的是StandardServletMultipartResolver。</p>
<blockquote>
<p>配置文件上传相关属性</p>
</blockquote>
<p>可以直接在配置文件中指定与文件上传相关的一些属性，以最大上传文件大小为例。</p>
<p>如果文件超出限制大小，后端报错The field file exceeds its maximum permitted size of 1024 bytes.</p>
<p>此时断点都进不去，由于文件超出限制大小，请求被拦截了。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">1KB</span>  <span class="comment"># 大写</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-单文件上传"><a href="#4-1-单文件上传" class="headerlink" title="4.1 单文件上传"></a>4.1 单文件上传</h4><p>文件上传后端处理需要注意的问题：</p>
<ul>
<li>确保保存目录的存在，否则会报FileNotFoundException</li>
<li>文件名称相同的处理</li>
<li>静态资源访问的处理，如果自定了静态资源访问路径，要注意自定义的静态资源访问路径覆盖springboot默认的静态资源访问路径的问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里格式化的方式要和返回的路径和保存的路径拼接成最终的字符串，注意格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;/yyyy/MM/dd/&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 文件上传必须是post请求，get请求没有请求体</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(HttpServletRequest request, MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String formatDate = LocalDate.now().format(formatter);</span><br><span class="line">        <span class="comment">// 文件要保存的路径，实际上是webapp目录下，而webapp目录默认是静态资源可以访问的路径，可以通过浏览器直接访问文件</span></span><br><span class="line">        String savePath = request.getServletContext().getRealPath(<span class="string">&quot;/img&quot;</span>) + formatDate;</span><br><span class="line">        <span class="comment">// 如果目录不存在，需要创建目录，否则报错FileNotFoundException</span></span><br><span class="line">        File dest = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="keyword">if</span>(!dest.exists())&#123;</span><br><span class="line">            dest.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理文件名称 uuid+后缀名</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String fileName = uuid + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 保存文件到dest目录</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> File(dest, fileName));</span><br><span class="line">        <span class="comment">// 返回文件路径</span></span><br><span class="line">        <span class="keyword">return</span> request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + <span class="string">&quot;/img&quot;</span> + formatDate + fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从后端接收到的file来看，使用的是StandardServletMultipartResplver:</p>
<p><img src="C:\Users\zjm16\AppData\Roaming\Typora\typora-user-images\image-20210109125716984.png" alt="后端接收到的file"></p>
<blockquote>
<p> 前端通过表单上传文件</p>
</blockquote>
<p>需要注意：</p>
<ul>
<li>name属性的名称要和后端参数的名称一致</li>
<li>需要指定enctype</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过Ajax方式上传文件</p>
</blockquote>
<p>$(“#file”)[0]是将jq对象转换成DOM对象，由于是单文件上传，files[0]取出第一个文件。</p>
<p><code>processData、contentType</code>属性的设置是非常重要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;msg&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;保存&quot; onclick=&quot;uploadFile()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function uploadFile()&#123;</span><br><span class="line">        var file = $(&quot;#file&quot;)[0].files[0];</span><br><span class="line">        var formData = new FormData();</span><br><span class="line">        formData.append(&quot;file&quot;,file);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:&quot;/upload&quot;,</span><br><span class="line">            type:&quot;post&quot;,</span><br><span class="line">            data: formData,</span><br><span class="line">            // 告诉JQuery不要对数据进行处理</span><br><span class="line">            processData: false,</span><br><span class="line">            // 告诉JQuery不要设置content-type</span><br><span class="line">            contentType: false,</span><br><span class="line">            success: function (result) &#123;</span><br><span class="line">                $(&quot;#msg&quot;).text(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-多文件上传"><a href="#4-2-多文件上传" class="headerlink" title="4.2 多文件上传"></a>4.2 多文件上传</h4><p>多文件上传有2中情况，处理请求的方式也不同：</p>
<ul>
<li>一个input框，上传多个文件(后端接收一个MultipartFile数组，循环保存)</li>
<li>多个input框(后端绑定多个MultipartFile参数，对应前端的多个input框的name属性)</li>
</ul>
<p>以下以一个input框,上传多个文件为例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;/yyyy/MM/dd/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/uploads&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">uploads</span><span class="params">(HttpServletRequest request, MultipartFile[] files)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(files.length);</span><br><span class="line">        String formatDate = LocalDate.now().format(formatter);</span><br><span class="line">        <span class="comment">// 文件要保存的路径，实际上是webapp目录下，而webapp目录默认是静态资源可以访问的路径，可以通过浏览器直接访问文件</span></span><br><span class="line">        String savePath = request.getServletContext().getRealPath(<span class="string">&quot;/img&quot;</span>) + formatDate;</span><br><span class="line">        <span class="comment">// 如果目录不存在，需要创建目录，否则报错FileNotFoundException</span></span><br><span class="line">        File dest = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="keyword">if</span>(!dest.exists())&#123;</span><br><span class="line">            dest.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; filePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">            <span class="comment">// 处理文件名称 uuid+后缀名</span></span><br><span class="line">            String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            String originalFilename = file.getOriginalFilename();</span><br><span class="line">            String fileName = uuid + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">// 保存文件到dest目录</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> File(dest, fileName));</span><br><span class="line">            String filePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + <span class="string">&quot;/img&quot;</span> + formatDate + fileName;</span><br><span class="line">            filePaths.add(filePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回文件路径</span></span><br><span class="line">        <span class="keyword">return</span> filePaths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用form表单：</p>
</blockquote>
<p><code>在file组件下添加multiple表示上传多文件</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/uploads&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用ajax:</p>
</blockquote>
<p><code>在file组件下添加multiple表示上传多文件</code></p>
<p>通过formData传递参数到后台的方式非常讲究，经过测试，以下两种方式后台接收不到参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> files = $(<span class="string">&quot;#files&quot;</span>)[<span class="number">0</span>].files;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    formData.append(<span class="string">&quot;files[&quot;</span> + i + <span class="string">&quot;]&quot;</span>, files[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> files = $(<span class="string">&quot;#files&quot;</span>)[<span class="number">0</span>].files;</span><br><span class="line">formData.append(<span class="string">&quot;files&quot;</span>,files);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的传递方式</span></span><br><span class="line"><span class="keyword">var</span> files = $(<span class="string">&quot;#files&quot;</span>)[<span class="number">0</span>].files;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    formData.append(<span class="string">&quot;files&quot;</span>, files[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要注意的一点是FormData是一个特殊的对象，通过console.log打印是{}，而实际上它是有值的。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;uploadFile()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> files = $(<span class="string">&quot;#files&quot;</span>)[<span class="number">0</span>].files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            formData.append(<span class="string">&quot;files&quot;</span>, files[i]);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">url</span>: <span class="string">&quot;/uploads&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">processData</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">contentType</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: formData,</span></span><br><span class="line"><span class="javascript">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">&quot;#msg&quot;</span>).text(result)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="4-3-使用FastJson报错Content-Type-cannot-contain-wildcard-type-‘-’"><a href="#4-3-使用FastJson报错Content-Type-cannot-contain-wildcard-type-‘-’" class="headerlink" title="4.3 使用FastJson报错Content-Type cannot contain wildcard type ‘*’"></a>4.3 使用FastJson报错Content-Type cannot contain wildcard type ‘*’</h4><p>在新版本的fastJson,FastJsonHttpMessageConverter初始化时，设置了MediaType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MediaType.ALL是 /</span></span><br><span class="line">    <span class="keyword">super</span>(MediaType.ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在SpringBoot的AbstractHttpMessageConverter类中,write的过程中，addDefaultHeaders方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">headers.setContentType(contentTypeToUse);</span><br></pre></td></tr></table></figure>

<p>setContentType方法中检查了Content-type不能含有通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(<span class="meta">@Nullable</span> MediaType mediaType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.isTrue(!mediaType.isWildcardType(), <span class="string">&quot;Content-Type cannot contain wildcard type &#x27;*&#x27;&quot;</span>);</span><br><span class="line">        Assert.isTrue(!mediaType.isWildcardSubtype(), <span class="string">&quot;Content-Type cannot contain wildcard subtype &#x27;*&#x27;&quot;</span>);</span><br><span class="line">        set(CONTENT_TYPE, mediaType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        remove(CONTENT_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法是在配置FastJsonHttpMessageConverter时候，设置Content-type:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastJsonHttpMessageConverter <span class="title">fastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        List&lt;MediaType&gt; supportMediaTypes = <span class="keyword">this</span>.getSupportMediaTypes();</span><br><span class="line">        converter.setSupportedMediaTypes(supportMediaTypes);</span><br><span class="line">        config.setDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        converter.setFastJsonConfig(config);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;MediaType&gt; <span class="title">getSupportMediaTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;MediaType&gt; supportedMediaTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_JSON);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_ATOM_XML);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_PDF);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_RSS_XML);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_XHTML_XML);</span><br><span class="line">        supportedMediaTypes.add(MediaType.APPLICATION_XML);</span><br><span class="line">        supportedMediaTypes.add(MediaType.IMAGE_GIF);</span><br><span class="line">        supportedMediaTypes.add(MediaType.IMAGE_JPEG);</span><br><span class="line">        supportedMediaTypes.add(MediaType.IMAGE_PNG);</span><br><span class="line">        supportedMediaTypes.add(MediaType.TEXT_EVENT_STREAM);</span><br><span class="line">        supportedMediaTypes.add(MediaType.TEXT_HTML);</span><br><span class="line">        supportedMediaTypes.add(MediaType.TEXT_MARKDOWN);</span><br><span class="line">        supportedMediaTypes.add(MediaType.TEXT_PLAIN);</span><br><span class="line">        supportedMediaTypes.add(MediaType.TEXT_XML);</span><br><span class="line">        <span class="keyword">return</span> supportedMediaTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-ControllerAdvice"><a href="#7-ControllerAdvice" class="headerlink" title="7.@ControllerAdvice"></a>7.@ControllerAdvice</h3><hr>
<h4 id="7-1-全局异常处理"><a href="#7-1-全局异常处理" class="headerlink" title="7.1 全局异常处理"></a>7.1 全局异常处理</h4><p>可以定义一个类，专门用来处理异常。在类上添加@ControllerAdvice注解，在方法上添加@ExceptionHandler(xxxException.class)注解，当发生异常的时候，会被这个方法捕获。</p>
<p>异常的处理方式可以返回一个错误页面，也可以通过response直接返回异常信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MaxUploadSizeExceededException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handlerFileException</span><span class="params">(MaxUploadSizeExceededException e)</span> </span>&#123;</span><br><span class="line">        ModelAndView model = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        model.addObject(<span class="string">&quot;error&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-预设全局数据"><a href="#7-2-预设全局数据" class="headerlink" title="7.2 预设全局数据"></a>7.2 预设全局数据</h4><p>可以在@ControllerAdvice标记的类中，配合@ModelAttribute返回一些全局通用的数据，任何一个controller都能获取该数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@ModelAttribute(value = &quot;info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">globalInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;version&quot;</span>,<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在任意一个controller中都可以获取@ControllerAdvice中返回的数据：</p>
<p>key为@ModelAttribute指定的value值，value为@ModelAttrrbute方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">globalInfo</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一 ，key=info,value=hashmap</span></span><br><span class="line">    Map&lt;String, Object&gt; attribute = (Map&lt;String, Object&gt;) model.getAttribute(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="comment">// 方式二</span></span><br><span class="line">    Map&lt;String, Object&gt; map = model.asMap();</span><br><span class="line">    Map&lt;String, Object&gt; attribute1  = (Map&lt;String, Object&gt;) map.get(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> attribute1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-自定义异常处理"><a href="#8-自定义异常处理" class="headerlink" title="8.自定义异常处理"></a>8.自定义异常处理</h3><hr>
<h4 id="8-1-默认的异常处理机制"><a href="#8-1-默认的异常处理机制" class="headerlink" title="8.1 默认的异常处理机制"></a>8.1 默认的异常处理机制</h4><blockquote>
<p>静态错误页面</p>
</blockquote>
<p>在static目录下新增目录error,在error目录下创建<code>状态码.html</code>文件，springBoot会根据状态码的不同返回不同的错误页面。</p>
<p>比如在error目录下创建404.html，500.html的页面，当出现404错误的时候，会返回404.html页面，当出现500错误的时候，会返回500.html页面。</p>
<p>这种做法很繁琐，状态码有很多，就意味着一个状态码对应着一个错误页面。因此，SpringBoot提供了一种模糊的匹配。</p>
<p>比如在error目录下创建4xx.html，5xx.html的页面，当出现4xx错误的时候，会返回4x.html页面，当出现5xx错误的时候，会返回5xx.html页面。</p>
<p>如果404.html和4xx.html同时存在。404.html的优先级会高于4xx.html。<code>精确匹配的优先级高于模糊匹配</code></p>
<blockquote>
<p>动态错误页面</p>
</blockquote>
<p>静态的错误页面，不能够提供更好的错误提示。因此，SpringBoot还提供了一种动态的错误页面，自动收集了错误信息，可以展示在页面上。</p>
<p>动态错误页面存放在template下的error目录。其文件名的命名规则跟静态页面的规则相同，比如400.html,4xx.html等。</p>
<p>唯一不同的是，它可以渲染错误信息,这些错误信息是SpringBoot为我们收集的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">出错的url：<span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;path&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">出错的时间：<span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;timestamp&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">状态码：<span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">错误类型:<span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;error&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">错误信息:<span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当静态页面和动态页面同时存在时，<code>动态页面的优先级高于静态页面</code></p>
<p>在SpringBoot2.4.1的版本中，如果没有在error目录下创建静态页面或动态页面，在template目录下创建的error.html也会被解析成动态的错误页面。</p>
<p><strong>优先级小结：精确高于模糊，动态高于静态。</strong></p>
<h4 id="8-2-异常处理源码分析"><a href="#8-2-异常处理源码分析" class="headerlink" title="8.2 异常处理源码分析"></a>8.2 异常处理源码分析</h4><p>ErrotMvcAutoConfiguration自动配置类中， 如果我们没有提供ErrorViewResolver接口的实现类，SpringBoot默认为我们提供一个DefaultErrorViewResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(DispatcherServlet.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span></span><br><span class="line"><span class="function">DefaultErrorViewResolver <span class="title">conventionErrorViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultErrorViewResolver(<span class="keyword">this</span>.applicationContext, <span class="keyword">this</span>.resourceProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在BasicErrorController类中errorHtml方法中查找错误页面，如果没有找到错误页面，返回一个error.html的动态页面。也就是说在template目录下创建的error页面会被当成错误页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model = Collections</span><br><span class="line">        .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="comment">// 错误页面处理</span></span><br><span class="line">    ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> (modelAndView != <span class="keyword">null</span>) ? modelAndView : <span class="keyword">new</span> ModelAndView(<span class="string">&quot;error&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，resolveErrorView是处理错误页面的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpStatus status,Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 错误页面视图解析器，如果不能获取到对应的错误页面，返回null</span></span><br><span class="line">    <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">        <span class="comment">// 调用下面的resolveErrorView方法</span></span><br><span class="line">        ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> modelAndView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取状态码对应的错误页面</span></span><br><span class="line">    ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);</span><br><span class="line">    <span class="comment">// 获取不到状态码对应的页面，尝试模糊匹配错误页面，这也就体现了精确匹配的优先级高于模糊匹配</span></span><br><span class="line">    <span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">        modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="8-3-自定义异常数据"><a href="#8-3-自定义异常数据" class="headerlink" title="8.3 自定义异常数据"></a>8.3 自定义异常数据</h4><p>ErrotMvcAutoConfiguration自动配置类中,如果我们没有提供ErrorAttributes接口的实现类，SpringBoot默认为我们提供一个DefaultErrorAttributes。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultErrorAttributes <span class="title">errorAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultErrorAttributes(<span class="keyword">this</span>.serverProperties.getError().isIncludeException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以自己提供一个ErrorAttributes的实现类，继承自DefaultErrorAttributes，自己提供异常数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAttributeConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; originalMap = <span class="keyword">super</span>.getErrorAttributes(webRequest, includeStackTrace);</span><br><span class="line">        originalMap.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;my error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> originalMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210110135117273.png" alt="自定义异常数据"></p>
<h4 id="8-4-自定义异常视图"><a href="#8-4-自定义异常视图" class="headerlink" title="8.4 自定义异常视图"></a>8.4 自定义异常视图</h4><p>我们可以自己提供一个ErrorViewResolver的实现类，继承自DefaultErrorViewResolver，自己提供异常视图：</p>
<p>需要注意的一点是：<code>model的数据是保存在unmodifiableMap的，如果想修改，可以先复制再修改，或覆盖它原本的值。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorViewResolverConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorViewResolverConfiguration</span><span class="params">(ApplicationContext applicationContext, ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(applicationContext, resourceProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应着template/error/myerror.html</span></span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/error/myerror&quot;</span>,model);</span><br><span class="line">        <span class="comment">// 也可以添加上自定义的异常数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;myerror info&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210110142819449.png" alt="model数据"></p>
<h3 id="9-CORS跨域"><a href="#9-CORS跨域" class="headerlink" title="9.CORS跨域"></a>9.CORS跨域</h3><h4 id="9-1-同源问题"><a href="#9-1-同源问题" class="headerlink" title="9.1 同源问题"></a>9.1 同源问题</h4><p>同源指的是<code>协议、域名、端口</code>要相同。</p>
<p>同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取用户的数据。</p>
<p>目前所有的浏览器都支持同源策略。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>目前，如果非同源，共有三种行为收到限制：</p>
<ul>
<li>Cookie、LocalStorage和IndexDB无法读取</li>
<li>DOM无法获得</li>
<li>AJAX请求不能发送</li>
</ul>
<h4 id="9-2-解决AJAX同源问题"><a href="#9-2-解决AJAX同源问题" class="headerlink" title="9.2 解决AJAX同源问题"></a>9.2 解决AJAX同源问题</h4><ul>
<li>JSONP(只支持GET请求)</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h4 id="9-3-CORS"><a href="#9-3-CORS" class="headerlink" title="9.3 CORS"></a>9.3 CORS</h4><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">阮一峰博客</a></p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<h4 id="9-4-SpringBoot中使用CORS"><a href="#9-4-SpringBoot中使用CORS" class="headerlink" title="9.4 SpringBoot中使用CORS"></a>9.4 SpringBoot中使用CORS</h4><p>案例：使用8081端口的应该发送AJAX请求8080端口的服务，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/hello&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).text(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>浏览器控制台报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://localhost:8080/hello&#x27; from origin &#x27;http://localhost:8081&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.text</span><br></pre></td></tr></table></figure>

<p>我们修改一下服务端，让它可以接收8081的请求,只需要加上@CorssOrigin注解，指明接收哪个域的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8081再次向8080发起AJAX请求，请求成功。我们来看下请求头信息：</p>
<p><code>Origin</code>用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /hello HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;87&quot;, &quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;87&quot;</span><br><span class="line">Accept: */*</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br><span class="line">Origin: http://localhost:8081  # </span><br><span class="line">Sec-Fetch-Site: same-site</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Referer: http://localhost:8081/</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure>

<p>响应信息：</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Vary: Origin</span><br><span class="line">Vary: Access-Control-Request-Method</span><br><span class="line">Vary: Access-Control-Request-Headers</span><br><span class="line">Access-Control-Allow-Origin: http://localhost:8081</span><br><span class="line">Content-Type: text/plain;charset=UTF-8</span><br><span class="line">Content-Length: 5</span><br><span class="line">Date: Sun, 10 Jan 2021 12:06:58 GMT</span><br></pre></td></tr></table></figure>

<h4 id="9-5-全局配置CROS"><a href="#9-5-全局配置CROS" class="headerlink" title="9.5 全局配置CROS"></a>9.5 全局配置CROS</h4><p>@CrossOrigin可以加在方法上，也可以加在类上。但是如果有多个方法或多个类,还是要写多次@CrossOrigin。</p>
<p>可以在全局配置，只需要写一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 所有接口</span></span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://localhost:8081&quot;</span>) <span class="comment">// 可接收来自http://localhost:8081的请求</span></span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)  <span class="comment">// 可接收所有请求</span></span><br><span class="line">            .allowedMethods(<span class="string">&quot;*&quot;</span>); <span class="comment">// 可接收所有的请求方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-探测请求"><a href="#9-6-探测请求" class="headerlink" title="9.6 探测请求"></a>9.6 探测请求</h4><p>当AJAX发送PUT/DELETE请求，或Content-type为application/json的请求时，由于不知道服务端支不支持PUT方法，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>服务端接收到探测请求后，会返回一些信息。</p>
<p>请求信息：</p>
<p>预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS /hello HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Accept: */*</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Origin: http://localhost:8081</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Site: same-site</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Referer: http://localhost:8081/</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure>

<p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>下面的HTTP响应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://localhost:8081</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。</p>
<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>服务器回应的其他CORS相关字段如下：</p>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期1800秒，即允许缓存该条回应1800秒，在此期间，不用发出另一条预检请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Vary: Origin</span><br><span class="line">Vary: Access-Control-Request-Method</span><br><span class="line">Vary: Access-Control-Request-Headers</span><br><span class="line">Access-Control-Allow-Origin: http://localhost:8081</span><br><span class="line">Access-Control-Allow-Methods: PUT</span><br><span class="line">Access-Control-Max-Age: 1800</span><br><span class="line">Allow: GET, HEAD, POST, PUT, DELETE, OPTIONS, PATCH</span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Sun, 10 Jan 2021 12:42:33 GMT</span><br></pre></td></tr></table></figure>

<h3 id="10-注册拦截器"><a href="#10-注册拦截器" class="headerlink" title="10.注册拦截器"></a>10.注册拦截器</h3><hr>
<p>编写拦截器，需要实现HandlerInterceptor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置类中创建自己编写的拦截器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(helloInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HandlerInterceptor <span class="title">helloInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在拦截器中添加@Component注解将拦截器加入到IOC容器当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中使用@Autowired注入拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloInterceptor helloInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(helloInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种注入的方法，如果不使用@ConfigurationProperties注入配置等功能，也是可以的。不过，推荐一起写在配置类中，方便管理。</p>
<h3 id="11-系统启动任务"><a href="#11-系统启动任务" class="headerlink" title="11.系统启动任务"></a>11.系统启动任务</h3><hr>
<h4 id="11-1-CommandLineRunner"><a href="#11-1-CommandLineRunner" class="headerlink" title="11.1 CommandLineRunner"></a>11.1 CommandLineRunner</h4><p>实现接口CommandLineRunner,并将其加入容器,CommandLineRunner就生效了。</p>
<p>如果有多个Runner,可以使用@Order指定优先级。@Order指定的数字越小，优先级越大。</p>
<p>@Order默认的优先级是Integet.MAX_VALUE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里接收的参数是命令行启动时传递的参数..</span></span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置启动时命令行传递参数：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210110210942742.png" alt="配置启动参数"></p>
<h4 id="11-2-ApplicationRunner"><a href="#11-2-ApplicationRunner" class="headerlink" title="11.2 ApplicationRunner"></a>11.2 ApplicationRunner</h4><p>实现接口ApplicationRunner，并将其加入容器,ApplicationRunner就生效了。</p>
<p>设定命令行传参为hello world –param=hahaha</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// [hello, world, --param=hahaha]</span></span><br><span class="line">        String[] sourceArgs = args.getSourceArgs();</span><br><span class="line">        System.out.println(Arrays.toString(sourceArgs));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [hello, world]</span></span><br><span class="line">        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();</span><br><span class="line">        System.out.println(nonOptionArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key-value</span></span><br><span class="line">        Set&lt;String&gt; optionNames = args.getOptionNames();</span><br><span class="line">        <span class="comment">// [hahaha]</span></span><br><span class="line">        <span class="keyword">for</span> (String optionName : optionNames) &#123;</span><br><span class="line">            System.out.println(args.getOptionValues(optionName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationRunner与CommandLineRunner可以同时存在，ApplicationRunner提供了更多的方式获取参数：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getSourceArgs()</td>
<td>获取启动的所有参数,与CommandLineRunner获取参数的形式相同</td>
</tr>
<tr>
<td>getNonOptionArgs()</td>
<td>获取没有key的参数，比如上面的hello world</td>
</tr>
<tr>
<td>getOptionNames()</td>
<td>获取参数的键值对,key为–指定的，比如上面的param=hahaha</td>
</tr>
</tbody></table>
<h3 id="12-整合Web基础组件"><a href="#12-整合Web基础组件" class="headerlink" title="12.整合Web基础组件"></a>12.整合Web基础组件</h3><hr>
<p>编写好基本的基础组件(Servlet,Listener,Filter)后,启动类添加@ServletComponentScan(basePackages = “xxxx”)扫描基础组件所在的包，即可加入IOC容器。</p>
<p>下面以创建一个监听器为例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;requestDestroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;requestInitialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-路径映射"><a href="#13-路径映射" class="headerlink" title="13.路径映射"></a>13.路径映射</h3><hr>
<p>有时候，我们有一个动态页面，不需要接收数据，但是又不能直接访问，因为动态页面不在静态资源的目录下。</p>
<p>这时候，我们通常需要写一个controller来完成页面的跳转，这种做法很繁琐。</p>
<p>我们可以使用直接配置路径映射，而无需编写controller.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/test1&quot;</span>)</span><br><span class="line">                .setViewName(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/test2&quot;</span>)</span><br><span class="line">                .setViewName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，在template目录下添加test1.html,test2.html，浏览器访问/test1，/test2可以访问到这两个动态页面。</p>
<h3 id="14-参数类型转换"><a href="#14-参数类型转换" class="headerlink" title="14.参数类型转换"></a>14.参数类型转换</h3><hr>
<p>如果后端参数是一个Date类型，前端传递的是字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/date/&#123;today&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">date</span><span class="params">(<span class="meta">@PathVariable</span> Date today)</span> </span>&#123;</span><br><span class="line">        System.out.println(today);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a href="">http://localhost:8081/date/2021-01-01</a>,报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type &#x27;java.lang.String&#x27; to required type &#x27;java.util.Date&#x27;</span><br></pre></td></tr></table></figure>

<p>后端并不能自动把String类型的参数转换成Date类型。</p>
<p>这就需要我们自己编写转换器了，编写一个类，实现Converter&lt;源数据类型，目标类型&gt;接口，并且加入到IOC容器：</p>
<p>Convert的第一个泛型参数是数据原来的数据类型，这里是String。</p>
<p>Convert的第二个泛型参数是数据的目标类型，这里是Date类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> simpleDateFormat.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-自定义欢迎页，图标"><a href="#15-自定义欢迎页，图标" class="headerlink" title="15.自定义欢迎页，图标"></a>15.自定义欢迎页，图标</h3><hr>
<p><code>欢迎页index.html</code>可以是静态页面，也可以是动态页面，可以放在静态目录(static等静态资源访问的目录)下，也可以放在动态目录(template).</p>
<p>当静态页面和动态页面同时存在，优先访问静态页面。</p>
<p><code>图标favicon.ico</code>放在static目录下。</p>
<h3 id="16-去除自定义配置"><a href="#16-去除自定义配置" class="headerlink" title="16.去除自定义配置"></a>16.去除自定义配置</h3><hr>
<p>去除自定义配置有2种方式：</p>
<ul>
<li>@SpringBootApplication(exclude=””)</li>
<li>在配置文件中指定spring.autoconfigure.exclude,类型为List<Class></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Security/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>有时候，我们在登陆页面需要添加验证码，而登陆使用的是Spring Security的登陆流程，就需要我们自定义Spring Security的认证逻辑了。有以下两种方式：</p>
<ol>
<li>添加Spring Security过滤器，这种方式有个弊端，每次请求都会通过该过滤器。但实际上，只需要登录请求经过该过滤器即可，其他请求是不需要经过该过滤器的，存在性能的弊端</li>
<li></li>
</ol>
<h3 id="1-Authentication接口简析"><a href="#1-Authentication接口简析" class="headerlink" title="1. Authentication接口简析"></a>1. Authentication接口简析</h3><p>Spring Security的认证逻辑是在接口<code>AuthenticationProvider</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>authenticate方法用来验证用户身份</li>
<li>supports 则用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication</li>
</ul>
<p>在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它实际上对 java.security.Principal 做的进一步封装，我们来看下 Authentication 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 角色列表</span></span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 用户携带的详细信息</span></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 当前用户,可能是一个用户名,也可能是一个用户对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 当前用户是否认证成功</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Authentication作为一个接口，它有很多的实现类：</p>
<ul>
<li>AnonymousAuthenticationToken(匿名登陆)</li>
<li>UsernamePasswordAuthenticationToken(账户密码登陆)</li>
<li>RememberMeAuthenticationToken(自动登陆)</li>
</ul>
<p>每一个 Authentication 都有适合它的 AuthenticationProvider 去处理校验。例如处理 UsernamePasswordAuthenticationToken 的 AuthenticationProvider 是 DaoAuthenticationProvider。</p>
<p>在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理。</p>
<h3 id="2-DaoAuthenticationProvider简析"><a href="#2-DaoAuthenticationProvider简析" class="headerlink" title="2. DaoAuthenticationProvider简析"></a>2. DaoAuthenticationProvider简析</h3><p>当我们使用账户密码登陆时，认证逻辑的处理类是DaoAuthenticationProvider，而DaoAuthenticationProvider继承自</p>
<p>AbstractUserDetailsAuthenticationProvider，我们先来看下它的父类，重点关注authenticate和support方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span>, <span class="title">InitializingBean</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,</span><br><span class="line">() -&gt; <span class="keyword">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>, <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        String username = determineUsername(authentication);</span><br><span class="line">        <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 通过用户名获取用户对象,会调用我们自己在登陆时候写的userDetail中的loadUserByUsername方法	</span></span><br><span class="line">        UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Failed to find user &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.hideUserNotFoundExceptions) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="keyword">this</span>.messages</span><br><span class="line">                                                  .getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Assert.notNull(user, <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检验user中的各个账户属性是否正常,例如账户是否被禁用，账户是否过期等</span></span><br><span class="line">            <span class="keyword">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">            <span class="comment">// 密码比对,是一个抽象方法，具体由子类实现</span></span><br><span class="line">            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">            <span class="comment">// we&#x27;re using latest data (i.e. not from the cache)</span></span><br><span class="line">            cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            <span class="keyword">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查密码是否过期</span></span><br><span class="line">        <span class="keyword">this</span>.postAuthenticationChecks.check(user);</span><br><span class="line">        <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">        &#125;</span><br><span class="line">        Object principalToReturn = user;</span><br><span class="line">        <span class="comment">// 是否强制将Authentication中的principal属性设置为字符串，默认值为false</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个新的Authentication返回</span></span><br><span class="line">        <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当authentication是UsernamePasswordAuthenticationToken的子类时，需要经过DaoAuthenticationProvider的认证逻辑处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 AbstractUserDetailsAuthenticationProvider 已经把 authenticate 和 supports 方法实现了（实现了大部分校验工作），所以在 DaoAuthenticationProvider 中，我们主要关注 additionalAuthenticationChecks 方法即可（密码比对工作）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Failed to authenticate since no credentials provided&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="keyword">this</span>.messages</span><br><span class="line">                                          .getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Failed to authenticate since password does not match stored value&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="keyword">this</span>.messages</span><br><span class="line">                                          .getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>additionalAuthenticationChecks 方法主要用来做密码比对的，逻辑也比较简单，就是调用 PasswordEncoder 的 matches 方法做比对，如果密码不对则直接抛出异常即可。</p>
<p><strong>正常情况下，我们使用用户名/密码登录，最终都会走到这一步。</strong></p>
<p>而 AuthenticationProvider 都是通过 ProviderManager#authenticate 方法来调用的。由于我们的一次认证可能会存在多个 AuthenticationProvider，所以，在 ProviderManager#authenticate 方法中会逐个遍历 AuthenticationProvider，并调用他们的 authenticate 方法做认证，我们来稍微瞅一眼 ProviderManager#authenticate 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        result = provider.authenticate(authentication);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法中，会遍历所有的 AuthenticationProvider，并调用它的 authenticate 方法进行认证。</p>
<h3 id="3-自定义认证流程"><a href="#3-自定义认证流程" class="headerlink" title="3. 自定义认证流程"></a>3. 自定义认证流程</h3><p>登录请求是调用 AbstractUserDetailsAuthenticationProvider#authenticate 方法进行认证的，在该方法中，又会调用到 DaoAuthenticationProvider#additionalAuthenticationChecks 方法做进一步的校验，去校验用户登录密码。我们可以自定义一个 AuthenticationProvider 代替 DaoAuthenticationProvider，并重写它里边的 additionalAuthenticationChecks 方法，在重写的过程中，加入验证码的校验逻辑即可。</p>
<h4 id="3-1-验证码生成"><a href="#3-1-验证码生成" class="headerlink" title="3.1 验证码生成"></a>3.1 验证码生成</h4><p>导入依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置验证码的生成属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Producer <span class="title">verifyCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证码属性</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>,<span class="string">&quot;150&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>,<span class="string">&quot;50&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.string&quot;</span>,<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> DefaultKaptcha();</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写controller，生成验证码图片，并将生成的验证码放入到session中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;code.jpg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVerifyCode</span><span class="params">(HttpServletResponse response, HttpSession session)</span> </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        String text = producer.createText();</span><br><span class="line">        <span class="comment">// 验证码放入session中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;verifyCode&quot;</span>,text);</span><br><span class="line">        <span class="comment">// 生成验证码</span></span><br><span class="line">        BufferedImage image = producer.createImage(text);</span><br><span class="line">        <span class="keyword">try</span> (ServletOutputStream outputStream = response.getOutputStream()) &#123;</span><br><span class="line">            ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，记得放行验证码的请求:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/code.jpg&quot;</span>).permitAll()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/hello&quot;</span>).authenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin&quot;</span>).fullyAuthenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/remember&quot;</span>).rememberMe()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable()</span><br><span class="line">        .sessionManagement()</span><br><span class="line">        .maximumSessions(<span class="number">1</span>)</span><br><span class="line">        .maxSessionsPreventsLogin(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问/code.jpg就可以获取验证码了。</p>
<h4 id="3-2-提供自定义的ProviderManager"><a href="#3-2-提供自定义的ProviderManager" class="headerlink" title="3.2 提供自定义的ProviderManager"></a>3.2 提供自定义的ProviderManager</h4><p>前面我们说，所有的 AuthenticationProvider 都是放在 ProviderManager 中统一管理的，所以接下来我们就要自己提供 ProviderManager。</p>
<p>首先，提供自定义的VerifyCodeAuthenticationProvider：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyCodeAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">DaoAuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 完成验证码的校验</span></span><br><span class="line">        ServletRequestAttributes requestAttributes =</span><br><span class="line">            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line">        <span class="comment">// 取出session中的验证码</span></span><br><span class="line">        String verfiyCode = (String) request.getSession().getAttribute(<span class="string">&quot;verfiyCode&quot;</span>);</span><br><span class="line">        <span class="comment">// 取出前端传递过来的验证码</span></span><br><span class="line">        String code = request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(verfiyCode == <span class="keyword">null</span> || code == <span class="keyword">null</span> || !verfiyCode.equals(code)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用DaoAuthenticationProvider的additionalAuthenticationChecks方法完成密码比对</span></span><br><span class="line">        <span class="keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注入自定义的 VerifyCodeAuthenticationProvider，这一切操作都在 SecurityConfig 中完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span>  <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将用户存在内存中,提供一个userDetailService</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> VerifyCodeAuthenticationProvider <span class="title">verifyCodeAuthenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VerifyCodeAuthenticationProvider verifyCodeAuthenticationProvider =</span><br><span class="line">            <span class="keyword">new</span> VerifyCodeAuthenticationProvider();</span><br><span class="line">        <span class="comment">// 需要提供userDetail，不然会报错</span></span><br><span class="line">        verifyCodeAuthenticationProvider.setUserDetailsService(userDetailsService());</span><br><span class="line">        <span class="keyword">return</span> verifyCodeAuthenticationProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过重写 authenticationManager 方法来提供一个自己的 AuthenticationManager，实际上就是 ProviderManager，在创建 ProviderManager 时，加入自己的 verifyCodeAuthenticationProvider。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProviderManager <span class="title">myProviderManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以传List,也可以传可变参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProviderManager(Arrays.asList(verifyCodeAuthenticationProvider()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/code.jpg&quot;</span>).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/hello&quot;</span>).authenticated()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/admin&quot;</span>).fullyAuthenticated()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/remember&quot;</span>).rememberMe()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="number">1</span>)</span><br><span class="line">            .maxSessionsPreventsLogin(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建VerifyCodeAuthenticationProvider，需要提供 UserDetailService 和 PasswordEncoder 实例。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Cloud/nginx/</url>
    <content><![CDATA[<h3 id="linux安装nginx"><a href="#linux安装nginx" class="headerlink" title="linux安装nginx"></a>linux安装nginx</h3><ol>
<li>安装nginx所需的依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在/usr/local/下创建nginx目录</p>
</li>
<li><p><a href="">https://nginx.org/download/</a>下载tar.gz包，并解压tar -zxvf xxxx.tar.gz</p>
</li>
<li><p>配置./configure –prefix=/usr/local/nginx</p>
</li>
<li><p>执行make &amp;&amp; make install</p>
</li>
<li><p>切换到/usr/local/nginx/sbin，执行nginx -t</p>
</li>
</ol>
<p>如果出现以下，则说明安装成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@ming</span> sbin]# ./nginx -t</span><br><span class="line">nginx: the configuration file /usr/local/nginx<span class="comment">//conf/nginx.conf syntax is ok</span></span><br><span class="line">nginx: configuration file /usr/local/nginx<span class="comment">//conf/nginx.conf test is successful</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行nginx,执行./nginx</li>
</ol>
<p>如果出现以下界面，说明安装成功。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201228003249059.png" alt="image-安装成功"></p>
<ol start="8">
<li>如果打不开，检查防火墙是不是没开放80端口。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=80/tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放端口，-permanent  表示永久生效，没有此参数重启后失效</span></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash">重启防火墙</span></span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>配置nginx开机自启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p> 添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx开机自启动</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Cloud/curl/</url>
    <content><![CDATA[<h3 id="1-查看网页源码"><a href="#1-查看网页源码" class="headerlink" title="1.查看网页源码"></a>1.查看网页源码</h3><p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址<a href="">www.sina.com</a>为例.</p>
<p>直接使用curl相当于发送get请求，这就相当与wget命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl www.sina.com</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>nginx<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget www.sina.com</span><br></pre></td></tr></table></figure>

<p>wget会直接把文件下载到当前目录，而curl命令需要使用-o属性保存。</p>
<p>以下命令将<a href="">www.sina.com</a>的源代码保存为index.html。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o index.html www.sina.com</span><br></pre></td></tr></table></figure>

<p>直接使用-O可以不指定文件的名称，直接使用远程文件的名称。但如果远程文件没有名称，会报以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl: Remote file name has no length!</span><br></pre></td></tr></table></figure>



<h3 id="2-自动跳转"><a href="#2-自动跳转" class="headerlink" title="2.自动跳转"></a>2.自动跳转</h3><p>上面我们访问<a href="">www.sina.com</a>的时候，返回的html是错误页面。这是因为<a href="http://www.sina.com新的网址是[www.sina.com.cn]()">www.sina.com新的网址是[www.sina.com.cn]()</a>.</p>
<p>在使用curl的时候，使用-L参数可以自动跳转。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L www.sina.com</span><br></pre></td></tr></table></figure>



<h3 id="3-显示响应头信息"><a href="#3-显示响应头信息" class="headerlink" title="3.显示响应头信息"></a>3.显示响应头信息</h3><p>使用-i参数能显示response头信息，连带着网页一起。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i www.sina.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 30 Dec 2020 07:38:19 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 178</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.sina.com.cn/</span><br><span class="line">Expires: Wed, 30 Dec 2020 07:38:55 GMT</span><br><span class="line">Cache-Control: max-age=120</span><br><span class="line">X-Via-SSL: ssl.23.sinag1.qxg.lb.sinanode.com</span><br><span class="line">Edge-Copy-Time: 1609313896730</span><br><span class="line">Age: 84</span><br><span class="line">Via: https/1.1 ctc.guangzhou.union.182 (ApacheTrafficServer/6.2.1 [cRs f ]), https/1.1 ctc.qingdao.union.63 (ApacheTrafficServer/6.2.1 [cRs f ])</span><br><span class="line">X-Via-Edge: 1609313899518c6e0602ff105f98c4141b37e</span><br><span class="line">X-Cache: HIT.63</span><br><span class="line">X-Via-CDN: f=edge,s=ctc.qingdao.union.46.nb.sinaedge.com,c=47.96.224.198;f=Edge,s=ctc.qingdao.union.63,c=140.249.5.46</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如果只想显示头信息，不想显示网页，使用-I参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -I www.sina.com</span><br></pre></td></tr></table></figure>



<h3 id="4-显示通信过程"><a href="#4-显示通信过程" class="headerlink" title="4.显示通信过程"></a>4.显示通信过程</h3><p>-v 参数可以显示一次http通信的整个过程，包括端口连接、 request头信息、response头信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* About to connect() to www.sina.com port 80 (#0)</span><br><span class="line">*   Trying 112.90.6.240...</span><br><span class="line">* Connected to www.sina.com (112.90.6.240) port 80 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET / HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: www.sina.com</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">&lt; HTTP/1.1 301 Moved Permanently</span><br><span class="line">&lt; Server: nginx</span><br><span class="line">&lt; Date: Wed, 30 Dec 2020 07:43:51 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 178</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http://www.sina.com.cn/</span><br><span class="line">&lt; Expires: Wed, 30 Dec 2020 07:45:33 GMT</span><br><span class="line">&lt; Cache-Control: max-age=120</span><br><span class="line">&lt; X-Via-SSL: ssl.95.sinag1.qxg.lb.sinanode.com</span><br><span class="line">&lt; Edge-Copy-Time: 1609314213341</span><br><span class="line">&lt; Age: 18</span><br><span class="line">&lt; Via: https/1.1 cnc.guangzhou.union.55 (ApacheTrafficServer/6.2.1 [cRs f ])</span><br><span class="line">&lt; X-Cache: HIT.70</span><br><span class="line">&lt; X-Via-CDN: f=edge,s=cnc.guangzhou.union.57.nb.sinaedge.com,c=47.96.224.198;f=Edge,s=cnc.guangzhou.union.55,c=112.90.6.74</span><br><span class="line">&lt; X-Via-Edge: 1609314231193c6e0602ff0065a7029a4230b</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection #0 to host www.sina.com left intact</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想查看更加详细的信息，使用下面的命令将结果输处到out.txt文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --trace out.txt www.sina.com</span><br></pre></td></tr></table></figure>



<h3 id="5-发送表单信息"><a href="#5-发送表单信息" class="headerlink" title="5.发送表单信息"></a>5.发送表单信息</h3><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure>

<p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>

<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST --data-urlencode &quot;date=April 1&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>



<h3 id="6-HTTP动词"><a href="#6-HTTP动词" class="headerlink" title="6.HTTP动词"></a>6.HTTP动词</h3><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7.文件上传"></a>7.文件上传</h3><p>假定文件上传的表单是下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&#x27;multipart/form-data&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;upload.cgi&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">press</span> <span class="attr">value</span>=<span class="string">&quot;OK&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以用curl这样上传文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure>



<h3 id="8-reference字段"><a href="#8-reference字段" class="headerlink" title="8.reference字段"></a>8.reference字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="9-User-Agent"><a href="#9-User-Agent" class="headerlink" title="9.User-Agent"></a>9.User-Agent</h3><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure>



<h3 id="10-Cookie"><a href="#10-Cookie" class="headerlink" title="10.Cookie"></a>10.Cookie</h3><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --cookie &quot;name=xxx&quot; www.example.com</span><br></pre></td></tr></table></figure>

<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -c cookies http://example.com</span><br><span class="line">curl -b cookies http://example.com</span><br></pre></td></tr></table></figure>



<h3 id="11-增加头信息"><a href="#11-增加头信息" class="headerlink" title="11.增加头信息"></a>11.增加头信息</h3><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type:application/json&quot; http://example.com</span><br></pre></td></tr></table></figure>



<h3 id="12-HTTP认证"><a href="#12-HTTP认证" class="headerlink" title="12.HTTP认证"></a>12.HTTP认证</h3><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user name:password example.com</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Security/%E7%A6%81%E6%AD%A2%E5%A4%9A%E7%AB%AF%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h3 id="1-禁止多端用户登陆"><a href="#1-禁止多端用户登陆" class="headerlink" title="1. 禁止多端用户登陆"></a>1. 禁止多端用户登陆</h3><p>在Spring Security中，禁止多端用户登陆有两种方式：</p>
<ol>
<li>后来的登陆踢掉已经登陆的用户</li>
<li>已经登陆的用户，后来的登陆不被允许</li>
</ol>
<h4 id="1-1-踢掉已经登陆的用户"><a href="#1-1-踢掉已经登陆的用户" class="headerlink" title="1.1 踢掉已经登陆的用户"></a>1.1 踢掉已经登陆的用户</h4><p>这两种方式在Spring Security中都很好实现，只需要配置一下sessionManager:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/hello&quot;</span>).authenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin&quot;</span>).fullyAuthenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/remember&quot;</span>).rememberMe()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable()</span><br><span class="line">        .sessionManagement()</span><br><span class="line">        <span class="comment">// 一个用户最多只允许一端登陆</span></span><br><span class="line">        .maximumSessions(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当完成上面的配置后，后来的登陆会踢掉已经登陆的用户，当已经登陆的用户再次访问接口时，会报错如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">This session has been <span class="title">expired</span> <span class="params">(possibly due to multiple concurrent logins being attempted as the same user)</span>.</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里说这个 session 已经过期，原因则是由于使用同一个用户进行并发登录。</p>
<h4 id="1-2-后来的登陆不被允许"><a href="#1-2-后来的登陆不被允许" class="headerlink" title="1.2 后来的登陆不被允许"></a>1.2 后来的登陆不被允许</h4><p>另外一种方式，后来的登陆不被允许的设置也非常简单,添加一个配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/hello&quot;</span>).authenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin&quot;</span>).fullyAuthenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/remember&quot;</span>).rememberMe()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable()</span><br><span class="line">        .sessionManagement()</span><br><span class="line">        .maximumSessions(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 阻止后来的登陆</span></span><br><span class="line">        .maxSessionsPreventsLogin(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Spring Security是监听session来清理session的记录的。而用户从不同的浏览器登陆后，都会有不同的session，当用户注销登陆之后，session就会失效，但是默认的失效是调用StandardSession#invalidate方法来清理session的。这一个失效事件无法被Spring容器感知到，进而导致用户注销登陆后，session信息没有及时清理，进而导致用户无法重新登陆进来。所以，我们需要一个事件发布器来监听session的事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionEventPublisher <span class="title">httpSessionEventPublisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpSessionEventPublisher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当完成以上配置后，如果用户已经登陆过，后来的登陆不被允许，会报错。</p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><p>首先我们知道，在用户登录的过程中，会经过 UsernamePasswordAuthenticationFilter,而 UsernamePasswordAuthenticationFilter 中过滤方法的调用是在 AbstractAuthenticationProcessingFilter 中触发的，我们来看下 AbstractAuthenticationProcessingFilter#doFilter 方法的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Authentication authenticationResult = attemptAuthentication(request, response);</span><br><span class="line">        <span class="keyword">if</span> (authenticationResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">        <span class="comment">// Authentication success</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>, failed);</span><br><span class="line">        unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">        <span class="comment">// Authentication failed</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们可以看到，调用 attemptAuthentication 方法走完认证流程之后，回来之后，接下来就是调用 sessionStrategy.onAuthentication 方法，这个方法就是用来处理 session 的并发问题的。具体在ConcurrentSessionControlAuthenticationStrategy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthentication</span><span class="params">(Authentication authentication, HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                             HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户的所有session,第一个参数是当前用户的authentication,第二个参数false表示不包含已经过期的session。在用户登陆之后，会将用户的session保存起来，key是principal，value是对应的sessionid的集合(Set&lt;sessionId&gt;)</span></span><br><span class="line">    List&lt;SessionInformation&gt; sessions = <span class="keyword">this</span>.sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 当前用户的有效session数</span></span><br><span class="line">    <span class="keyword">int</span> sessionCount = sessions.size();</span><br><span class="line">    <span class="comment">// 设置的session并发数</span></span><br><span class="line">    <span class="keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);</span><br><span class="line">    <span class="comment">// 如果当前有效的session数小于session并发数,不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCount &lt; allowedSessions) &#123;</span><br><span class="line">        <span class="comment">// They haven&#x27;t got too many login sessions running at present</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前session的并发数为-1，表示对session数量不做任何限制</span></span><br><span class="line">    <span class="keyword">if</span> (allowedSessions == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// We permit unlimited logins</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前 session 数（sessionCount）等于 session 并发数（allowedSessions），那就先看看当前 session 是否不为 null，并且已经存在于 sessions 中了，如果已经存在了，那都是自家人，不做任何处理；如果当前 session 为 null，那么意味着将有一个新的 session 被创建出来，届时当前 session 数（sessionCount）就会超过 session 并发数（allowedSessions）。</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCount == allowedSessions) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only permit it though if this request is associated with one of the</span></span><br><span class="line">            <span class="comment">// already registered sessions</span></span><br><span class="line">            <span class="keyword">for</span> (SessionInformation si : sessions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the session is null, a new one will be created by the parent class,</span></span><br><span class="line">        <span class="comment">// exceeding the allowed number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果前面的代码都没能return，将进入策略判断方法</span></span><br><span class="line">    allowableSessionsExceeded(sessions, allowedSessions, <span class="keyword">this</span>.sessionRegistry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allowableSessionsExceeded 方法中，首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，那么这次登录就失败了（对应 1.1 小节踢掉已经登陆用户的效果），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（对应 1.2 小节后来的登陆不被允许的效果）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">allowableSessionsExceeded</span><span class="params">(List&lt;SessionInformation&gt; sessions, <span class="keyword">int</span> allowableSessions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         SessionRegistry registry)</span> <span class="keyword">throws</span> SessionAuthenticationException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exceptionIfMaximumExceeded || (sessions == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SessionAuthenticationException(</span><br><span class="line">            <span class="keyword">this</span>.messages.getMessage(<span class="string">&quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;</span>,</span><br><span class="line">                                     <span class="keyword">new</span> Object[] &#123; allowableSessions &#125;, <span class="string">&quot;Maximum sessions of &#123;0&#125; for this principal exceeded&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Determine least recently used sessions, and mark them for invalidation</span></span><br><span class="line">    sessions.sort(Comparator.comparing(SessionInformation::getLastRequest));</span><br><span class="line">    <span class="keyword">int</span> maximumSessionsExceededBy = sessions.size() - allowableSessions + <span class="number">1</span>;</span><br><span class="line">    List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(<span class="number">0</span>, maximumSessionsExceededBy);</span><br><span class="line">    <span class="keyword">for</span> (SessionInformation session : sessionsToBeExpired) &#123;</span><br><span class="line">        session.expireNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Security/Remember%20me/</url>
    <content><![CDATA[<h3 id="踩坑集锦"><a href="#踩坑集锦" class="headerlink" title="踩坑集锦"></a>踩坑集锦</h3><h4 id="1-1-No-AuthenticationProvider-found-for-org-springframework-security-authentication-UsernamePasswordAuth"><a href="#1-1-No-AuthenticationProvider-found-for-org-springframework-security-authentication-UsernamePasswordAuth" class="headerlink" title="1.1 No AuthenticationProvider found for org.springframework.security.authentication.UsernamePasswordAuth"></a>1.1 No AuthenticationProvider found for org.springframework.security.authentication.UsernamePasswordAuth</h4><p>有可能的原因是重写了configure方法，而方法体内是空的。这是一种非常傻逼的操作…</p>
<h4 id="1-2-java-lang-IllegalStateException-UserDetailsService-is-required"><a href="#1-2-java-lang-IllegalStateException-UserDetailsService-is-required" class="headerlink" title="1.2 java.lang.IllegalStateException: UserDetailsService is required."></a>1.2 java.lang.IllegalStateException: UserDetailsService is required.</h4><p>出现这种错误的原因可能是在配置文件中配置了用户名和密码…,而且用户名和密码是可以进行登陆的。不过后台会报错，只需将配置文件中的用户名密码配置在config方法中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">        .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-Remember-Me的使用"><a href="#1-Remember-Me的使用" class="headerlink" title="1. Remember-Me的使用"></a>1. Remember-Me的使用</h3><p>如果需要实现<code>自动登陆</code>的功能，且在关闭浏览器后重开，或者重启服务器后还能自动登陆，可以使用Spring Security的Remember-me功能。只需要配置一下rememberMe()即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当配置rememberMe()后，自动登陆功能就可以实现了：</p>
<ul>
<li><p>在登陆页面，会出现Remember me on this computer.的选项。如果勾选了这个选项，发送POST请求的/login会在body中增加一个remember-me:on的参数。<code>如果是自定义的登陆页面,想使用remember-me的功能,传递的key值就应该是remember-me</code>.</p>
</li>
<li><p>当勾选了后，再次访问其他接口，Cookie中会携带remember-me:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: JEECGINDEXSTYLE=ace;JSESSIONID=93573581FD0676F64B7D495F9968D6AE; remember-me=dXNlcjoxNjE1OTYzNzQ0Mzk5OjhiYTBhZjkxYzlhNzBhYjlkMzQwNGMyNWM2OWFhYzdk</span><br></pre></td></tr></table></figure>



<p>接下来，我们来研究一下remember-me的组成，这串字符串是经过Base64编码后的，我们写段小代码来还原它的真面目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes =</span><br><span class="line">      Base64.getDecoder().decode(<span class="string">&quot;dXNlcjoxNjE1OTYyNzY2NDEyOmQyMWJkNmI5YjY3YjM0MmRkN2UwZjIzMjkxN2FmZjRl&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:分割的字符串，其中：</p>
<ul>
<li>第一段为<code>用户名</code>，也就是在登陆界面登陆的用户名</li>
<li>第二段为<code>过期时间</code>，默认是两周</li>
<li>第三段为<code>MD5计算的散列值</code>。他的明文格式是 <code>username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + key</code>，最后的 key 是一个散列盐值，可以用来防治令牌被修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user:1615962766412:d21bd6b9b67b342dd7e0f232917aff4e</span><br></pre></td></tr></table></figure>



<p>那么，如果用户勾选了Remember-me的选项后，登陆流程是这样子的：</p>
<p>用户勾选remember-me选项后，/login请求会带上remember-on的参数。在浏览器关闭后，或服务器重启后，用户再去访问接口，此时会携带Cookie中的remember-me到服务端。服务端拿到这个remember-me，就可以解析用户名和过期时间，再根据用户名查询到用户密码，然后通过MD5散列函数计算出散列值，将计算出的散列值与浏览器传递的散列值进行对比，就能确认这个令牌是否有效。</p>
<h3 id="2-Remember-Me的生成与校验"><a href="#2-Remember-Me的生成与校验" class="headerlink" title="2. Remember-Me的生成与校验"></a>2. Remember-Me的生成与校验</h3><h4 id="2-1-生成过程"><a href="#2-1-生成过程" class="headerlink" title="2.1 生成过程"></a>2.1 生成过程</h4><p>按照remember-me的格式，生成的过程需要的有<code>用户名</code>，<code>过期时间</code>,<code>密码(MD5加密中使用)</code>。</p>
<p>remember-me参数的生成是在TokenBasedRememberMeServices类中的onLoginSuccess方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取用户名和密码</span></span><br><span class="line">    String username = <span class="keyword">this</span>.retrieveUserName(successfulAuthentication);</span><br><span class="line">    String password = <span class="keyword">this</span>.retrievePassword(successfulAuthentication);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(username)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Unable to retrieve username&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登陆成功后,密码可能被擦除了。从数据库中获取密码</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line">            UserDetails user = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            password = user.getPassword();</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Unable to obtain password for user: &quot;</span> + username);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 2.计算过期时间</span></span><br><span class="line">        <span class="keyword">int</span> tokenLifetime = <span class="keyword">this</span>.calculateLoginLifetime(request, successfulAuthentication);</span><br><span class="line">        <span class="keyword">long</span> expiryTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果过期的时间没有设置，默认为当前的时间加上两周</span></span><br><span class="line">        expiryTime += <span class="number">1000L</span> * (<span class="keyword">long</span>)(tokenLifetime &lt; <span class="number">0</span> ? <span class="number">1209600</span> : tokenLifetime);</span><br><span class="line">        <span class="comment">// 3.MD5生成散列值</span></span><br><span class="line">        String signatureValue = <span class="keyword">this</span>.makeTokenSignature(expiryTime, username, password);</span><br><span class="line">        <span class="comment">// 4.设置到cookie中</span></span><br><span class="line">        <span class="keyword">this</span>.setCookie(<span class="keyword">new</span> String[]&#123;username, Long.toString(expiryTime), signatureValue&#125;, tokenLifetime, request, response);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Added remember-me cookie for user &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;, expiry: &#x27;&quot;</span> + <span class="keyword">new</span> Date(expiryTime) + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makeTokenSignature使用MD5生成散列值，可以看到散列值的明文格式。</p>
<p>同时也说明了MD5加密使用<code>MessageDigest</code>，也要注意使用Hex.encode进行编码，否则输出是乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">makeTokenSignature</span><span class="params">(<span class="keyword">long</span> tokenExpiryTime, String username, String password)</span> </span>&#123;</span><br><span class="line">    String data = username + <span class="string">&quot;:&quot;</span> + tokenExpiryTime + <span class="string">&quot;:&quot;</span> + password + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest digest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No MD5 algorithm available!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>散列函数中的key如果没有设置，默认是在 RememberMeConfigurer#getKey 方法中进行设置的，它的值是一个 UUID 字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.rememberMeServices <span class="keyword">instanceof</span> AbstractRememberMeServices) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = ((AbstractRememberMeServices)<span class="keyword">this</span>.rememberMeServices).getKey();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们自己没有设置 key，key 默认值是一个 UUID 字符串，这样会带来一个问题，就是如果服务端重启，这个 key 会变，这样就导致之前派发出去的所有 remember-me 自动登录令牌失效(<code>测试好像并不会？？？</code>)，所以，我们可以指定这个 key。指定方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .key(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-校验过程"><a href="#2-2-校验过程" class="headerlink" title="2.2 校验过程"></a>2.2 校验过程</h4><p>RememberMeAuthenticationFilter#doFilter方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(LogMessage</span><br><span class="line">                          .of(() -&gt; <span class="string">&quot;SecurityContextHolder not populated with remember-me token, as it already contained: &#x27;&quot;</span></span><br><span class="line">                              + SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取不到用户信息,进行自动登陆的处理</span></span><br><span class="line">    Authentication rememberMeAuth = <span class="keyword">this</span>.rememberMeServices.autoLogin(request, response);    		......</span><br></pre></td></tr></table></figure>

<p>AbstractRememberMeServices#autoLogin:</p>
<p>真正校验remember-me参数的方法是processAutoLoginCookie。它是一个抽象方法，实现有2个：</p>
<ul>
<li>TokenBasedRememberMeServices</li>
<li>PersistentTokenBasedRememeberMeServices</li>
</ul>
<p>这里使用的是TokenBasedRememberMeServices。而PersistentTokenBasedRememeberMeServices是持久化令牌使用的，后续会介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Authentication <span class="title">autoLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取cookie</span></span><br><span class="line">    String rememberMeCookie = extractRememberMeCookie(request);</span><br><span class="line">    <span class="keyword">if</span> (rememberMeCookie == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Remember-me cookie detected&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rememberMeCookie.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Cookie was empty&quot;</span>);</span><br><span class="line">        cancelCookie(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        String[] cookieTokens = decodeCookie(rememberMeCookie);</span><br><span class="line">        <span class="comment">// 对remember-me参数的校验,包括用户,过期时间等</span></span><br><span class="line">        UserDetails user = processAutoLoginCookie(cookieTokens, request, response);</span><br><span class="line">        <span class="keyword">this</span>.userDetailsChecker.check(user);</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Remember-me cookie accepted&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> createSuccessfulAuthentication(request, user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，核心就是提取出 cookie 信息，并对 cookie 信息进行解码，解码之后，再调用 processAutoLoginCookie 方法去做校验。</p>
<h3 id="3-风险以及解决方法"><a href="#3-风险以及解决方法" class="headerlink" title="3. 风险以及解决方法"></a>3. 风险以及解决方法</h3><p>如果我们开启了 RememberMe 功能，最最核心的东西就是放在 cookie 中的令牌了，这个令牌突破了 session 的限制，即使服务器重启、即使浏览器关闭又重新打开，只要这个令牌没有过期，就能访问到数据。</p>
<p>一旦令牌丢失，别人就可以拿着这个令牌随意登录我们的系统了，这是一个非常危险的操作。</p>
<p>但是实际上这是一段悖论，为了提高用户体验（少登录），我们的系统不可避免的引出了一些安全问题，不过我们可以通过技术将安全风险降低到最小。</p>
<h4 id="3-1-持久化令牌"><a href="#3-1-持久化令牌" class="headerlink" title="3.1 持久化令牌"></a>3.1 持久化令牌</h4><p>持久化令牌就是在基本的自动登录功能基础上，又增加了新的校验参数，来提高系统的安全性，这一些都是由开发者在后台完成的，对于用户来说，登录体验和普通的自动登录体验是一样的。</p>
<p>在持久化令牌中，新增了两个经过 MD5 散列函数计算的校验参数，一个是 series，另一个是 token。其中，series 只有当用户在使用用户名/密码登录时，才会生成或者更新，而 token 只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录，就像手机 QQ ，一个手机上登录了，就会踢掉另外一个手机的登录，这样用户就会很容易发现账户是否泄漏。</p>
<p>要想使用持久化令牌，我们就需要一张表来保存令牌。可以自定义表，也可以使用Spring Security提供的JdbcTokenRepositoryImpl。根据JdbcTokenRepositoryImpl定义的操作sql，创建表的sql如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `persistent_logins` (  </span><br><span class="line"> `username` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,  </span><br><span class="line"> `series` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,  </span><br><span class="line"> `token` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,  </span><br><span class="line"> `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  </span><br><span class="line"> PRIMARY KEY (`series`)  </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>用来保存令牌的处理类是PersistentRememberMeToken。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentRememberMeToken</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String series;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String tokenValue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Date date; <span class="comment">// 上一次自动登陆的时间</span></span><br><span class="line">    <span class="comment">//省略 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们还需要添加JDBC和Mysql的依赖。并在配置文件中配置数据库相关的属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>
<p>Spring Security的配置类也需要添加JdbcRepositoryImpl和tokenRepository:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function">JdbcTokenRepositoryImpl <span class="title">jdbcTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> JdbcTokenRepositoryImpl repository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">     repository.setDataSource(dataSource);</span><br><span class="line">     <span class="keyword">return</span> repository;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">            .tokenRepository(jdbcTokenRepository())</span><br><span class="line">            .and()</span><br><span class="line">            .csrf()</span><br><span class="line">            .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问流程和使用RememberMe的时候没有什么不同(用户的体验是一样的)。唯一不同的是持久化令牌的方式把remember-me保存到了数据库中。</p>
<p>前端传递的参数remember-me经过Base64解码后:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uJQ60QhTdmucg5jnmPjhDg%3D%3D:tuQyXHvjgimTtFI7jLnQgw%3D%3D</span><br></pre></td></tr></table></figure>
<p><code>%3D</code>代表<code>=</code>。此时查看数据库中的表，多了一条记录：<br>|  series| token |<br>|–|–|<br>| uJQ60QhTdmucg5jnmPjhDg== | tuQyXHvjgimTtFI7jLnQgw==|</p>
<p>数据库中的记录和我们看到的 remember-me 令牌解析后是一致的。</p>
<h4 id="3-2-持久化令牌生成流程"><a href="#3-2-持久化令牌生成流程" class="headerlink" title="3.2 持久化令牌生成流程"></a>3.2 持久化令牌生成流程</h4><p>持久化令牌的生成流程在PersistentTokenBasedRememberMeServices#onLoginSuccess:</p>
<p>与TokenBasedRememberMeServices不同的是，PersistentTokenBasedRememberMeServices不需要获取用户的密码，series和token都是调用SecureRandom 随机生成的。不同于我们以前用的 Math.random 或者 java.util.Random 这种伪随机数，SecureRandom 则采用的是类似于密码学的随机数生成规则，其输出结果较难预测，适合在登录这样的场景下使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">    String username = successfulAuthentication.getName();</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Creating new persistent login for user %s&quot;</span>, username));</span><br><span class="line">    <span class="comment">// 生成令牌对象</span></span><br><span class="line">    PersistentRememberMeToken persistentToken = <span class="keyword">new</span> PersistentRememberMeToken(username, generateSeriesData(),generateTokenData(), <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向数据库中添加</span></span><br><span class="line">        <span class="keyword">this</span>.tokenRepository.createNewToken(persistentToken);</span><br><span class="line">        <span class="comment">// 添加cookie</span></span><br><span class="line">        addCookie(persistentToken, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Failed to save persistent token &quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成series，Base64编码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateSeriesData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] newSeries = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">this</span>.seriesLength];</span><br><span class="line">    <span class="keyword">this</span>.random.nextBytes(newSeries);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.getEncoder().encode(newSeries));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成token，Base64编码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateTokenData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] newToken = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">this</span>.tokenLength];</span><br><span class="line">    <span class="keyword">this</span>.random.nextBytes(newToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.getEncoder().encode(newToken));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-持久化令牌校验流程"><a href="#3-3-持久化令牌校验流程" class="headerlink" title="3.3 持久化令牌校验流程"></a>3.3 持久化令牌校验流程</h4><p>持久化令牌的校验核心在PersistenctTokenBasedRememberMeServices#processAutoLoginCookie:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDetails <span class="title">processAutoLoginCookie</span><span class="params">(String[] cookieTokens, HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cookieTokens.length != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCookieException(<span class="string">&quot;Cookie token did not contain &quot;</span> + <span class="number">2</span> + <span class="string">&quot; tokens, but contained &#x27;&quot;</span>+ Arrays.asList(cookieTokens) + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String presentedSeries = cookieTokens[<span class="number">0</span>];</span><br><span class="line">    String presentedToken = cookieTokens[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从数据库中获取令牌对象</span></span><br><span class="line">    PersistentRememberMeToken token = <span class="keyword">this</span>.tokenRepository.getTokenForSeries(presentedSeries);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No series match, so we can&#x27;t authenticate using this cookie</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RememberMeAuthenticationException(<span class="string">&quot;No persistent token found for series id: &quot;</span> + presentedSeries);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检验token，如果查出来的 token 和前端传来的 token 不相同，说明账号可能被人盗用（别人用你的令牌登录之后，token 会变）。此时根据用户名移除相关的 token，相当于必须要重新输入用户名密码登录才能获取新的自动登录权限。</span></span><br><span class="line">    <span class="keyword">if</span> (!presentedToken.equals(token.getTokenValue())) &#123;</span><br><span class="line">        <span class="comment">// Token doesn&#x27;t match series value. Delete all logins for this user and throw</span></span><br><span class="line">        <span class="comment">// an exception to warn them.</span></span><br><span class="line">        <span class="keyword">this</span>.tokenRepository.removeUserTokens(token.getUsername());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CookieTheftException(<span class="keyword">this</span>.messages.getMessage(</span><br><span class="line">            <span class="string">&quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验token过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (token.getDate().getTime() + getTokenValiditySeconds() * <span class="number">1000L</span> &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RememberMeAuthenticationException(<span class="string">&quot;Remember-me login has expired&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Token also matches, so login is valid. Update the token value, keeping the</span></span><br><span class="line">    <span class="comment">// *same* series number.</span></span><br><span class="line">    <span class="comment">// 保持series不变，更新token值</span></span><br><span class="line">    <span class="keyword">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Refreshing persistent login token for user &#x27;%s&#x27;, series &#x27;%s&#x27;&quot;</span>,token.getUsername(), token.getSeries()));</span><br><span class="line">    PersistentRememberMeToken newToken = <span class="keyword">new</span> PersistentRememberMeToken(token.getUsername(), token.getSeries(),generateTokenData(), <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate());</span><br><span class="line">        <span class="comment">// 重新添加到cookie中</span></span><br><span class="line">        addCookie(newToken, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Failed to update token: &quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RememberMeAuthenticationException(<span class="string">&quot;Autologin failed due to data access problem&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户名查询用户信息，再走一波登录流程。</span></span><br><span class="line">    <span class="keyword">return</span> getUserDetailsService().loadUserByUsername(token.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-4-二次校验"><a href="#3-4-二次校验" class="headerlink" title="3.4 二次校验"></a>3.4 二次校验</h4><p>为了让用户使用方便，我们开通了自动登录功能，但是自动登录功能又带来了安全风险，一个规避的办法就是如果用户使用了自动登录功能，我们可以只让他做一些常规的不敏感操作，例如数据浏览、查看，但是不允许他做任何修改、删除操作，如果用户点击了修改、删除按钮，我们可以跳转回登录页面，让用户重新输入密码确认身份，然后再允许他执行敏感操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/hello&quot;</span>).authenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin&quot;</span>).fullyAuthenticated()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/remember&quot;</span>).rememberMe()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .tokenRepository(jdbcTokenRepository())</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>/remember接口是需要 rememberMe 才能访问。</li>
<li>/admin 是需要 fullyAuthenticated，fullyAuthenticated 不同于 authenticated，fullyAuthenticated 不包含自动登录的形式，而 authenticated 包含自动登录的形式。</li>
<li>/hello是 authenticated 就能访问，也就是账号密码登陆和自动登陆都可以。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Cloud/Spring%20Security/</url>
    <content><![CDATA[<h3 id="1-SpringSecurity初体验"><a href="#1-SpringSecurity初体验" class="headerlink" title="1.SpringSecurity初体验"></a>1.SpringSecurity初体验</h3><p>SpringBoot为SpringSecurity自动化配置了很多东西，只要把security的依赖导进来，所有的方法都会被security保护，需要登录才可以访问。</p>
<p>默认情况下，在启动SpringBoot项目的时候，会生成一个随机的密码，账户名是user，使用它可以进行登录。</p>
<p>如果使用postman进行访问，可以在Basis Auth中配置账号密码。如果验证成功，会自动跳转到/目录。</p>
<p><code>此时可能发生的404错误是由于/目录下访问不到资源而导致的404.</code></p>
<h4 id="1-1-配置用户名密码"><a href="#1-1-配置用户名密码" class="headerlink" title="1.1 配置用户名密码"></a>1.1 配置用户名密码</h4><p>如果配置了用户名和密码，SpringBoot项目启动的时候不再生成随机密码。</p>
<p>配置密码的方式有3种：</p>
<ul>
<li>在配置文件中配置</li>
<li>在配置类中配置</li>
<li>保存到数据库</li>
</ul>
<h4 id="1-2-在配置文件中配置"><a href="#1-2-在配置文件中配置" class="headerlink" title="1.2 在配置文件中配置"></a>1.2 在配置文件中配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">      <span class="attr">roles:</span> <span class="comment"># 角色，List&lt;String&gt;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-在配置类中配置"><a href="#1-3-在配置类中配置" class="headerlink" title="1.3 在配置类中配置"></a>1.3 在配置类中配置</h4><p>需要继承WebSecurityConfigurerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码不加密,可以使用明文密码，已经过时</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置多个用户的账号密码角色，其中密码能配置成明文是因为NoOpPasswordEncoder的作用</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        		<span class="comment">// 开启登录配置</span></span><br><span class="line">                http.authorizeRequests()</span><br><span class="line">            	<span class="comment">// /admin/**的url需要admin角色才能访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            	<span class="comment">// /user/**的url,admin和user角色都可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">                .hasAnyRole(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;user&quot;</span>)</span><br><span class="line">            	<span class="comment">// 其他的请求，只要登录了就可以访问</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            	<span class="comment">// 登录的时候访问的url修改为/doLogin,账号和密码的参数名称是user和pwd</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">            	<span class="comment">// 登录成功后的处理，这里返回JSON格式的数据</span></span><br><span class="line">                .successHandler( (request,response,authentication) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter writer = response.getWriter();</span><br><span class="line">                    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>,authentication.getPrincipal());</span><br><span class="line">                    String result = <span class="keyword">new</span> ObjectMapper().writeValueAsString(map);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.write(result);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 登录失败后的处理，这里返回JSON格式的数据</span></span><br><span class="line">                .failureHandler( (request,response,exception) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter writer = response.getWriter();</span><br><span class="line">                    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;status&quot;</span>,<span class="number">500</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>,exception.getMessage());</span><br><span class="line">                    String result = <span class="keyword">new</span> ObjectMapper().writeValueAsString(map);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.write(result);</span><br><span class="line">                &#125;)</span><br><span class="line">            	<span class="comment">// 和表单登录相关的接口都可以访问</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            	<span class="comment">// 退出登录时访问的url</span></span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">            	<span class="comment">// 成功退出时的处理，返回JSON数据</span></span><br><span class="line">                .logoutSuccessHandler( (request,response,authentication) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter writer = response.getWriter();</span><br><span class="line">                    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">                    String result = <span class="keyword">new</span> ObjectMapper().writeValueAsString(map);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.write(result);</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">            	<span class="comment">// 禁用CSRF</span></span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。</p>
<p>因此我们还可以通过重写 WebSecurityConfigurerAdapter 中的 userDetailsService 方法来提供一个 UserDetailService 实例进而配置多个用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JdbcUserDetailsManager、InMemoryUserDetailsManager都是UserDetailService的实例</span></span><br><span class="line">    InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">    <span class="comment">// 参数是一个UserDetails,通过User.withUsername等方法返回的UserBuilder.build返回一个UserDetails实例</span></span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;ming&quot;</span>).password(<span class="string">&quot;$2a$10$vcMANJ1FiElZyS31BwuiwusGihNfcoGGQJJtdJEqi7C4Ukpv26fze&quot;</span>).roles(<span class="string">&quot;user&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>但是需要注意的是，两种方式只能选择其中一种。</code></p>
<h4 id="1-4-在数据库中配置"><a href="#1-4-在数据库中配置" class="headerlink" title="1.4 在数据库中配置"></a>1.4 在数据库中配置</h4><p>从数据库中配置就需要创建数据表保存账户、角色信息。</p>
<p><code>建表语句：</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SQLyog Ultimate v12.4.3 (64 bit)</span></span><br><span class="line"><span class="comment">MySQL - 5.7.17-log : Database - security</span></span><br><span class="line"><span class="comment">*********************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET NAMES utf8 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=&#x27;&#x27;*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`security` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `security`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nameZh` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `role`(`id`,`name`,`nameZh`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;ROLE_dba&#x27;</span>,<span class="string">&#x27;数据库管理员&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;ROLE_admin&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;ROLE_user&#x27;</span>,<span class="string">&#x27;用户&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `locked` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `<span class="keyword">user</span>`(`id`,`username`,`password`,`enabled`,`locked`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;sang&#x27;</span>,<span class="string">&#x27;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `uid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">5</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `user_role`(`id`,`uid`,`rid`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>user</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>password</th>
<th>enabled</th>
<th>locker</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>root</td>
<td>$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>admin</td>
<td>$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>sang</td>
<td>$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<blockquote>
<p>role</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>nameZh</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ROLE_dba</td>
<td>数据库管理员</td>
</tr>
<tr>
<td>2</td>
<td>ROLE_admin</td>
<td>系统管理员</td>
</tr>
<tr>
<td>3</td>
<td>ROLE_user</td>
<td>用户</td>
</tr>
</tbody></table>
<blockquote>
<p>user_role</p>
</blockquote>
<p>root用户拥有dba,admin角色。</p>
<p>admin用户拥有admin角色。</p>
<p>user用户拥有user角色。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>rid</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>创建好表后，我们需要连接数据库，这里我就使用JPA来连接数据库，在连接数据库之前记得导入mysql、druid、jpa的依赖。</p>
<p>我们还需编写配置文件和创建实体User,Role。</p>
<p><code>配置文件:</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">none</span></span><br><span class="line">      <span class="attr">naming:</span></span><br><span class="line">        <span class="attr">physical-strategy:</span> <span class="string">org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="comment"># format-sql必须放在properties.hibernate才有效,而且使用的是下划线</span></span><br><span class="line">        <span class="attr">format_sql:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br></pre></td></tr></table></figure>

<p>User类实现了<code>UserDetails</code>接口，并实现了其方法。UserDetails接口是告诉Spring Security，我这个User类的哪些属性对应着登录名，密码等。</p>
<p>我们希望在验证用户是否在系统中存在的时候，把该用户的角色给它赋值上。这里使用了JPA的导航属性，在查询出User类的时候，就会把对应的角色给赋值了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean locked;</span><br><span class="line">    <span class="comment">// 这里设置roles属性不能使用懒加载，懒加载会报错</span></span><br><span class="line">    <span class="comment">// 在查询出roles属性的时候才使用懒加载</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;user_role&quot;,joinColumns = @JoinColumn(name = &quot;uid&quot;),</span></span><br><span class="line"><span class="meta">               inverseJoinColumns = @JoinColumn(name = &quot;rid&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.roles.stream()</span><br><span class="line">                .map(r -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(r.getName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否还没过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否未被锁定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 凭证是否未过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Role:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 这里的column实际上是无效的，因为@Column指定的name属性和实体属性名称相同就会失效。</span></span><br><span class="line">    <span class="comment">// 需要到配置文件中指定JPA的命名策略</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;nameZh&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nameZh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service实现了UserDetailsService,稍后在配置Spring Security的用户时会用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数username就是前端参数登录时传递过来的</span></span><br><span class="line"><span class="comment">     * 只需要判断登录的用户在系统存在与否</span></span><br><span class="line"><span class="comment">     * 至于密码校验那些，交给Spring Security</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user =  userDao.findUserByUserName(username)</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;username not found&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置角色，使用JPA的导航属性</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserDao:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Optional&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DataBaseSecurityConfiguration:</code></p>
<p>配置Spring Security的用户信息，httpConfig，密码编码等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBaseSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/dba/**&quot;</span>)</span><br><span class="line">                .hasRole(<span class="string">&quot;dba&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HelloController:</code></p>
<p>编写3个接口，分别测试dba,admin,user的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dba/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dba</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,dba&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结：使用数据库配置Spring Security的账户密码</p>
<ul>
<li>实体类需要实现UserDetail接口，提供给Spring Security一些信息做为验证的依据</li>
<li>Spring Security在配置用户信息的时候需要一个UserDetailService，我们需要创建一个Service实现UserDetailService接口，查询前端登录的用户在系统中是否存在，其他验证工作交给Spring Security即可</li>
</ul>
</blockquote>
<blockquote>
<p>使用JDBC从数据库中配置</p>
</blockquote>
<p>在org\springframework\security\spring-security-core\5.4.2\spring-security-core-5.4.2.jar!\org\springframework\security\core\userdetails\jdbc\users.ddl</p>
<p>如果是使用Mysql数据库，把varchar_ignorecase改成varchar就可以了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,password varchar_ignorecase(<span class="number">500</span>) <span class="keyword">not</span> <span class="keyword">null</span>,enabled <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> authorities (username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,authority varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,<span class="keyword">constraint</span> fk_authorities_users <span class="keyword">foreign</span> key(username) <span class="keyword">references</span> users(username));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index ix_auth_username <span class="keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure>

<p>使用JdbcUserDetailsManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要datasource</span></span><br><span class="line">    JdbcUserDetailsManager manager = <span class="keyword">new</span> JdbcUserDetailsManager(dataSource);</span><br><span class="line">    <span class="comment">// 系统每次启动都会执行这段代码，需要判断用户在数据库中是否存在，避免多次创建用户</span></span><br><span class="line">    <span class="keyword">if</span>(!manager.userExists(<span class="string">&quot;user&quot;</span>))&#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;$2a$10$vcMANJ1FiElZyS31BwuiwusGihNfcoGGQJJtdJEqi7C4Ukpv26fze&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!manager.userExists(<span class="string">&quot;ming&quot;</span>)) &#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;ming&quot;</span>).password(<span class="string">&quot;$2a$10$vcMANJ1FiElZyS31BwuiwusGihNfcoGGQJJtdJEqi7C4Ukpv26fze&quot;</span>).roles(<span class="string">&quot;user&quot;</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(userDetailsService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-5-多个HttpConfig的配置"><a href="#1-5-多个HttpConfig的配置" class="headerlink" title="1.5 多个HttpConfig的配置"></a>1.5 多个HttpConfig的配置</h4><p>HttpConfig是配置访问规则的，可以存在多个。</p>
<p>如果需要多个配置多个HttpConfig，可以使用多个静态内部类继承WebSecurityConfigurerAdapter来注册多个。</p>
<p>多个类需要使用@Order来指定执行顺序。数值越小，优先级越高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiSecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 即使多个HttpConfig,账户密码也是一样的</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// /admin/**下的所有请求都需要admin角色才能访问</span></span><br><span class="line">            http.antMatcher(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest()</span><br><span class="line">                    .hasRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">                    .hasAnyRole(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                    .anyRequest()</span><br><span class="line">                    .authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf()</span><br><span class="line">                    .disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-6-加密密码"><a href="#1-6-加密密码" class="headerlink" title="1.6 加密密码"></a>1.6 加密密码</h4><p>Spring Security提供了BCryptPasswordEncoder类，可以加密密码。</p>
<p>即使明文是一致的，生成的加密密码也会不一样，先来看一个简单的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BCryptPasswordEncoder encoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        String password1 = encoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        String password2 = encoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(password1);</span><br><span class="line">        System.out.println(password2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明文密码123生成的加密密码是不一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$2a$10$CuU3nXzZ.DtVmI5hxxNS1exrV0nSECqL182g/ockvp8tylmdYb67O</span><br><span class="line">$2a$10$Or.xAznkldCAQKnuFyKMG.V9.VAfI0pk7tUeVdNGP9vZDFT5stj72</span><br></pre></td></tr></table></figure>

<p>我们可以在之前的配置类中使用加密密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder(); <span class="comment">// 使用BCryptPasswordEncoder</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将明文密码123通过BCryptPasswordEncoder生成的加密密码配置在这里，通过密码123就能登录</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">        .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;$2a$10$CuU3nXzZ.DtVmI5hxxNS1exrV0nSECqL182g/ockvp8tylmdYb67O&quot;</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .withUser(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;$2a$10$Or.xAznkldCAQKnuFyKMG.V9.VAfI0pk7tUeVdNGP9vZDFT5stj72&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-7-方法级别的权限"><a href="#1-7-方法级别的权限" class="headerlink" title="1.7 方法级别的权限"></a>1.7 方法级别的权限</h4><p>可以使用@PreAuthorize、@PostAuthorize、@Secured三个注解对方法的访问进行限制。</p>
<p>同时需要配置@EnableGlobalMethodSecurity注解开启全局方法限制。</p>
<p>controller中需要访问service层的方法，@EnableGlobalMethodSecurity加在controller层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// prePostEnabled：开启@PreAuthorize、@PostAuthorize的权限验证</span></span><br><span class="line"><span class="comment">// securedEnabled：开启@Secured的权限验证</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> helloService.hello3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>service层中的方法中使用@PreAuthorize、@PostAuthorize、@Secured三个注解对方法的访问进行限制。</p>
<p>@PreAuthorize、@PostAuthorize可以使用表达式。</p>
<p>@Secured只能使用ROLE_角色名称，并且需要注意大小写。如果大小写写错，这个方法限制没生效，所有的用户都可以访问该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// admin、user角色都可以访问该方法</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;user&#x27;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只有user角色能访问该方法</span></span><br><span class="line">    <span class="meta">@Secured(&quot;ROLE_user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只有admin角色能访问该方法</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-8-角色继承"><a href="#1-8-角色继承" class="headerlink" title="1.8 角色继承"></a>1.8 角色继承</h4><p>上级可能具备下级的所有权限，如果使用角色继承，这个功能就很好实现，我们只需要在 SecurityConfig 中添加如下代码来配置角色继承关系即可。</p>
<p>角色继承的配置只需要在配置类中，将RoleHierarchy加入到容器即可。</p>
<p><code>注意，在配置时，需要给角色手动加上 </code>ROLE_<code>前缀。下面的配置表示</code>ROLE_admin<code>自动具备</code>ROLE_user<code> 的权限。</code>.</p>
<p>如果有多个角色继承关系的配置，使用空格分割开。比如<code>ROLE_admin &gt; ROLE_user  ROLE_root &gt; ROLE_user</code></p>
<p>但是SpringBoot 2.4.1的版本是使用\n分隔符,<code>ROLE_admin &gt; ROLE_user \n ROLE_root &gt; ROLE_user</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RoleHierarchy <span class="title">roleHierarchy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl roleHierarchy = <span class="keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_admin &gt; ROLE_user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-9-动态权限配置"><a href="#1-9-动态权限配置" class="headerlink" title="1.9 动态权限配置"></a>1.9 动态权限配置</h4><p>前面我们配置的HttpConfig都是写在配置类中的，在真实的项目中，这显然不合理。</p>
<p>真实项目中，应该从把哪些角色可以访问哪些资源的信息保存到数据库中。修改了数据库的信息，就相当于动态修改了权限。</p>
<p>在之前的security库中添加menu和menu_role两张表。</p>
<p>menu代表着可以访问的资源的路径，menu_role代表着访问资源的路径和角色之间的关系。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Table structure for table `menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `menu` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `<span class="keyword">pattern</span>` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `menu`(`id`,`<span class="keyword">pattern</span>`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;/db/**&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;/admin/**&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;/user/**&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `menu_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `menu_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `menu_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `mid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `menu_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `menu_role`(`id`,`mid`,`rid`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>menu</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>pattern</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/dba/**</td>
</tr>
<tr>
<td>2</td>
<td>/admin/**</td>
</tr>
<tr>
<td>3</td>
<td>/user/**</td>
</tr>
</tbody></table>
<blockquote>
<p>menu_role</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>mid</th>
<th>rid</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>新增实体类<code>Menu:</code></p>
<p>一个资源可能有多个角色可以访问，有List<Role>属性代表可以访问该资源的所有角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;menu_role&quot;,joinColumns = @JoinColumn(name = &quot;mid&quot;),</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = @JoinColumn(name = &quot;rid&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态配置权限需要两个类：</p>
<ul>
<li><p>根据当前的请求，从数据库中查询出哪些角色可以访问该资源</p>
</li>
<li><p>根据数据库中查询出来的角色和当前登录用户的角色进行对比,校验能否访问</p>
</li>
</ul>
<p><code>RequestUrlFilter:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Date</span> 2021/01/16 15:39</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> 根据当前的请求路径,从数据库中获取访问当前路径需要的角色列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestUrlFilter</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuDao menuDao;</span><br><span class="line">    <span class="comment">// 注意是new出来的,不是注入</span></span><br><span class="line">    <span class="keyword">private</span> AntPathMatcher antPathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object o)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        FilterInvocation filterInvocation = (FilterInvocation) o;</span><br><span class="line">        <span class="comment">// 获取当前请求路径</span></span><br><span class="line">        String requestUrl = filterInvocation.getRequestUrl();</span><br><span class="line">        <span class="comment">// 获取数据库中的路径</span></span><br><span class="line">        List&lt;Menu&gt; allMenu = menuDao.findAll();</span><br><span class="line">        <span class="comment">// 获取当前请求路径需要的角色列表</span></span><br><span class="line">        List&lt;String&gt; roleNames = allMenu.stream()</span><br><span class="line">                .filter(menu -&gt; antPathMatcher.match(menu.getPattern(), requestUrl))</span><br><span class="line">                .flatMap(menu -&gt; menu.getRoles().stream())</span><br><span class="line">                .map(r -&gt; r.getName())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// list转数组,如果访问的路径与数据库中的路径不匹配，返回一个标识ROLE_login(自定义的,后面判断的时候用到)</span></span><br><span class="line">        String[] roleArray = <span class="keyword">new</span> String[roleNames.size()];</span><br><span class="line">        <span class="comment">// 不能返回空集合，否则进不了DecisionManager</span></span><br><span class="line">        <span class="keyword">return</span> SecurityConfig.createList(CollectionUtils.isEmpty(roleNames) ? <span class="keyword">new</span> String[]&#123;<span class="string">&quot;ROLE_login&quot;</span>&#125;</span><br><span class="line">                : roleNames.toArray(roleArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Lambda写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Date</span> 2021/01/22 22:44</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> 返回有权访问当前请求的角色列表,</span></span><br><span class="line"><span class="comment"> * 如果当前请求在数据库中找不到对应的角色列表,不能返回空集合,而是返回一个标识,</span></span><br><span class="line"><span class="comment"> * 在DecisionManager中可以根据这个标识判断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuRoleFilter</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line">    <span class="keyword">private</span> AntPathMatcher antPathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object o)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        String requestUrl = ((FilterInvocation) o).getRequestUrl();</span><br><span class="line">        <span class="comment">// 获取所有菜单和菜单对应的角色</span></span><br><span class="line">        List&lt;Menu&gt; menuList = menuMapper.getAllMenuWithRole();</span><br><span class="line">        <span class="comment">// 访问当前请求需要的角色列表,如果匹配不到请求,返回空集合</span></span><br><span class="line">        List&lt;String&gt; roleNameList = menuList.stream()</span><br><span class="line">                .filter(m -&gt; m.getPath()!=<span class="keyword">null</span>)</span><br><span class="line">                .filter(m -&gt; antPathMatcher.match(m.getPath(), requestUrl))</span><br><span class="line">                .flatMap(m -&gt; m.getRoles().stream())</span><br><span class="line">                .map(Role::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        String[] roleNameArray = <span class="keyword">new</span> String[roleNameList.size()];</span><br><span class="line">        <span class="comment">// 不能返回空集合，否则进不了DecisionManager</span></span><br><span class="line">        <span class="keyword">return</span> roleNameList.size() == <span class="number">0</span> ?SecurityConfig.createList(<span class="string">&quot;ROLE_LOGIN&quot;</span>)</span><br><span class="line">                : SecurityConfig.createList(roleNameArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>MyAccessDecisionManager:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Date</span> 2021/01/16 15:59</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> 访问当前路径所需要的角色和数据库中的角色进行校验</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定当前登录的用户是否有权限访问当前访问的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication 用户的登录信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o FilterInvocation对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection FilterInvocationSecurityMetadataSource返回的角色列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AccessDeniedException 没有权限访问时抛出的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InsufficientAuthenticationException 有部分权限，但是权限不足以访问的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection)</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute configAttribute : collection) &#123;</span><br><span class="line">            String needRole = configAttribute.getAttribute();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;ROLE_LOGIN&quot;</span>.equals(needRole)) &#123;</span><br><span class="line">                <span class="comment">// 当前访问的请求在数据库中匹配不到相应的请求</span></span><br><span class="line">                <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientAuthenticationException(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前用户的角色列表</span></span><br><span class="line">                Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">                <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(needRole.equals(authority.getAuthority()))&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientAuthenticationException(<span class="string">&quot;权限不足,请联系管理员..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute configAttribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在配置类中注入<code>RequestUrlFilter,MyAccessDecisionManager</code>,并在config中配置它们，完整的配置类如下：</p>
<p><code>如果使用动态控制权限，就不能再配置anyRequest().antherticated()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBaseSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestUrlFilter requestUrlFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDecisionManager myAccessDecisionManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RoleHierarchy <span class="title">roleHierarchy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoleHierarchyImpl roleHierarchy = <span class="keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">        roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_root &gt; ROLE_user \n ROLE_admin &gt; ROLE_user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O o)</span> </span>&#123;</span><br><span class="line">                        o.setSecurityMetadataSource(requestUrlFilter);</span><br><span class="line">                        o.setAccessDecisionManager(myAccessDecisionManager);</span><br><span class="line">                        <span class="keyword">return</span> o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-0-从内存中获取登录信息"><a href="#2-0-从内存中获取登录信息" class="headerlink" title="2.0 从内存中获取登录信息"></a>2.0 从内存中获取登录信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hr hr = (Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br></pre></td></tr></table></figure>



<h4 id="2-1-JSON格式登陆"><a href="#2-1-JSON格式登陆" class="headerlink" title="2.1 JSON格式登陆"></a>2.1 JSON格式登陆</h4><p>Spring Security默认是使用Key-Value的形式进行登陆的。也就是默认的/login请求只支持Key-Value的POST请求。</p>
<p>用户登陆的用户名/密码是在<code>UsernamePasswordAuthenticationFilter</code>类中处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</span><br><span class="line">            username = username != <span class="keyword">null</span> ? username : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            username = username.trim();</span><br><span class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</span><br><span class="line">            password = password != <span class="keyword">null</span> ? password : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中，我们就可以看出来为什么 Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是 request.getParameter。</p>
<p>所以我们要定义成 JSON 的，思路很简单，就是自定义来定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code> ，重写attemptAuthentication方法.</p>
<p><code>JsonAuthenticationFilter:</code> 定义一个过滤器继承<code>UsernamePasswordAuthenticationFilter</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 只支持POST方法</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;POST&quot;</span>.equals(request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理JSON格式的数据,从reqeust中用流的方式读取成Map</span></span><br><span class="line">        <span class="keyword">if</span> (MediaType.APPLICATION_JSON_VALUE.equals(request.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Map&lt;String, String&gt; params = <span class="keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);</span><br><span class="line">                String username = params.get(<span class="keyword">this</span>.getUsernameParameter());</span><br><span class="line">                username = username != <span class="keyword">null</span> ? username.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String password = params.get(<span class="keyword">this</span>.getPasswordParameter());</span><br><span class="line">                password = password != <span class="keyword">null</span> ? password.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                UsernamePasswordAuthenticationToken authRequest =</span><br><span class="line">                        <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">                <span class="keyword">this</span>.setDetails(request,authRequest);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是调用父类处理Key-Value的方法,如果使用this,就造成递归调用了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要在配置类中创建自己的Filter类，并配置到HttpConfig中,filter中能设置的属性跟formLogin的差不多。Filter中设置的和formLogin设置的都能起效，但一般只需要设置一个即可，完整的配置类如下:</p>
<p><code>SecurityConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       auth.inMemoryAuthentication()</span><br><span class="line">               .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">               .password(<span class="string">&quot;$2a$10$vcMANJ1FiElZyS31BwuiwusGihNfcoGGQJJtdJEqi7C4Ukpv26fze&quot;</span>)</span><br><span class="line">               .roles(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().mvcMatchers(<span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/css/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            	<span class="comment">// 注册自己编写的Filter</span></span><br><span class="line">                .addFilterAt(jsonAuthenticationFilter(), JsonAuthenticationFilter.class)</span><br><span class="line">            	<span class="comment">// 这里设置formLogin与Filter的不冲突</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JsonAuthenticationFilter <span class="title">jsonAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JsonAuthenticationFilter filter = <span class="keyword">new</span> JsonAuthenticationFilter();</span><br><span class="line">        filter.setUsernameParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        filter.setPasswordParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 这个非常重要</span></span><br><span class="line">        filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        <span class="comment">// 类似于loginProcessUrl</span></span><br><span class="line">        filter.setFilterProcessesUrl(<span class="string">&quot;/doLogin&quot;</span>);</span><br><span class="line">        filter.setAuthenticationSuccessHandler((request,response,auth) -&gt; &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">            result.put(<span class="string">&quot;data&quot;</span>,auth.getPrincipal());</span><br><span class="line">            writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(result));</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;);</span><br><span class="line">        filter.setAuthenticationFailureHandler( (request,response,e) -&gt; &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            result.put(<span class="string">&quot;status&quot;</span>,<span class="number">500</span>);</span><br><span class="line">            result.put(<span class="string">&quot;data&quot;</span>,e.getMessage());</span><br><span class="line">            writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(result));</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-2-持久化令牌"><a href="#2-2-持久化令牌" class="headerlink" title="2.2 持久化令牌"></a>2.2 持久化令牌</h4><p>当每次使用用户名/密码登陆的时候，会生成一个series和token，浏览器把它保存在cookie中。当退出浏览器再重新访问的时候，还是同一个cookie，并不会重新生成新的token。</p>
<p>而当在别端访问的时候，使用用户名/密码登陆的时候，会生成新的token，之前的浏览器cookie就会失效，从而实现多端踢下线的功能。</p>
<p>如果之前在别端访问过，又没有退出，是可以继续访问的。</p>
<p>如果使用Spring Security自带的JdbcPersistentTokenRepository,需要添加一张数据表，JdbcPersistentTokenRepository会操作这张表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `persistent_logins` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `series` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `token` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_used` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`series`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>配置类中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">        .hasRole(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .antMatchers(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">        .hasRole(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .addFilterAt(jsonAuthenticationFilter(), JsonAuthenticationFilter.class)</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .key(<span class="string">&quot;ming&quot;</span>)</span><br><span class="line">        .tokenRepository(persistentTokenRepository())</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-自定义验证逻辑-验证码"><a href="#2-2-自定义验证逻辑-验证码" class="headerlink" title="2.2 自定义验证逻辑-验证码"></a>2.2 自定义验证逻辑-验证码</h4><p>首先，需要引入验证码的框架:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置验证码,这里主要是设置一下验证码图片的宽高等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Producer <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>,<span class="string">&quot;150&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>,<span class="string">&quot;50&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.string&quot;</span>,<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> DefaultKaptcha();</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口返回验证码图片:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;code.jpg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codeImage</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        response.setContentType(MediaType.IMAGE_JPEG_VALUE);</span><br><span class="line">        String text = producer.createText();</span><br><span class="line">        BufferedImage image = producer.createImage(text);</span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;vCode&quot;</span>,text);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServletOutputStream out = response.getOutputStream();</span><br><span class="line">            ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自己的AutherationProvider,继承自DaoAuthenticationProvider，因为所有的账户/密码登陆的方式都会经过这里，我们可以在这里添加验证码的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">DaoAuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 验证码逻辑</span></span><br><span class="line">        HttpServletRequest request =</span><br><span class="line">                ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        String code = request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        String vCode = (String) request.getSession().getAttribute(<span class="string">&quot;vCode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="keyword">null</span> || vCode == <span class="keyword">null</span> || !code.equals(vCode)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类中添加自己写的AuthenticationProvider，同时放开访问验证码图片的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationManager <span class="title">authenticationManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProviderManager(myAuthenticationProvider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MyAuthenticationProvider <span class="title">myAuthenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAuthenticationProvider provider = <span class="keyword">new</span> MyAuthenticationProvider();</span><br><span class="line">    provider.setPasswordEncoder(passwordEncoder());</span><br><span class="line">    provider.setUserDetailsService(userDetailsService());</span><br><span class="line">    <span class="keyword">return</span> provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/code.jpg&quot;</span>)</span><br><span class="line">        .permitAll()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">        .hasRole(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .antMatchers(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">        .hasRole(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .addFilterAt(jsonAuthenticationFilter(), JsonAuthenticationFilter.class)</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        <span class="comment">// .key(&quot;ming&quot;)</span></span><br><span class="line">        .tokenRepository(persistentTokenRepository())</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-异常处理"><a href="#2-3-异常处理" class="headerlink" title="2.3 异常处理"></a>2.3 异常处理</h4><p>当未登录直接访问url时，拦截器(DecisionManager)会抛出异常,并重定向到/login登录页面，此时前端是没有通过代理的，直接访问url，就会出现跨域的问题。</p>
<p>有一种解决方案是在/login上添加跨域的注解,但这不是很好，我希望后端返回<code>未登录</code>的信息给前端，这就需要异常处理了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Redis/redis/</url>
    <content><![CDATA[<h3 id="1-redis是什么？"><a href="#1-redis是什么？" class="headerlink" title="1.redis是什么？"></a>1.redis是什么？</h3><blockquote>
<p>讲redis不得不讲nosql</p>
</blockquote>
<ul>
<li>nosql不使用sql作为查询语言。</li>
<li>nosql存储数据可以不需要固定的表格形式，它是基于键值对存储的。</li>
</ul>
<blockquote>
<p>redis的定义</p>
</blockquote>
<ul>
<li>redis可以用作数据库、缓存、消息中间件。</li>
<li>redis支持多种类型的数据结构。如字符串(String),散列(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)。</li>
</ul>
<h3 id="2-redis-memcached-mysql的比较"><a href="#2-redis-memcached-mysql的比较" class="headerlink" title="2.redis,memcached,mysql的比较"></a>2.redis,memcached,mysql的比较</h3><h4 id="2-1-数据类型，存储方式的比较"><a href="#2-1-数据类型，存储方式的比较" class="headerlink" title="2.1 数据类型，存储方式的比较"></a>2.1 数据类型，存储方式的比较</h4><table>
<thead>
<tr>
<th>数据库类型</th>
<th>数据存储方式</th>
<th>特色功能</th>
</tr>
</thead>
<tbody><tr>
<td>mysql</td>
<td>硬盘持久化</td>
<td>事务</td>
</tr>
<tr>
<td>memcached</td>
<td>内存</td>
<td></td>
</tr>
<tr>
<td>redis</td>
<td>硬盘持久化+内存</td>
<td>支持多种数据类型</td>
</tr>
</tbody></table>
<h4 id="2-2-内存缓存memcached、redis的比较"><a href="#2-2-内存缓存memcached、redis的比较" class="headerlink" title="2.2 内存缓存memcached、redis的比较"></a>2.2 内存缓存memcached、redis的比较</h4><table>
<thead>
<tr>
<th></th>
<th>内存管理机制</th>
<th>持久化方案</th>
<th>缓存数据过期机制</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>memcached</td>
<td>基于Slab Allocation机制管理内存,其主要思想是按照预先规定的大小,将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录,以完全解决内存碎片问题。<code>通过空闲列表判断存储状态。</code>[类似于Java虚拟机对象的分配,空闲列表]</td>
<td>不支持数据持久化操作,所有的数据都保存在内存中</td>
<td>不会监视数据是否过期,而在获取数据时才会检查数据是否已经失效。[类似与懒加载]</td>
<td>只支持单一的KV键值对数据类型</td>
</tr>
<tr>
<td>redis</td>
<td>现场申请内存的机制,由于分配内存是连续的,并且很少使用空闲列表来优化内存分配,<code>会在一定程度上存在内存碎片</code>。[类似于Java虚拟机对象的分配,直接内存分配]</td>
<td>支持rdb和aof两种不同的持久化方法。<code>rdb属于全量数据备份,备份的是数据。aof数据增量备份，备份的是指令。</code></td>
<td>定时、定期等多种缓存失效策略</td>
<td>支持五种数据类型</td>
</tr>
</tbody></table>
<h3 id="3-redis作为数据库和作为缓存的选择"><a href="#3-redis作为数据库和作为缓存的选择" class="headerlink" title="3.redis作为数据库和作为缓存的选择"></a>3.redis作为数据库和作为缓存的选择</h3><h3 id="4-redis设置"><a href="#4-redis设置" class="headerlink" title="4.redis设置"></a>4.redis设置</h3><h4 id="4-1-远程连接设置"><a href="#4-1-远程连接设置" class="headerlink" title="4.1 远程连接设置"></a>4.1 远程连接设置</h4><blockquote>
<p>1.修改redis.conf配置文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定可以访问redis的网段。默认值是<span class="built_in">bind</span> 127.0.0.1,只允许本地访问。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> ip,即只允许ip指定的地址能远程访问redis，连localhost都无法访问</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 0.0.0.0 或注释掉这一行,即允许任何ip访问</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保护模式，默认是protected-mode yes开启保护模式的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果设置了<span class="built_in">bind</span>或者requirepass,则可以设置为yes,不影响远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程访问的密码,可以设置,也可以不设置,为了安全性,最好设置上密码</span></span><br><span class="line">requirepass root</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.检查防火墙</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查6379端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=6379/tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久开放6379端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙状态：</span></span><br><span class="line">firewall-cmd --state </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查防火墙开放的端口</span></span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙开机自启动</span></span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙取消某一开放端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=9200/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止firewall开机启动</span></span><br><span class="line">systemctl disable firewalld.service </span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.如果使用阿里云,记得开放阿里云安全组的端口</p>
</blockquote>
<h4 id="4-2-脚本启动redis认证密码"><a href="#4-2-脚本启动redis认证密码" class="headerlink" title="4.2 脚本启动redis认证密码"></a>4.2 脚本启动redis认证密码</h4><p>在使用脚本启动redis的时候，如果设置了redis密码，在进行<code>service redisd stop</code>操作的时候会出现以下错误:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(error) NOAUTH Authentication required</span><br></pre></td></tr></table></figure>

<p>此时，可以在/etc/init.d/redisd脚本文件中添加-a密码选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加-a 密码选项</span></span><br><span class="line"><span class="meta">$</span><span class="bash">CLIEXEC  -a <span class="string">&#x27;password&#x27;</span> -p <span class="variable">$REDISPORT</span> shutdown</span></span><br></pre></td></tr></table></figure>



<h3 id="5-redis事务"><a href="#5-redis事务" class="headerlink" title="5.redis事务"></a>5.redis事务</h3><h4 id="5-1-MULTI-与-EXEC"><a href="#5-1-MULTI-与-EXEC" class="headerlink" title="5.1 MULTI 与 EXEC"></a>5.1 MULTI 与 EXEC</h4><p>MULTI</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Cloud/Docker/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1. Docker简介"></a>1. Docker简介</h3><p>Docker是一种虚拟化技术，类比于虚拟机。虚拟机需要模拟硬件还有很多不常用的软件等，而Docker是共用宿主机的内核，需要什么软件就引入相应的容器，而且各个容器之间是隔离的，互不影响也能通信。<code>Dockre是比虚拟机更加轻量的虚拟技术。</code></p>
<h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><blockquote>
<p>镜像image</p>
</blockquote>
<p>Docker镜像就好比是一个模板，可以通过这个模板来创建容器服务(可以创建多个容器)。</p>
<p>比如，tomcat镜像 -&gt; run -&gt; tomcat容器（提供服务）。</p>
<blockquote>
<p>容器Container</p>
</blockquote>
<p>Docker利用容器技术，独立运行一个或一组应用。</p>
<p>容器是通过镜像来创建的。</p>
<blockquote>
<p>仓库Repository</p>
</blockquote>
<p>仓库就是存放镜像的地方。分为公有仓库和私有仓库。</p>
<p>DockerHub(国外)，阿里云(国内，配置镜像加速)</p>
<h4 id="1-2-安装Docker"><a href="#1-2-安装Docker" class="headerlink" title="1.2 安装Docker"></a>1.2 安装Docker</h4><ol>
<li>查看环境</li>
</ol>
<p>查看Linux版本，系统内核要求3.10以上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Linux ming <span class="number">3.10</span><span class="number">.0</span><span class="number">-514.26</span><span class="number">.2</span>.el7.x86_64 #<span class="number">1</span> SMP Tue Jul <span class="number">4</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span> UTC <span class="number">2017</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>查看系统信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装Docker</li>
</ol>
<blockquote>
<p>如果已经安装过docker，卸载已经安装的版本</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置Docker的仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 下载yum-utils(其中包含了yum-config-manager)</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置阿里的docker仓库地址</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装Docker</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除缓存</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载docker</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看Docker版本信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>出现以下结果，说明Docker安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.1</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        831ebea</span><br><span class="line"> Built:             Tue Dec 15 04:37:17 2020</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动docker</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行hello-world示例镜像</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101205537190.png" alt="image-docker hello-world"></p>
<h4 id="1-3-阿里云镜像加速器"><a href="#1-3-阿里云镜像加速器" class="headerlink" title="1.3 阿里云镜像加速器"></a>1.3 阿里云镜像加速器</h4><p>登录阿里云，找到<code>容器镜像服务</code>，镜像加速器。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101213032540.png" alt="image-阿里云镜像加速器"></p>
<h4 id="1-4-docerk-run-流程"><a href="#1-4-docerk-run-流程" class="headerlink" title="1.4 docerk run 流程"></a>1.4 docerk run 流程</h4><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101214614552.png" alt="image-docker run运行流程"></p>
<h4 id="1-5-底层原理"><a href="#1-5-底层原理" class="headerlink" title="1.5 底层原理"></a>1.5 底层原理</h4><blockquote>
<p>Docker是怎么工作的？</p>
</blockquote>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在服务器上，客户端通过Socket访问，</p>
<p>Docker Server接收到Docker Client的指令，就会执行这个命令。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101213937951.png" alt="image-Docker工作原理"></p>
<h3 id="2-镜像的基本命令"><a href="#2-镜像的基本命令" class="headerlink" title="2.镜像的基本命令"></a>2.镜像的基本命令</h3><p><a href="https://docs.docker.com/engine/reference/commandline/docker/">官方参考文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助命令</span></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>

<h4 id="2-1-查看镜像"><a href="#2-1-查看镜像" class="headerlink" title="2.1 查看镜像"></a>2.1 查看镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看所有镜像</span></span><br><span class="line">docker images -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看镜像的id</span></span><br><span class="line">docker images -q</span><br></pre></td></tr></table></figure>

<h4 id="2-2-搜索镜像"><a href="#2-2-搜索镜像" class="headerlink" title="2.2 搜索镜像"></a>2.2 搜索镜像</h4><p>搜索镜像可以使用DockerHub搜索，也可以使用命令进行搜索。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 搜索mysql的镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 搜索stars大于9000的本版</span></span><br><span class="line">docker search mysql --filter=stars=9000</span><br></pre></td></tr></table></figure>

<h4 id="2-3-下载镜像"><a href="#2-3-下载镜像" class="headerlink" title="2.3 下载镜像"></a>2.3 下载镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 不指定版本，默认下载最新版本latest</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载指定版本，这里的版本号一定要是DockerHub上有的版本</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>既然知道了真实地址，docker pull mysql:5.7 相当于 docker pull docker.io/library/mysql:5.7</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101225333094.png" alt="image-docker pull mysql:5.7"></p>
<h4 id="2-4-删除镜像"><a href="#2-4-删除镜像" class="headerlink" title="2.4 删除镜像"></a>2.4 删除镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.通过镜像名称删除，-f 强制删除</span></span><br><span class="line">docker rmi -f mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 通过id删除</span></span><br><span class="line">docker rmi -f f07dfa83b528</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 删除所有的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210101225852498.png" alt="image-删除镜像"></p>
<h3 id="3-容器的基本命令"><a href="#3-容器的基本命令" class="headerlink" title="3.容器的基本命令"></a>3.容器的基本命令</h3><h4 id="3-1-创建容器并启动"><a href="#3-1-创建容器并启动" class="headerlink" title="3.1 创建容器并启动"></a>3.1 创建容器并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 以交互模式启动centos容器，交互使用bash命令行</span></span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用images id 启动容器</span></span><br><span class="line">docker run -it 300e315adb2f /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">--name=&quot;&quot;  # 指定容器名字</span><br><span class="line">-d         # 后台方式运行</span><br><span class="line">-it        # 使用交互方式运行，进入容器查看内容</span><br><span class="line">-p         # 指定容器的端口，有以下几种形式</span><br><span class="line">	- 主机端口：容器端口（常用）</span><br><span class="line">	- ip:主机端口：容器端口</span><br><span class="line">	- 容器端口</span><br><span class="line">-P         # 随机指定端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后,主机名称变成了容器id</span></span><br><span class="line">[root@8434890d1132 /]# </span><br><span class="line"></span><br><span class="line">[root@ming local]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">41a27a712b32   centos    &quot;/bin/bash&quot;   14 seconds ago   Up 13 seconds             funny_wright</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-2-查看容器"><a href="#3-2-查看容器" class="headerlink" title="3.2 查看容器"></a>3.2 查看容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看正在运行的容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看正在运行的容器和历史运行的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">-n=1 # 显示最近创建的容器</span><br><span class="line">-q   # 只显示容器id</span><br></pre></td></tr></table></figure>

<h4 id="3-3-退出容器"><a href="#3-3-退出容器" class="headerlink" title="3.3 退出容器"></a>3.3 退出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 退出容器并关闭</span></span><br><span class="line">[root@8434890d1132 /]# exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 退出容器，不关闭</span></span><br><span class="line">CTRL + P + Q </span><br></pre></td></tr></table></figure>

<h4 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h4><p>删除容器使用rm，删除镜像使用rmi。(i = image)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 指定容器id删除</span></span><br><span class="line">docker rm -f 41a27a712b32</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 删除所有容器，指定参数-f强制删除，如果容器正在运行，也能删除</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 删除所有容器，如果容器正在运行，会报错</span></span><br><span class="line">docker ps -aq|xargs docker rm</span><br></pre></td></tr></table></figure>

<h4 id="3-5-启动和停止容器"><a href="#3-5-启动和停止容器" class="headerlink" title="3.5 启动和停止容器"></a>3.5 启动和停止容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 启动容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 重启容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 停止容器</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 容器在运行，可以使用<span class="built_in">kill</span>强制停止容器</span></span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>



<h3 id="4-常用其他命令"><a href="#4-常用其他命令" class="headerlink" title="4.常用其他命令"></a>4.常用其他命令</h3><h4 id="4-1-后台启动容器"><a href="#4-1-后台启动容器" class="headerlink" title="4.1 后台启动容器"></a>4.1 后台启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 镜像名称</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 问题：后台方式启动容器后,docker ps查看容器,发现刚启动的容器停止了?</span></span><br><span class="line">docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止.</span><br></pre></td></tr></table></figure>

<h4 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器7194f420dccf最近10行的日志信息</span></span><br><span class="line">docker logs -tf --tail 10 7194f420dccf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">-f # 显示最新的日志</span><br><span class="line">-t # 显示时间戳</span><br><span class="line">-tail n # 显示最后n行</span><br></pre></td></tr></table></figure>

<p>为了方便查看日志，启动容器的时候让它运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后台方式启动，每隔1s输出hello,world，方便查看日志信息</span></span><br><span class="line">docker run -d centos /bin/sh -c &quot;while true;do echo hello,world;sleep 1;done&quot;</span><br><span class="line"></span><br><span class="line">[root@ming local]# docker logs -tf --tail 10 7194f420dccf </span><br><span class="line">2021-01-02T04:59:49.064172640Z hello,world</span><br><span class="line">2021-01-02T04:59:50.065917036Z hello,world</span><br><span class="line">2021-01-02T04:59:51.067497230Z hello,world</span><br><span class="line">2021-01-02T04:59:52.069279085Z hello,world</span><br><span class="line">2021-01-02T04:59:53.070906928Z hello,world</span><br><span class="line">2021-01-02T04:59:54.072698176Z hello,world</span><br><span class="line">2021-01-02T04:59:55.074312881Z hello,world</span><br><span class="line">2021-01-02T04:59:56.075940314Z hello,world</span><br><span class="line">2021-01-02T04:59:57.077579824Z hello,world</span><br><span class="line">2021-01-02T04:59:58.083724580Z hello,world</span><br><span class="line">2021-01-02T04:59:59.085284061Z hello,world</span><br><span class="line">2021-01-02T05:00:00.086883423Z hello,world</span><br><span class="line">2021-01-02T05:00:01.088530900Z hello,world</span><br></pre></td></tr></table></figure>

<h4 id="4-3-查看容器中进程的信息"><a href="#4-3-查看容器中进程的信息" class="headerlink" title="4.3 查看容器中进程的信息"></a>4.3 查看容器中进程的信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看容器中进程信息</span></span><br><span class="line">docker top 7194f420dccf</span><br></pre></td></tr></table></figure>

<h4 id="4-4-查看镜像的元数据"><a href="#4-4-查看镜像的元数据" class="headerlink" title="4.4 查看镜像的元数据"></a>4.4 查看镜像的元数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;	</span><br><span class="line">        # 容器的完整id，默认只是截取前面几位</span><br><span class="line">        <span class="attr">&quot;Id&quot;</span>: <span class="string">&quot;7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Created&quot;</span>: <span class="string">&quot;2021-01-02T04:54:22.996950933Z&quot;</span>, # 容器创建时间</span><br><span class="line">        <span class="attr">&quot;Path&quot;</span>: <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Args&quot;</span>: [ # 启动容器时使用的参数</span><br><span class="line">            <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;while true;do echo hello,world;sleep 1;done&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;State&quot;</span>: &#123; # 容器状态</span><br><span class="line">            <span class="attr">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;Pid&quot;</span>: <span class="number">19341</span>,</span><br><span class="line">            <span class="attr">&quot;ExitCode&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;StartedAt&quot;</span>: <span class="string">&quot;2021-01-02T04:54:23.420056968Z&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Image&quot;</span>: <span class="string">&quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;</span>, # 镜像信息</span><br><span class="line">        <span class="attr">&quot;ResolvConfPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631/resolv.conf&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;HostnamePath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631/hostname&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;HostsPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631/hosts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;LogPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631/7194f420dccf83fc219103ba4b8fe704583cbe52a8e0ad53bc5ee7c788ece631-json.log&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;/quizzical_brown&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;RestartCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Platform&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MountLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ProcessLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;AppArmorProfile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ExecIDs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Binds&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;ContainerIDFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;LogConfig&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Config&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;NetworkMode&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;PortBindings&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;RestartPolicy&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;no&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;MaximumRetryCount&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;AutoRemove&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;VolumeDriver&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;VolumesFrom&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;CapAdd&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;CapDrop&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;CgroupnsMode&quot;</span>: <span class="string">&quot;host&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Dns&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;DnsOptions&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;DnsSearch&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;ExtraHosts&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;GroupAdd&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;IpcMode&quot;</span>: <span class="string">&quot;private&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Cgroup&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Links&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;OomScoreAdj&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;PidMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Privileged&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;PublishAllPorts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;ReadonlyRootfs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;SecurityOpt&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;UTSMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;UsernsMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ShmSize&quot;</span>: <span class="number">67108864</span>,</span><br><span class="line">            <span class="attr">&quot;Runtime&quot;</span>: <span class="string">&quot;runc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ConsoleSize&quot;</span>: [</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Isolation&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;CpuShares&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;Memory&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;NanoCpus&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CgroupParent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;BlkioWeight&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;BlkioWeightDevice&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;BlkioDeviceReadBps&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;BlkioDeviceWriteBps&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;BlkioDeviceReadIOps&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;BlkioDeviceWriteIOps&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;CpuPeriod&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CpuQuota&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CpuRealtimePeriod&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CpuRealtimeRuntime&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CpusetCpus&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;CpusetMems&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Devices&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;DeviceCgroupRules&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;DeviceRequests&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;KernelMemory&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;KernelMemoryTCP&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;MemoryReservation&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;MemorySwap&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;MemorySwappiness&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;OomKillDisable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;PidsLimit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;Ulimits&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;CpuCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;CpuPercent&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;IOMaximumIOps&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;IOMaximumBandwidth&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;MaskedPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/asound&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/acpi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/kcore&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/keys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/latency_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_list&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sched_debug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/scsi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/sys/firmware&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;ReadonlyPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/bus&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/fs&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/irq&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sysrq-trigger&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/d76624dcc42355cece3b8a39ba99dcf0b1714c80f5c28fc7ff80cf778a635932-init/diff:/var/lib/docker/overlay2/d5c1df794c28e4c26a5118b7df6f110d8cd67fd4b2184e3f0509513bde2686ac/diff&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/d76624dcc42355cece3b8a39ba99dcf0b1714c80f5c28fc7ff80cf778a635932/merged&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/d76624dcc42355cece3b8a39ba99dcf0b1714c80f5c28fc7ff80cf778a635932/diff&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/d76624dcc42355cece3b8a39ba99dcf0b1714c80f5c28fc7ff80cf778a635932/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Mounts&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;Config&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Hostname&quot;</span>: <span class="string">&quot;7194f420dccf&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;Env&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;while true;do echo hello,world;sleep 1;done&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Image&quot;</span>: <span class="string">&quot;centos&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Volumes&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Entrypoint&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;OnBuild&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;NetworkSettings&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Bridge&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;SandboxID&quot;</span>: <span class="string">&quot;ea030739e7cabd90101a0040969de447c6ba176267e502f5a5558b19f2a4d813&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;HairpinMode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;LinkLocalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;Ports&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;SandboxKey&quot;</span>: <span class="string">&quot;/var/run/docker/netns/ea030739e7ca&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;SecondaryIPAddresses&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;SecondaryIPv6Addresses&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;2cef83333f52c17f883782c62909d4878761bb98238aa45939039609e2d1ccfc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPPrefixLen&quot;</span>: <span class="number">16</span>,</span><br><span class="line">            <span class="attr">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Networks&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;bridge&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;IPAMConfig&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;Links&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;Aliases&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;NetworkID&quot;</span>: <span class="string">&quot;1cd4dcbb6871cbcce8292729579d2a62dee582c9b7cd3810298c1d69bc1de4cb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;2cef83333f52c17f883782c62909d4878761bb98238aa45939039609e2d1ccfc&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;IPPrefixLen&quot;</span>: <span class="number">16</span>,</span><br><span class="line">                    <span class="attr">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;DriverOpts&quot;</span>: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="4-5-进入当前正在运行的容器"><a href="#4-5-进入当前正在运行的容器" class="headerlink" title="4.5 进入当前正在运行的容器"></a>4.5 进入当前正在运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 进入当前正在运行的容器进行操作，不会启动新的进程</span></span><br><span class="line">docker attach 4db8b5f683c1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 进入当前正在运行的容器进行操作，会重新启动一个进程</span></span><br><span class="line">docker exec -it 4db8b5f683c1 /bin/bash</span><br></pre></td></tr></table></figure>

<p>虽然是不同的进程进行操作，但容器内的资源还是共享的。</p>
<p>首先使用docker exec -it 4db8b5f683c1 /bin/bash进入容器：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210102132444427.png" alt="image-docker attach"></p>
<p>然后使用docker attach 4db8b5f683c1进入容器:并没有启动一个新的/bin/bash进程。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210102132515791.png" alt="image-docker exec"></p>
<h4 id="4-6-从容器内拷贝文件到主机上"><a href="#4-6-从容器内拷贝文件到主机上" class="headerlink" title="4.6 从容器内拷贝文件到主机上"></a>4.6 从容器内拷贝文件到主机上</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 即使容器当前不在运行，也可以拷贝出文件</span></span><br><span class="line">docker cp 容器id:容器内路径  当前主机路径</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ming local]# docker cp 4db8b5f683c1:/aaa.txt /home/  # 将容器内/aaa.txt 拷贝到当前主机 /home/ 目录下</span><br><span class="line">[root@ming local]# ls /home</span><br><span class="line">aaa.txt</span><br></pre></td></tr></table></figure>



<h3 id="5-命令小结"><a href="#5-命令小结" class="headerlink" title="5.命令小结"></a>5.命令小结</h3><p><img src="https://upload-images.jianshu.io/upload_images/12842279-f5d4c22882f4a649.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="docker命令图谱"></p>
<h3 id="6-小实战"><a href="#6-小实战" class="headerlink" title="6. 小实战"></a>6. 小实战</h3><h4 id="6-1-部署nginx"><a href="#6-1-部署nginx" class="headerlink" title="6.1 部署nginx"></a>6.1 部署nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 下载nginx</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看镜像</span></span><br><span class="line">[root@ming ~]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">nginx        latest    ae2feff98a0c   2 weeks ago   133MB</span><br><span class="line">centos       latest    300e315adb2f   3 weeks ago   209MB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动容器，将主机的3344端口映射到容器内的80端口</span></span><br><span class="line">[root@ming ~]# docker run -p 3344:80 -it nginx  /bin/bash</span><br><span class="line">root@6b29c7751037:/# </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.查看nginx安装目录，版本信息</span></span><br><span class="line">root@6b29c7751037:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@6b29c7751037:/# cd /usr/sbin</span><br><span class="line">root@6b29c7751037:/usr/sbin# ./nginx -version</span><br><span class="line">nginx version: nginx/1.19.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.启动nginx</span></span><br><span class="line">root@6b29c7751037:/usr/sbin# ./nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外网访问<a href="">http://47.96.224.198:3344/</a>，容器内启动nginx成功。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210102143249340.png" alt="image-docker部署nginx"></p>
<h4 id="6-2-部署tomcat"><a href="#6-2-部署tomcat" class="headerlink" title="6.2 部署tomcat"></a>6.2 部署tomcat</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看镜像</span></span><br><span class="line">[root@ming ~]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">tomcat       latest    feba8d001e3f   2 weeks ago   649MB</span><br><span class="line">nginx        latest    ae2feff98a0c   2 weeks ago   133MB</span><br><span class="line">centos       latest    300e315adb2f   3 weeks ago   209MB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 启动容器，将主机的3355端口映射到容器内的80端口</span></span><br><span class="line">[root@ming ~]# docker run -p 3355:8080 -it tomcat /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动tomcat</span></span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat/bin# ./startup.sh </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 查看进程，tomcat已经启动</span></span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat/bin# ps -ef|grep tomcat</span><br><span class="line">root        15     1  1 07:45 pts/0    00:00:02 /usr/local/openjdk-11/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root        45     1  0 07:47 pts/0    00:00:00 grep tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外网访问<a href="">http://47.96.224.198:3355/</a>,出现以下界面：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210102154829545.png" alt="image-访问tomcat"></p>
<p>这是因为阿里云镜像默认是下载最小的镜像，只下载了必要的组件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# ls  </span><br><span class="line">BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# ls webapps  # webapps目录是空的</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# ls webapps.dist/   # webapps.dist目录才是原本的webapps目录</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# mv webapps webapps.backup</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# mv webapps.dist webapps  # 将webapps.dist目录改成webapps目录</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.backup</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work</span><br><span class="line">root@5e2e3cb50a29:/usr/local/tomcat# ls webapps</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次访问[<a href="">http://47.96.224.198:3355/</a>,这次就可以正常访问了。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20210102193605035.png" alt="image-访问docker中的tomcat"></p>
<h3 id="7-提交镜像"><a href="#7-提交镜像" class="headerlink" title="7.提交镜像"></a>7.提交镜像</h3><p>从仓库下载下来的镜像都是只读的，每当我们操作镜像，就会在原来镜像的上面加一层我们自己的操作，我们可以将它保存起来，下次直接使用我们操作过的镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看镜像</span></span><br><span class="line">[root@ming /]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS       PORTS                    NAMES</span><br><span class="line">89b24a4b7084   tomcat    &quot;/bin/bash&quot;   4 hours ago   Up 4 hours   0.0.0.0:3366-&gt;8080/tcp   infallible_lewin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将我们操作过的镜像commit成mytomcat</span></span><br><span class="line">[root@ming /]# docker commit -m &#x27;tomcat add webapps&#x27; -a &#x27;xiaoming&#x27; 89b24a4b7084 mytomcat</span><br><span class="line">sha256:42d7b6dea11ce283033c6015765bff176ffbdad71105c02048e4e7352a5239f4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看镜像</span></span><br><span class="line">[root@ming /]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">mytomcat     latest    42d7b6dea11c   10 seconds ago   654MB  # 我们自己生成的镜像</span><br><span class="line">tomcat       latest    feba8d001e3f   2 weeks ago      649MB</span><br><span class="line">nginx        latest    ae2feff98a0c   2 weeks ago      133MB</span><br><span class="line">centos       latest    300e315adb2f   3 weeks ago      209MB</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将镜像89b24a4b7084提交，生成我们自己的镜像mytomcat</span></span><br><span class="line">docker commit -m &#x27;tomcat add webapps&#x27; -a &#x27;xiaoming&#x27; 89b24a4b7084 mytomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">-m  # 提交的信息,类似于git commit</span><br><span class="line">-a  # 作者</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-容器数据卷"><a href="#8-容器数据卷" class="headerlink" title="8.容器数据卷"></a>8.容器数据卷</h3><p>我们在容器内操作，数据保存在容器内，这是一件很<code>危险</code>的事情，假如不小心删除了容器，容器内的数据就全部丢失了。</p>
<p>有没有一种技术可以将容器内的数据同步到宿主机器上，将容器内的目录和宿主机的目录进行绑定，无论修改容器内的目录，还是修改宿主机的目录，都能自动同步数据，完成数据的持久化呢？ 这就是数据卷的技术。</p>
<p>使用以下命令完成数据卷的挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v 宿主机的目录:容器内的目录</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 进入容器，进行目录挂载</span></span><br><span class="line">docker run -p 3355:8080 -v /home/test/:/home -it mytomcat /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看镜像状态，查看挂载信息</span></span><br><span class="line">docker inspect 7feb5a932a8b</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/home/test&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 进入到容器内,/home目录下创建文件test.java</span></span><br><span class="line">root@7feb5a932a8b:/home# ls</span><br><span class="line">test.java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 查看宿主机器/home/<span class="built_in">test</span>目录下是否同步了test.java文件</span></span><br><span class="line">[root@ming test]# pwd</span><br><span class="line">/home/test</span><br><span class="line">[root@ming test]# ls</span><br><span class="line">test.java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.在宿主机上修改test.java文件，修改其内容</span></span><br><span class="line">[root@ming test]# vim test.java </span><br><span class="line">[root@ming test]# cat test.java </span><br><span class="line">hello,world</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.查看容器中/home目录下的test.java文件</span></span><br><span class="line">root@7feb5a932a8b:/home# cat test.java </span><br><span class="line">hello,world</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：使用数据卷技术，可以将容器内的目录和宿主机器上的目录进行同步，从而达到数据持久化的目的。</span></span><br></pre></td></tr></table></figure>



<h4 id="8-1-部署mysql"><a href="#8-1-部署mysql" class="headerlink" title="8.1 部署mysql"></a>8.1 部署mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 直接使用docker run 下载mysql，如果本地不存在mysql的镜像，会从远程仓库中拉取</span></span><br><span class="line">docker run -p 3307:3306 -v /home/mysql/data:/var/lib/mysql -v /home/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql5.7 mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">-e  # 设置环境</span><br><span class="line">MYSQL_ROOT_PASSWORD # mysql root用户的密码</span><br><span class="line">--name  # 容器的名称</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.使用navicat连接数据库，并创建数据库<span class="built_in">test</span></span></span><br><span class="line">host:47.96.224.198:3307 </span><br><span class="line">username:root</span><br><span class="line">password:123456</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看宿主机上/home/mysql/data目录下有没有<span class="built_in">test</span>数据库</span></span><br><span class="line">[root@ming data]# pwd</span><br><span class="line">/home/mysql/data</span><br><span class="line">[root@ming data]# ll |grep test</span><br><span class="line">drwxr-x--- 2 systemd-bus-proxy input     4096 Jan  2 20:14 test  # test数据库,说明容器内的目录和宿主机的目录已经同步</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 删除容器</span></span><br><span class="line">docker rm -f a312a3e56f40 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.数据持久化了，即使删除容器，数据也不会丢失</span></span><br><span class="line">[root@ming data]# ll | grep test</span><br><span class="line">drwxr-x--- 2 systemd-bus-proxy input     4096 Jan  2 20:14 test</span><br></pre></td></tr></table></figure>



<h4 id="8-2-具名挂载和匿名挂载"><a href="#8-2-具名挂载和匿名挂载" class="headerlink" title="8.2 具名挂载和匿名挂载"></a>8.2 具名挂载和匿名挂载</h4><p>之前使用的<code>docker run -v 宿主机的目录:容器内的目录</code>是指定目录的挂载方式。</p>
<p>除此之外，还有具名挂载和匿名挂载。</p>
<blockquote>
<p>具名挂载</p>
</blockquote>
<p>具名挂载通过<code>docker run -v 卷名：容器内的目录</code>进行挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 具名挂载的方式启动nginx</span></span><br><span class="line">docker run -d -p 3344:80 -v juming_nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看数据卷</span></span><br><span class="line">[root@ming /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     juming_nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看juming_nginx的详细信息</span></span><br><span class="line">[root@ming /]# docker volume inspect juming_nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-01-02T20:37:12+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming_nginx/_data&quot;,  # 挂载的路径</span><br><span class="line">        &quot;Name&quot;: &quot;juming_nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 到挂载的路径下查看，nginx的配置文件目录已经挂载到了/var/lib/docker/volumes/juming_nginx/_data目录下</span></span><br><span class="line">[root@ming _data]# pwd</span><br><span class="line">/var/lib/docker/volumes/juming_nginx/_data</span><br><span class="line">[root@ming _data]# ls</span><br><span class="line">conf.d          koi-utf  mime.types  nginx.conf   uwsgi_params</span><br><span class="line">fastcgi_params  koi-win  modules     scgi_params  win-utf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>匿名挂载</p>
</blockquote>
<p>匿名挂载通过<code>docker run -v 容器内路径</code>进行挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 匿名挂载的方式启动nginx</span></span><br><span class="line">docker run -d -p 3344:80 -v /etc/nginx.conf nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看数据卷,是一串字符串</span></span><br><span class="line">[root@ming _data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     ffb564010a743ee8d607d1fd35bdf54fbef705881cf9c2625c431e83f626c532</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看挂载的详细信息</span></span><br><span class="line">[root@ming _data]# docker volume inspect ffb564010a743ee8d607d1fd35bdf54fbef705881cf9c2625c431e83f626c532</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-01-02T20:42:50+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/ffb564010a743ee8d607d1fd35bdf54fbef705881cf9c2625c431e83f626c532/_data&quot;,  # 挂载的目录</span><br><span class="line">        &quot;Name&quot;: &quot;ffb564010a743ee8d607d1fd35bdf54fbef705881cf9c2625c431e83f626c532&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.到挂载的目录查看，发现目录是空的</span></span><br><span class="line">[root@ming _data]# pwd</span><br><span class="line">/var/lib/docker/volumes/2909b1711dfe40c72036dc8d950d2da653a6b88563acbb0b1e49932469e1247d/_data</span><br><span class="line">[root@ming _data]# ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现，如果不是以指定目录的方式进行挂载，挂载的目录默认是在<code>/var/lib/docker/volumes/卷名/_data/</code>目录下。</p>
<h4 id="8-3-权限"><a href="#8-3-权限" class="headerlink" title="8.3 权限"></a>8.3 权限</h4><p>相对于容器内而言，默认情况下，文件是可读可写的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 启动nginx容器并进入容器</span></span><br><span class="line">docker run -p 3344:80 -v juming_nginx:/etc/nginx.conf -it nginx /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 到/etc/目录下，查看nginx.conf的权限</span></span><br><span class="line">drwxr-xr-x 3 root root    4096 Jan  2 12:37 nginx.conf  # 可读可写的权限</span><br></pre></td></tr></table></figure>

<p>我们可以在启动容器的时候，指定容器内的文件权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. ro = <span class="built_in">read</span> only ,在容器内只读，不能修改</span></span><br><span class="line">docker run -p 3344:80 -v juming_nginx:/etc/nginx.conf:ro -it nginx /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. rw = <span class="built_in">read</span> write,在容器内可读，可写</span></span><br><span class="line">docker run -p 3344:80 -v juming_nginx:/etc/nginx.conf:ro -it nginx /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="8-4-多个容器挂载同一个目录"><a href="#8-4-多个容器挂载同一个目录" class="headerlink" title="8.4 多个容器挂载同一个目录"></a>8.4 多个容器挂载同一个目录</h4><p>使用–volume-for指定一个容器，同步这个容器的数据。就相当于，继承一个容器，自动同步它的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 启动容器centos1,挂载容器内的目录/home/centos1</span></span><br><span class="line">docker run -it --name centos1 -v centos1:/home/centos1/ centos /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在centos1容器的/home/centos1目录下创建centos1.txt文件</span></span><br><span class="line">[root@69a8809a9e6f centos1]# pwd</span><br><span class="line">/home/centos1</span><br><span class="line">[root@69a8809a9e6f centos1]# ls</span><br><span class="line">centos1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看宿主机上centos1的挂载目录</span></span><br><span class="line">[root@ming _data]# pwd</span><br><span class="line">/var/lib/docker/volumes/centos1/_data</span><br><span class="line">[root@ming _data]# ls</span><br><span class="line">centos1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动容器centos2，centos2继承自centos1</span></span><br><span class="line">docker run -it --name centos2 --volumes-from centos1 centos /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 进入到centos2的/home/centos1目录下</span></span><br><span class="line">[root@a5afec9346bd centos1]# pwd</span><br><span class="line">/home/centos1</span><br><span class="line">[root@a5afec9346bd centos1]# ls</span><br><span class="line">centos1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在centos2的目录下，可以看到centos1的目录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. centos2容器中,在centos1目录中创建centos2.txt</span></span><br><span class="line">[root@a5afec9346bd centos2]# pwd</span><br><span class="line">/home/centos1</span><br><span class="line">[root@a5afec9346bd centos2]# ls</span><br><span class="line">centos1.txt centos2.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 进入到centos1容器中，查看/home/centos1目录下是否多了centos2.txt</span></span><br><span class="line">[root@06e27ea51ee0 centos1]# ls  # centos1的目录下,存在centos2.txt，说明centos2创建的文件自动同步到centos1</span><br><span class="line">centos1.txt centos2.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 查看centos2的挂载目录</span></span><br><span class="line">docker inspect centos2</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;centos1&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/centos1/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home/centos1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 查看centos1的挂载目录</span></span><br><span class="line">docker inspect centos1</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;centos1&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/centos1/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home/centos1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：centos1和centos2挂载的是同一个目录，连name都是相同的centos1。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这意味着，我们查看centos2的详细数据卷信息，也是使用docker volume inspect centos1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们创建一个新的容器centos3，让它–volumes-from centos2,它能不能自动同步centos2创建的目录centos2呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 启动centos3容器</span></span><br><span class="line">docker run -it --name centos3 --volumes-from centos2 centos /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看/home目录下是否存在centos2目录</span></span><br><span class="line">[root@96b772d61de0 home]# ls  # 说明centos3不能同步centos2创建的目录</span><br><span class="line">centos1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看centos3挂载的目录信息</span></span><br><span class="line">docker inspect centos3</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;centos1&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/centos1/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home/centos1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos3虽然继承自centos2，但是centos2是继承自centos1，挂载的只是centos1的目录，所以centos3不能同步centos2创建的目录。</span></span><br></pre></td></tr></table></figure>



<h3 id="9-Dockfile"><a href="#9-Dockfile" class="headerlink" title="9.Dockfile"></a>9.Dockfile</h3><p>Dockfile是面向开发的，我们以后要发布项目，就需要编写dockfile文件。</p>
<h4 id="9-1-制作一个Dockefile"><a href="#9-1-制作一个Dockefile" class="headerlink" title="9.1 制作一个Dockefile"></a>9.1 制作一个Dockefile</h4><p>dockerfile就是一个脚本文件，里面的脚本用来创建镜像。</p>
<p>新建一个目录/home/docker_volume_test，创建dockerfile1的脚本文件。</p>
<p>需要注意的几点：</p>
<ul>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行从上到下顺序执行</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交</li>
<li>必须使用双引号，单引号不行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">VOLUME [&quot;volume1&quot;,&quot;volume2&quot;]</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>写好脚本文件后，使用<code>docker build</code>命令生成镜像。</p>
<p>需要注意的有2点：</p>
<ul>
<li>-t 生成的镜像名称不能带/</li>
<li>最后一个参数指定生成路径，.代表当前目录</li>
<li>如果文件命名为Dockerfile，在docker build的时候可以不指定-f参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 利用当前目录下的dockerfile文件在当前目录下生成xiaoming/centos的镜像</span></span><br><span class="line">[root@ming docker_volume_test]# docker build -f dockerfile1 -t xiaoming/centos .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 300e315adb2f</span></span><br><span class="line">Step 2/4 : VOLUME [&quot;volume1&quot;,&quot;volume2&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 7d9097ed198e</span></span><br><span class="line">Removing intermediate container 7d9097ed198e</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 8f3d72c8bccc</span></span><br><span class="line">Step 3/4 : CMD echo &#x27;------end------&#x27;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 27f56b2fe602</span></span><br><span class="line">Removing intermediate container 27f56b2fe602</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> bdcf8bb3ee27</span></span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> e9c64f298af8</span></span><br><span class="line">Removing intermediate container e9c64f298af8</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7fc575cbe035</span></span><br><span class="line">Successfully built 7fc575cbe035</span><br><span class="line">Successfully tagged xiaoming/centos:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">-f # 指定的dockfile文件</span><br><span class="line">-t # target,生成的目录镜像</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看镜像</span></span><br><span class="line">[root@ming docker_volume_test]# docker images</span><br><span class="line">REPOSITORY        TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">xiaoming/centos   latest    7fc575cbe035   21 seconds ago   209MB  # 利用dockerfile生成的镜像文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动容器</span></span><br><span class="line">[root@ming docker_volume_test]# docker run -it xiaoming/centos /bin/bash</span><br><span class="line">[root@40476da59260 /]# ls -l</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan  3 07:14 volume1 # 生成镜像的时候自动挂载的volume1目录</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan  3 07:14 volume2 # 生成镜像的时候自动挂载的volume2目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 在容器内的volume1目录中创建文件volume1.txt</span></span><br><span class="line">[root@40476da59260 volume1]# pwd</span><br><span class="line">/volume1</span><br><span class="line">[root@40476da59260 volume1]# ls</span><br><span class="line">volume1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看挂载信息</span></span><br><span class="line">docker inspect 40476da59260  # 容器id</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;188f9cd826889b4497db0df774a3c493666b808bce0cffbadc90ae20901fda49&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/188f9cd826889b4497db0df774a3c493666b808bce0cffbadc90ae20901fda49/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;volume1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;9ecc05996ab6035f6fee907b130473f8ad9eba1244635a98bbf3e5dbde8747a8&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/9ecc05996ab6035f6fee907b130473f8ad9eba1244635a98bbf3e5dbde8747a8/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;volume2&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 到挂载目录下查看是否同步了容器的文件</span></span><br><span class="line">[root@ming _data]# pwd</span><br><span class="line">/var/lib/docker/volumes/188f9cd826889b4497db0df774a3c493666b808bce0cffbadc90ae20901fda49/_data</span><br><span class="line">[root@ming _data]# ls</span><br><span class="line">volume1.txt  # 容器内创建的文件已经同步，说明挂载成功。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="9-2-Dockfile指令"><a href="#9-2-Dockfile指令" class="headerlink" title="9.2 Dockfile指令"></a>9.2 Dockfile指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像，一切从这里开始构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定维护者信息（姓名+邮箱）</td>
</tr>
<tr>
<td>RUN</td>
<td>镜像构建的时候需要运行的命令</td>
</tr>
<tr>
<td>ADD</td>
<td>添加内容，会自动解压</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>镜像的工作目录</td>
</tr>
<tr>
<td>VOLUME</td>
<td>设置卷，挂载主机目录</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口配置</td>
</tr>
<tr>
<td>CMD</td>
<td>指定容器启动的时候运行的命令，只有最后一个会生效</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定这个容器启动的时候运行的命令，可以追加命令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当构建一个被继承Dockfile就会触发指令</td>
</tr>
<tr>
<td>COPY</td>
<td>类似ADD,将文件拷贝到镜像中</td>
</tr>
<tr>
<td>ENV</td>
<td>构建的时候设置环境变量</td>
</tr>
</tbody></table>
<h4 id="9-3-CMD与ENTRYPOINT的区别"><a href="#9-3-CMD与ENTRYPOINT的区别" class="headerlink" title="9.3 CMD与ENTRYPOINT的区别"></a>9.3 CMD与ENTRYPOINT的区别</h4><p>我们编写一个Dockerfile文件，创建添加了vim的centos：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基于centos镜像构建</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 维护者</span></span><br><span class="line">MAINTAINER &quot;ming&lt;11498895@qq.com&gt;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像，也就是执行docker build的时候，下载vim命令</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置工作目录，容器启动的时候就在这个工作目录下</span></span><br><span class="line">ENV MAINDIR /home</span><br><span class="line">WORKDIR $MAINDIR</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器时，执行的命令</span></span><br><span class="line">CMD [&quot;ls&quot;,&quot;-l&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行docker build 生成镜像</span></span><br><span class="line">docker build -f centos_dockfile -t centos:0.1 .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里我们指定了生成镜像的版本号，在启动的时候，也需要指定镜像的版本号才能启动</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 启动容器，注意这里不指定使用/bin/bash启动，才会执行dockerfile中的cmd命令</span></span><br><span class="line">[root@ming docker_volume_test]# docker run centos:0.1</span><br><span class="line">total 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器启动的时候执行了ls -l命令</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 做个测试，在启动容器的时候使其执行ls -l /命令</span></span><br><span class="line">[root@ming docker_volume_test]# docker run centos:0.1 /</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: &quot;/&quot;: permission denied: unknown.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时候，产生了一个错误，这是由于docker run时指定的/命令替换了dockfile中CMD指定指定的ls -l命令，而/命令不是一个正确的命令，就报错了</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们在dockerfile文件中使用ENTRYPOINT指令替换CMD指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER &quot;ming&lt;11498895@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MAINDIR /home</span><br><span class="line">WORKDIR $MAINDIR</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-l&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 我们直接启动容器，执行的是ls -l 命令</span></span><br><span class="line">[root@ming docker_volume_test]# docker run centos:0.1</span><br><span class="line">total 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 我们在启动容器的时候追加命令，使其执行ls -l /命令</span></span><br><span class="line">[root@ming docker_volume_test]# docker run centos:0.1 /</span><br><span class="line">total 48</span><br><span class="line">lrwxrwxrwx  1 root root    7 Nov  3 15:22 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x  5 root root  340 Jan  3 09:57 dev</span><br><span class="line">drwxr-xr-x  1 root root 4096 Jan  3 09:57 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov  3 15:22 home</span><br><span class="line">lrwxrwxrwx  1 root root    7 Nov  3 15:22 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx  1 root root    9 Nov  3 15:22 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------  2 root root 4096 Dec  4 17:37 lost+found</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov  3 15:22 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov  3 15:22 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov  3 15:22 opt</span><br><span class="line">dr-xr-xr-x 90 root root    0 Jan  3 09:57 proc</span><br><span class="line">dr-xr-x---  1 root root 4096 Jan  3 09:55 root</span><br><span class="line">drwxr-xr-x 11 root root 4096 Dec  4 17:37 run</span><br><span class="line">lrwxrwxrwx  1 root root    8 Nov  3 15:22 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov  3 15:22 srv</span><br><span class="line">dr-xr-xr-x 13 root root    0 Jan  3 09:57 sys</span><br><span class="line">drwxrwxrwt  7 root root 4096 Dec  4 17:37 tmp</span><br><span class="line">drwxr-xr-x  1 root root 4096 Dec  4 17:37 usr</span><br><span class="line">drwxr-xr-x  1 root root 4096 Dec  4 17:37 var</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：如果使用ENTRYPOINT,我们在docker run时指定的命令是会追加到原来命令的后面的</span></span><br></pre></td></tr></table></figure>



<h4 id="9-4-查看构建过程"><a href="#9-4-查看构建过程" class="headerlink" title="9.4 查看构建过程"></a>9.4 查看构建过程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 使用docker <span class="built_in">history</span> 镜像id  可以查看一个镜像构建的过程</span></span><br><span class="line">[root@ming ~]# docker history 7e97f5b8161a</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">7e97f5b8161a   3 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;sh /…   0B        </span><br><span class="line">4744060107e4   3 minutes ago   /bin/sh -c #(nop)  EXPOSE 8080                  0B        </span><br><span class="line">cd04af7c483b   3 minutes ago   /bin/sh -c #(nop) WORKDIR /usr/local/tomcat     0B        </span><br><span class="line">c7b335498d11   3 minutes ago   /bin/sh -c #(nop)  ENV MAINPATH=/usr/local/t…   0B        </span><br><span class="line">d07929bdbbaa   3 minutes ago   /bin/sh -c #(nop)  ENV PATH=/usr/local/sbin:…   0B        </span><br><span class="line">f3fc451eee02   3 minutes ago   /bin/sh -c #(nop)  ENV CATALINA_BASH=/usr/lo…   0B        </span><br><span class="line">3498f6fce614   3 minutes ago   /bin/sh -c #(nop)  ENV CATALINA_HOME=/usr/lo…   0B        </span><br><span class="line">978f9d791d9c   3 minutes ago   /bin/sh -c #(nop)  ENV CLASSPATH=.:/usr/loca…   0B        </span><br><span class="line">92e9bc253a9e   3 minutes ago   /bin/sh -c #(nop)  ENV JAVA_HOME=/usr/local/…   0B        </span><br><span class="line">8773f4df5b08   3 minutes ago   /bin/sh -c cd /usr/local/java &amp;&amp; yum -y inst…   349MB     </span><br><span class="line">90e3f7678077   4 minutes ago   /bin/sh -c #(nop) ADD file:a1bfef71355927262…   113MB     </span><br><span class="line">f4149d27d5d7   4 minutes ago   /bin/sh -c #(nop) ADD file:f10b183415fb392e3…   14.6MB    </span><br><span class="line">256d743023b7   4 minutes ago   /bin/sh -c yum -y install rpm                   1.83MB    </span><br><span class="line">1bbdc376780a   4 minutes ago   /bin/sh -c yum -y install vim                   58MB      </span><br><span class="line">c1b496dc6b45   5 minutes ago   /bin/sh -c #(nop)  MAINTAINER xiaoming&lt;11498…   0B        </span><br><span class="line">300e315adb2f   3 weeks ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      3 weeks ago     /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        </span><br><span class="line">&lt;missing&gt;      3 weeks ago     /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7…   209MB </span><br></pre></td></tr></table></figure>



<h4 id="9-5-制作tomcat的Dockfile"><a href="#9-5-制作tomcat的Dockfile" class="headerlink" title="9.5 制作tomcat的Dockfile"></a>9.5 制作tomcat的Dockfile</h4><blockquote>
<p>准备tomcat，JDK的压缩包,编写Dockerfile</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基于centos</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 作者信息</span></span><br><span class="line">MAINTAINER xiaoming&lt;1149895826@qq.com&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载vim</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下的压缩包发送到服务器，ADD指令会自动解压</span></span><br><span class="line">ADD apache-tomcat-8.5.61.tar.gz /usr/local/tomcat/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下的JDK rpm包发送到服务器</span></span><br><span class="line">ADD jdk-8u271-linux-x64.rpm /usr/local/java/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载rpm包，安装JDK</span></span><br><span class="line">RUN cd /usr/local/java &amp;&amp; yum -y install /usr/local/java/jdk-8u271-linux-x64.rpm &amp;&amp; yum install which -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量,这里非常重要，稍微有一点错误，容器就启动不起来</span></span><br><span class="line">ENV JAVA_HOME /usr/java/jdk1.8.0_271-amd64</span><br><span class="line">ENV CLASSPATH .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/tomcat/apache-tomcat-8.5.61</span><br><span class="line">ENV CATALINA_BASH /usr/local/tomcat/apache-tomcat-8.5.61</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器启动时的工作目录</span></span><br><span class="line">ENV MAINPATH /usr/local/tomcat</span><br><span class="line">WORKDIR $MAINPATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暴露容器的端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器启动时执行的命令：启动tomcat，并打印启动日志</span></span><br><span class="line">CMD sh /usr/local/tomcat/apache-tomcat-8.5.61/bin/startup.sh &amp;&amp; tail -f /usr/local/tomcat/apache-tomcat-8.5.61/logs/catalina.out</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker build 生成镜像文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 由于文件命名是Dockerfile,无需指定-f参数</span></span><br><span class="line">docker build -t diy_tomcat .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 后台启动容器,将tomcat的webapps和日志目录挂载到宿主机,启动后自动打印启动日志</span></span><br><span class="line">[root@ming diy_tomcat]# docker run -p 3344:8080 -v /home/diy_tomcat/webapps/:/usr/local/tomcat/apache-tomcat-8.5.61/webapps/ -v /home/diy_tomcat/logs/:/usr/local/tomcat/apache-tomcat-8.5.61/logs/ diy_tomcat </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 查看容器,容器正在运行</span></span><br><span class="line">[root@ming diy_tomcat]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND                  CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">3134796152c3   diy_tomcat   &quot;/bin/sh -c &#x27;sh /usr…&quot;   About a minute ago   Up About a minute   0.0.0.0:3344-&gt;8080/tcp   heuristic_kare</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.外网访问http://47.96.224.198:3344/,访问正常</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看宿主机挂载的目录是否挂载成功</span></span><br><span class="line">[root@ming webapps]# pwd</span><br><span class="line">/home/diy_tomcat/webapps</span><br><span class="line">[root@ming webapps]# ls</span><br><span class="line">balance  dev  docs  examples  host-manager  manager  ROOT</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以后，我们只需要将项目部署在宿主机的webapps目录下就可以啦</span></span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;1&quot;&gt;/proc/sys/vm/drop_caches</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-发布自己的镜像"><a href="#10-发布自己的镜像" class="headerlink" title="10.发布自己的镜像"></a>10.发布自己的镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 首先需要创建DockerHub的账号</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在命令行中先登录账户</span></span><br><span class="line">[root@ming ~]# docker login -u jinming8</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 将要发布的镜像tag成 用户名/镜像名，这一步至关重要</span></span><br><span class="line">[root@ming ~]# docker tag nginx jinming8/nginx:0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 执行push命令，发布到Dockhub</span></span><br><span class="line">[root@ming ~]# docker push jinming8/nginx:0.1</span><br><span class="line">The push refers to repository [docker.io/jinming8/nginx]</span><br><span class="line">4eaf0ea085df: Mounted from library/nginx </span><br><span class="line">2c7498eef94a: Mounted from library/nginx </span><br><span class="line">7d2b207c2679: Mounted from library/nginx </span><br><span class="line">5c4e5adc71a8: Mounted from library/nginx </span><br><span class="line">87c8a1d8f54f: Mounted from library/mysql </span><br><span class="line">0.1: digest: sha256:13e4551010728646aa7e1b1ac5313e04cf75d051fa441396832fcd6d600b5e71 size: 1362   # 发布成功</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 退出登录</span></span><br><span class="line">[root@ming ~]# docker logout</span><br><span class="line">Removing login credentials for https://index.docker.io/v1/</span><br></pre></td></tr></table></figure>



<h3 id="11-Docker网络"><a href="#11-Docker网络" class="headerlink" title="11. Docker网络"></a>11. Docker网络</h3><h4 id="11-1-问题1：宿主机和容器能不能ping通？-✔"><a href="#11-1-问题1：宿主机和容器能不能ping通？-✔" class="headerlink" title="11.1 问题1：宿主机和容器能不能ping通？  ✔"></a>11.1 问题1：宿主机和容器能不能ping通？  ✔</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看宿主机器的ip addr</span></span><br><span class="line">[root@ming ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3f:00:fd:98 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.47.149/20 brd 172.16.47.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 314901004sec preferred_lft 314901004sec</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN </span><br><span class="line">    link/ether 02:42:e7:4f:27:e0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宿主机器上有3个网卡：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. lo:本地回环地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. eth0:阿里云内网，ip=172.16.47.149</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. docker0:docker的网卡，只要我们安装了docker就会有这个网卡</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 启动一个tomcat容器</span></span><br><span class="line">[root@ming ~]# docker run -it --name tomcat1  tomcat /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 进入容器内查看ip</span></span><br><span class="line">root@1826a8cb702d:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">332: eth0@if333: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内有2个网卡：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. lo:本地回环地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 332: eth0@if333:docker为容器分配的网卡，ip=172.17.0.2</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 在容器内ping宿主机器的ip 172.16.47.149</span></span><br><span class="line">root@1826a8cb702d:/usr/local/tomcat# ping 172.16.47.149</span><br><span class="line">PING 172.16.47.149 (172.16.47.149) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.16.47.149: icmp_seq=1 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 172.16.47.149: icmp_seq=2 ttl=64 time=0.075 ms</span><br><span class="line">64 bytes from 172.16.47.149: icmp_seq=3 ttl=64 time=0.077 ms</span><br><span class="line">64 bytes from 172.16.47.149: icmp_seq=4 ttl=64 time=0.077 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论1：在容器内是可以ping通宿主机器地址的</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. CTRL+P+Q退出容器，在宿主机查看ip addr</span></span><br><span class="line">[root@ming ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3f:00:fd:98 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.47.149/20 brd 172.16.47.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 314900722sec preferred_lft 314900722sec</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 02:42:e7:4f:27:e0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">333: veth740bb55@if332: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP </span><br><span class="line">    link/ether 06:b3:9f:71:29:93 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相比与启动容器tomcat之前，宿主机多了一个网卡333: veth740bb55@if332，而且我们发现，它与容器的内的网卡332: eth0@if333形成了一对。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 在宿主机内ping容器地址172.17.0.2</span></span><br><span class="line">[root@ming ~]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.084 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论2:宿主机是可以ping通容器内的ip的</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>安装了docker之后，会默认分配一个网卡docker0</li>
<li>我们每启动一个容器，docker就会给容器分配一个ip，使用的是桥接模式，veth-pair技术(一对虚拟设备接口，在这里，一端连着容器，一端连着docker0)</li>
</ul>
<h4 id="11-2-问题2：两个容器直接能否直接ping通？-✔"><a href="#11-2-问题2：两个容器直接能否直接ping通？-✔" class="headerlink" title="11.2 问题2：两个容器直接能否直接ping通？ ✔"></a>11.2 问题2：两个容器直接能否直接ping通？ ✔</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.再次启动一个容器tomcat2，查看ip地址</span></span><br><span class="line">[root@ming ~]# docker run -it --name=tomcat2 tomcat /bin/bash</span><br><span class="line">root@9d1e83b5c4d6:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">334: eth0@if335: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内也是有2个网卡，一个本机回环地址，一个docker分配的网卡，tomcat2的ip=172.17.0.3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. tomcat2 能否ping通 tomcat1 ？</span> </span><br><span class="line">root@9d1e83b5c4d6:/usr/local/tomcat# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.099 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.087 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.085 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.089 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果肯定是可以的，因为从ip地址可以看出，它们属于同一个网段。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 进入到tomcat1容器，ping tomcat2的ip</span></span><br><span class="line">[root@ming ~]# docker attach 1826a8cb702d</span><br><span class="line">root@1826a8cb702d:/usr/local/tomcat# ping 172.17.0.3</span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.075 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.090 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.085 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.089 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次验证。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：两个容器之间也是可以相互ping通的。虽然两个容器直接能ping通，但两个容器间却不是直接相连接的。它们通过veth-pair与docker0相连，docker0这个桥接起了作用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-3-能否通过容器的name来连接？-×-–link-✔"><a href="#11-3-能否通过容器的name来连接？-×-–link-✔" class="headerlink" title="11.3 能否通过容器的name来连接？ ×(–link ✔)"></a>11.3 能否通过容器的name来连接？ ×(–link ✔)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 进入到tomcat1容器，直接ping tomcat2容器的名字</span></span><br><span class="line">root@1826a8cb702d:/usr/local/tomcat# ping tomcat2</span><br><span class="line">ping: tomcat2: Name or service not known</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不能直接通过容器名称来连接</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 重新启动容器tomcat3，指定--link 连接tomcat2</span></span><br><span class="line">[root@ming ~]# docker run -it --name tomcat3 --link tomcat2 tomcat /bin/bash </span><br><span class="line">root@0ded9ce6d825:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">338: eth0@if339: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，这里tomcat3的ip=172.17.0.2，好像和tomcat1的ip相同，但是我这里是把tomcat1容器退出了的</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 在tomcat3容器内直接ping tomcat2</span></span><br><span class="line">root@0ded9ce6d825:/usr/local/tomcat# ping tomcat2</span><br><span class="line">PING tomcat2 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat2 (172.17.0.3): icmp_seq=1 ttl=64 time=0.094 ms</span><br><span class="line">64 bytes from tomcat2 (172.17.0.3): icmp_seq=2 ttl=64 time=0.084 ms</span><br><span class="line">64 bytes from tomcat2 (172.17.0.3): icmp_seq=3 ttl=64 time=0.085 ms</span><br><span class="line">64 bytes from tomcat2 (172.17.0.3): icmp_seq=4 ttl=64 time=0.084 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论1:在启动容器的时候，使用--link 参数指定容器，可以与指定的容器通过名称连接</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 进入容器tomcat2，ping tomcat3</span></span><br><span class="line">[root@ming ~]# docker attach 9d1e83b5c4d6</span><br><span class="line">root@9d1e83b5c4d6:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">334: eth0@if335: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">root@9d1e83b5c4d6:/usr/local/tomcat# ping tomcat3</span><br><span class="line">ping: tomcat3: Name or service not known</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论2:tomcat2是不能ping通tomcat3的，说明tomcat3容器启动的时候指定的--link参数是单向的。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 进入tomcat3容器，查看/etc/hosts文件</span></span><br><span class="line">[root@ming ~]# docker attach 0ded9ce6d825</span><br><span class="line">root@0ded9ce6d825:/usr/local/tomcat# cat /etc/hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.3	tomcat2 9d1e83b5c4d6</span><br><span class="line">172.17.0.2	0ded9ce6d825</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论3：我们惊奇的发现，所谓的tomcat3启动时指定的--link参数，只是修改了tomcat的hosts文件，当tomcat3访问tomcat2的时候，跳转到172.17.0.3(也就是tomcat的ip地址)</span></span><br></pre></td></tr></table></figure>

<p>虽然–link能使用容器名称来连接，但这种做法是过时的，更好的方法是使用自定义网络。</p>
<h4 id="11-4-自定义网络"><a href="#11-4-自定义网络" class="headerlink" title="11.4 自定义网络"></a>11.4 自定义网络</h4><blockquote>
<p>查看网络信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看网络信息</span></span><br><span class="line">[root@ming ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1cd4dcbb6871   bridge    bridge    local</span><br><span class="line">937119faf618   host      host      local</span><br><span class="line">5f780b566b6c   none      null      local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker有3种网络模式：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.bridge:桥接模式，docker默认的网络模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.host:与宿主机器共享网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.none:不使用网络</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看某个网络模式的详细信息</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;1cd4dcbb6871cbcce8292729579d2a62dee582c9b7cd3810298c1d69bc1de4cb&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-01-01T21:28:47.705629496+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,   # 桥接</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,  # 子网</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;     # 网关</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;0ded9ce6d825fac539ca1190591a162f9437a10a5b85a75f10c2631431748686&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat3&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;82d9154362a6a3e96e6ca9e52b550682a8eb7f79d99d19809116c6b44d67bd8f&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, # ip</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;9d1e83b5c4d6f1d1c569d7df4d24df17be392f9d72c33b4107ea4f8e1686bb16&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;354c25db100af0a53d982fd893a52fee7f5b4d8f533ce9901de24bf9c191dc93&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义一个网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建网络，指定网关和子网掩码</span></span><br><span class="line">[root@ming ~]# docker network create --gateway 192.168.0.1 --subnet 192.168.0.0/16 mynet </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看创建的网络</span></span><br><span class="line">[root@ming ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1cd4dcbb6871   bridge    bridge    local</span><br><span class="line">937119faf618   host      host      local</span><br><span class="line">805e98b29181   mynet     bridge    local</span><br><span class="line">5f780b566b6c   none      null      local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动容器的时候指定网络</span></span><br><span class="line">[root@ming ~]# docker run -it --name tomcat1 --net mynet tomcat /bin/bash</span><br><span class="line">root@a8d9dd3ce963:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">341: eth0@if342: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:c0:a8:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.0.2/16 brd 192.168.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 容器启动后的ip=192.168.0.2,是我们自定义的网络mynet</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 4. 查看mynet的详细信息</span></span><br><span class="line"> </span><br><span class="line">[root@ming ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;805e98b29181a303950c9f3267587e6ea27c2df3728a0723e4f16acb43add392&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-01-05T19:12:36.296644818+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, # 我们设置的子网</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;    # 我们设置的网关</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;  # 此网络内的容器信息</span><br><span class="line">            &quot;a8d9dd3ce9633968957a5d1487bbf85716985f97ed6cf4f2b9a78c47d2c3f67d&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;f1bbab5f9d330f62f17ef2076dd09d00a124d14d5ce8c3658d8e6459215c4e19&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,  # tomcat1容器的ip</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 启动容器tomcat2，查看ip，并通过容器名称连接tomcat1</span></span><br><span class="line">[root@ming ~]# docker run -it --name tomcat2 --net mynet tomcat /bin/bash</span><br><span class="line">root@bf9e41e968ae:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">343: eth0@if344: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:c0:a8:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.0.3/16 brd 192.168.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">root@bf9e41e968ae:/usr/local/tomcat# ping tomcat1</span><br><span class="line">PING tomcat1 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat1.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.101 ms</span><br><span class="line">64 bytes from tomcat1.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.083 ms</span><br><span class="line">64 bytes from tomcat1.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.098 ms</span><br><span class="line">64 bytes from tomcat1.mynet (192.168.0.2): icmp_seq=4 ttl=64 time=0.088 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论1:通过自定义网络是能通过容器名称进行连接的。</span></span><br></pre></td></tr></table></figure>

<h4 id="11-5-网络互联"><a href="#11-5-网络互联" class="headerlink" title="11.5 网络互联"></a>11.5 网络互联</h4><p>上面tomcat1和tomcat2已经连接在mynet网络下了，那么连接在docker0的容器，能否访问mynet网络下的容器呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 使用默认的docker0启动一个容器tomcat3</span></span><br><span class="line">[root@ming ~]# docker run -it --name tomcat3 tomcat /bin/bash</span><br><span class="line">root@bac489a3beb3:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">345: eth0@if346: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 使用tomcat3连接mynet网络下的tomcat2</span></span><br><span class="line">root@bac489a3beb3:/usr/local/tomcat# ping tomcat2</span><br><span class="line">ping: tomcat2: Name or service not known</span><br><span class="line">root@bac489a3beb3:/usr/local/tomcat# ping 192.168.0.3</span><br><span class="line">PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 无论是通过ip，还是通过容器名称，都无法连接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mynet和docker0的网段不同</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 使用docker network connect让docker0下的tomcat3容器连接到mynet网络</span></span><br><span class="line">[root@ming ~]# docker network connect mynet tomcat3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 查看mynet网络的详细信息</span></span><br><span class="line">[root@ming ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;805e98b29181a303950c9f3267587e6ea27c2df3728a0723e4f16acb43add392&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-01-05T19:12:36.296644818+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;a8d9dd3ce9633968957a5d1487bbf85716985f97ed6cf4f2b9a78c47d2c3f67d&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;f1bbab5f9d330f62f17ef2076dd09d00a124d14d5ce8c3658d8e6459215c4e19&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;bf9e41e968aeccc9ccd0ecc3efc60c1d38b550ea783dbc530b68eba9b7952d5c&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;f016fc90361535f9e08c0ad4dfd92bc630c83a88704680231e33a4bbd201f15a&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;f1933b52fa5559c60890e2a223cb118ff2290a5f0ff4966d1cffac28c280c439&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat3&quot;,  # mynet网络下已经有了tomcat3的容器</span><br><span class="line">                &quot;EndpointID&quot;: &quot;48ce720242696f70d6ae7051a8754d56b30ae2d3bc08b82761822eeca25ddebf&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看tomcat3容器的ip</span></span><br><span class="line">root@f1933b52fa55:/usr/local/tomcat# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">347: eth0@if348: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">349: eth1@if350: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:c0:a8:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.0.4/16 brd 192.168.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 可以看到，tomcat有2个ip地址</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">          172.17.0.2  docker0网卡的</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">          192.168.0.4  mynet网卡的</span></span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Spring%20Cloud/Spring%20Cloud/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="微服务架构理论入门"><a href="#微服务架构理论入门" class="headerlink" title="微服务架构理论入门"></a>微服务架构理论入门</h3><h4 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h4><ul>
<li><p>提倡将单一应用程序拆分成一组小的服务</p>
</li>
<li><p>每个服务都是一个SpringBoot应用</p>
</li>
</ul>
<h4 id="SpringCloud概念"><a href="#SpringCloud概念" class="headerlink" title="SpringCloud概念"></a>SpringCloud概念</h4><ul>
<li>分布式微服务架构的一站式解决方案</li>
</ul>
<h4 id="版本选型"><a href="#版本选型" class="headerlink" title="版本选型"></a>版本选型</h4><p><strong>由SpringCloud版本决定SpringBoot版本。</strong></p>
<h5 id="SpringBoot版本选型"><a href="#SpringBoot版本选型" class="headerlink" title="SpringBoot版本选型"></a>SpringBoot版本选型</h5><ul>
<li>springBoot官方强烈建议使用2.0以上版本</li>
<li>2.2.2.RELEASE</li>
</ul>
<h5 id="SpringCloud版本选型"><a href="#SpringCloud版本选型" class="headerlink" title="SpringCloud版本选型"></a>SpringCloud版本选型</h5><ul>
<li><p>springCloud H版本对应SpringBoot2.2.x版本</p>
</li>
<li><p>Hoxton.SR1</p>
</li>
<li><p>Clond Alibaba 2.1.0.RELEASE</p>
</li>
</ul>
<h3 id="停更的影响"><a href="#停更的影响" class="headerlink" title="停更的影响"></a>停更的影响</h3><ul>
<li>服务注册中心<ul>
<li>Eureka(×)</li>
<li>Zookeeper(✔)</li>
<li>Consul(✔)</li>
<li>Nacos(✔)</li>
</ul>
</li>
<li>服务调用<ul>
<li>Ribbon</li>
<li>LoadBalancer(✔)</li>
<li>Feign(x)</li>
<li>OpenFeign(✔)</li>
</ul>
</li>
<li>服务降级<ul>
<li>Hystrix(x)</li>
<li>Reslience4j(✔)</li>
<li>Sentinenl(✔ 国内使用)</li>
</ul>
</li>
<li>服务网关<ul>
<li>Zuul(x)</li>
<li>Gateway(✔)</li>
</ul>
</li>
<li>服务配置<ul>
<li>Config(x)</li>
<li>Nacos(✔)</li>
</ul>
</li>
<li>服务总线<ul>
<li>Bus(x)</li>
<li>Nacos(✔)</li>
</ul>
</li>
</ul>
<h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h4><ul>
<li>出现在最顶层的父POM文件中</li>
<li>锁定版本，子POM不需要指定版本号就可以使用父POM的版本号，子POM不需要写groupid和version</li>
<li>如果子POM指定了具体的版本号，使用子POM的版本号</li>
<li>只是声明依赖，并不引入，子POM需要显示声明需要用的依赖 </li>
</ul>
<h4 id="基础pom-xml"><a href="#基础pom-xml" class="headerlink" title="基础pom.xml"></a>基础pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringCloud alibaba nacos--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="微服务模块创建"><a href="#微服务模块创建" class="headerlink" title="微服务模块创建"></a>微服务模块创建</h4><ul>
<li>创建module(创建完成回到父工程POM查看变化)</li>
<li>修改pom.xml</li>
<li>写配置文件yml</li>
<li>写启动类</li>
<li>写业务类</li>
</ul>
<h4 id="mybatis-mapper文件模板"><a href="#mybatis-mapper文件模板" class="headerlink" title="mybatis mapper文件模板"></a>mybatis mapper文件模板</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sise.cloud.dao.StorageDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="构建时的几个小坑"><a href="#构建时的几个小坑" class="headerlink" title="构建时的几个小坑"></a>构建时的几个小坑</h4><ul>
<li><p>使用mybatis时，可以在启动类上标记注解@MapperScan来注入Dao，也可以直接在Dao上标记@Mappee注解来将Dao加入到容器中（不推荐使用@Repository，在插入时有时候会出现问题）</p>
</li>
<li><p>mapper.xml的namespace应该与Dao对应</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sise.cloud.dao.PaymentDao&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>mybatis的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># mapper.xml存放位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 实体类不用写全限定类名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.sise.cloud.model</span></span><br></pre></td></tr></table></figure></li>
<li><p>mybatis插入时返回主键的写法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Payment&quot;</span>&gt;</span></span><br><span class="line">      insert into payment(serial) values( #&#123;serial&#125; )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>返回的主键在对应实体的keyProperty中，而不是方法的返回值。方法的返回值是影响行数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Long&gt; <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span>  Payment payment)</span></span>&#123;</span><br><span class="line">    Integer row = paymentService.create(payment);</span><br><span class="line">    <span class="keyword">return</span> row != <span class="keyword">null</span> ? <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">200</span>,<span class="string">&quot;ok&quot;</span>, payment.getId())</span><br><span class="line">        : <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">500</span>,<span class="string">&quot;create error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>datasource配置：</p>
<p><strong>注意serverTimezone的大小写。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 当前数据库操作类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mcloud?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></li>
<li><p>post方法传递json数据时，后端记得加上@RequestBody注解</p>
</li>
</ul>
<h4 id="devtool热部署"><a href="#devtool热部署" class="headerlink" title="devtool热部署"></a>devtool热部署</h4><ol>
<li>添加maven依赖(子POM)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在pom文件中添加maven-plugin(父POM)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>enabling automatic build</li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211204645960.png" alt="image-热部署idea设置"></p>
<ol start="4">
<li>ctrl + shift + alt + /</li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211204742180.png" alt="image-registry设置"></p>
<h4 id="Run-Dashboard的配置"><a href="#Run-Dashboard的配置" class="headerlink" title="Run Dashboard的配置"></a>Run Dashboard的配置</h4><p><strong>在项目的存放路径下.idea目录下，有一个workspace.xml，找到RunDashboard的选项，添加配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;ruleStates&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重启idea后，再次run项目就出现了。</p>
<h4 id="maven出现KIX-path-building-failed"><a href="#maven出现KIX-path-building-failed" class="headerlink" title="maven出现KIX path building failed"></a>maven出现KIX path building failed</h4><p>idea maven设置添加参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-DarchetypeCatalog=internal -Dmaven.wagon.http.ssl.insecure=<span class="keyword">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211213212548.png" alt="image-maven设置"></p>
<h4 id="抽取出公用的api和实体类"><a href="#抽取出公用的api和实体类" class="headerlink" title="抽取出公用的api和实体类"></a>抽取出公用的api和实体类</h4><ul>
<li>新建一个moduel：cloud-api-common</li>
<li>将多个模块重复的代码抽取到这个模块</li>
<li>maven clean instll ，将公用模块发布到仓库</li>
<li>其他module引入公用模块的坐标</li>
</ul>
<h4 id="80端口被占用"><a href="#80端口被占用" class="headerlink" title="80端口被占用"></a>80端口被占用</h4><p>在window上，80端口被占用的2种情况：</p>
<ul>
<li>SQL Server Reporting Services (MSSQLSERVER) ，SQL Server的日志系统</li>
<li>IIS服务</li>
</ul>
<p>解决方法（SQL Server Reporting Services ）：</p>
<ol>
<li>使用命令netstat -ano|findstr 80查找使用80端口的程序，可以看到是pid=4的的程序</li>
<li>使用命令tasklist列出当前运行的所有线程，可以看到pid=4的程序竟然是system</li>
<li>使用命名services.msc进入服务端口，找到SQL Server Reporting Services (MSSQLSERVER)，终止</li>
</ol>
<p>解决方法（IIS）:</p>
<ol>
<li>使用管理员身份运行cmd</li>
<li>使用net stop http停止http服务</li>
<li>sc config http start= disabled  <strong>注意，=后面的空格不可少</strong></li>
</ol>
<h4 id="linux安装wget"><a href="#linux安装wget" class="headerlink" title="linux安装wget"></a>linux安装wget</h4><ol>
<li>linux查看版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据linux版本下载wget命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ftp.sjtu.edu.cn/centos/7/os/x86_64/Packages/</span><br><span class="line">下载wget-1.14-18.el7_6.1.x86_64.rpm   </span><br><span class="line">上传到阿里云服务器</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装wget</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -vih wget-1.14-18.el7_6.1.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>如果已经安装了wget，还提示wget command is not found？ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.执行以下命令查询wge命令的路径</span></span><br><span class="line">whereis wge</span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统返回以下信息。</span></span><br><span class="line">wge：/usr/bin/wge</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.根据上述的路径，执行以下命令重命名即可。</span></span><br><span class="line">cp /usr/bin/wge /usr/bin/wget</span><br></pre></td></tr></table></figure>



<h4 id="linux配置网卡"><a href="#linux配置网卡" class="headerlink" title="linux配置网卡"></a>linux配置网卡</h4><ol>
<li><p>使用ipconfig查看ip信息</p>
</li>
<li><p>vim /etc/sysconfig/network-scripts/ifcfg-eth0</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">ARPCHECK=no</span><br><span class="line">IPADDR=172.16.47.149</span><br><span class="line">NETMASK=255.255.240.0</span><br><span class="line">GATEWAY=172.16.47.253</span><br></pre></td></tr></table></figure>



<h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查询包安装的位置</span><br><span class="line">rpm -ql 包名</span><br><span class="line"># 查询所有已经安装的包</span><br><span class="line">rpm  -qa  </span><br><span class="line"># 查询包是否安装</span><br><span class="line">rpm  -q</span><br></pre></td></tr></table></figure>





<h4 id="修改阿里的yum源"><a href="#修改阿里的yum源" class="headerlink" title="修改阿里的yum源"></a>修改阿里的yum源</h4><ol>
<li> 首先备份系统自带yum源配置文件/etc/yum.repos.d/CentOS-Base.repo</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看centos版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下载yum源配置文件到/etc/yum.repos.d</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CentOS7</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CentOS6</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CentOS5</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行yum makecache生成缓存</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>



<h4 id="linux安装JDK"><a href="#linux安装JDK" class="headerlink" title="linux安装JDK"></a>linux安装JDK</h4><ol>
<li><p>下载rpm包，上传到linux服务器</p>
</li>
<li><p>rpm -ivh 安装包</p>
</li>
<li><p>rpm -qa | grep jdk 查找当前系统中安装的JDK包</p>
</li>
<li><p>rpm -ql jdk包名 | grep bin 查找JDK安装的目录</p>
</li>
<li><p>配置环境变量vim /etc/profile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_271-amd64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></li>
<li><p>测试查看JDK版本  java  javac</p>
</li>
</ol>
<h4 id="linux安装maven"><a href="#linux安装maven" class="headerlink" title="linux安装maven"></a>linux安装maven</h4><ol>
<li><p>打开maven的官网下载页，找到tar.gz压缩包，然后右键选择【复制链接地址】</p>
</li>
<li><p>回到Linux服务器中，创建一个maven目录，使用<code>wget</code>命令将复制的链接进行下载。</p>
</li>
<li><p> 然后使用命令<code>tar -zxvf apache-maven-3.6.0-bin.tar.gz</code>，将压缩包进行解压，解压后我们会得到一个 <code>apache-maven-3.6.0</code>目录。</p>
</li>
<li><p>我们cd进入到 <code>apache-maven-3.6.0</code>目录，然后执行命令<code>pwd</code>，显示maven的绝对路径。然后复制该路径</p>
</li>
<li><p>执行命令<code>vim /etc/profile </code>编辑环境变量文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME=/root/app/maven/apache-maven-3.6.0</span><br></pre></td></tr></table></figure></li>
<li><p>将MAVEN_HOME追加到PATH环境变量中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure></li>
<li><p>执行<code>source /etc/profile</code>命令来更新刚才的配置。</p>
</li>
<li><p>执行命令<code>mvn -version</code>查看maven是否安装配置成功。</p>
</li>
</ol>
<h4 id="linux安装rabbitMQ"><a href="#linux安装rabbitMQ" class="headerlink" title="linux安装rabbitMQ"></a>linux安装rabbitMQ</h4><ol>
<li>安装erlang,添加源vim /etc/yum.repos.d/erlang-solutions.repo</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[erlang-solutions]</span><br><span class="line">name=CentOS $releasever - $basearch - Erlang Solutions</span><br><span class="line">baseurl=https://packages.erlang-solutions.com/rpm/centos/$releasever/$basearch</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.erlang-solutions.com/rpm/erlang_solutions.asc</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc</span><br></pre></td></tr></table></figure>

<p>安装erlang：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install erlang -y</span><br></pre></td></tr></table></figure>

<p>验证是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">erl -version</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201219203141782.png" alt="image-查看erlang版本"></p>
<ol start="2">
<li>安装rabbitMQ</li>
</ol>
<p>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.14/rabbitmq-server-3.7.14-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y rabbitmq-server-3.7.13-1.el7.noarch.rpm</span><br><span class="line">rpm -ivh rabbitmq-server-3.7.13-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>安装过程中如果出现错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Failed dependencies: 	socat is needed by rabbitmq-server-3.7.14-1.el7.noarch</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install socat</span><br></pre></td></tr></table></figure>

<p>安装完成后在/usr/sbin目录下有4个关于rabbitMQ的命令：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201219222958331.png" alt="image-rabbitMQ命令"></p>
<ol start="3">
<li>启动rabbitMQ</li>
</ol>
<blockquote>
<p>rabbitmq-server start，当然也可以使用 rabbitmqctl statr_app 来启动</p>
</blockquote>
<ol start="4">
<li>开启rabbitMQ界面管理</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加账号，授权远程访问</li>
</ol>
<blockquote>
<p>默认帐号guest只能用于本地访问，要远程访问可添加用户授权</p>
<p>添加新用户：rabbitmqctl add_user ming 123456</p>
<p>给新用户添加tags：rabbitmqctl set_user_tags ming administrator</p>
<p>授权：rabbitmqctl set_permissions ming “.<em>“ “.</em>“ “.*”</p>
<p>查看rabbitmqctl 命令的使用：rabbitmqctl </p>
</blockquote>
<ol start="6">
<li>重启</li>
</ol>
<blockquote>
<p>关闭：rabbitmqctl stop</p>
<p>启动：rabbitmqctl start_app</p>
<p>浏览器输入 ip:15672 进入登录界面，输入刚才创建的用户名和密码即可进入</p>
</blockquote>
<ol start="7">
<li>开放端口，15672是web管理界面的端口，5672是MQ访问的端口</li>
</ol>
<blockquote>
<p>如果是阿里云的服务器，需要到安全组中开放5672和15672端口</p>
</blockquote>
<h4 id="linux安装nacos"><a href="#linux安装nacos" class="headerlink" title="linux安装nacos"></a>linux安装nacos</h4><ol>
<li><p>确保先安装了JDK和Maven</p>
</li>
<li><p>上传tar.gz包到服务器，tar -zxvf xxx解压后，bin目录中运行</p>
<p>./startup.sh -m standalone</p>
</li>
</ol>
<h4 id="linux安装mysql"><a href="#linux安装mysql" class="headerlink" title="linux安装mysql"></a>linux安装mysql</h4><ol>
<li>检查是否已经安装过mysql</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">rpm</span> <span class="string">-qa</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果已经安装，执行删除命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查询所有mysql对应的文件夹,删除相关目录或文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">whereis</span> <span class="string">mysql</span></span><br><span class="line"><span class="string">rm</span> <span class="string">-rf</span> <span class="string">/usr/bin/mysql</span> <span class="string">/usr/include/mysql</span> <span class="string">/data/mysql</span> <span class="string">/data/mysql/mysql</span> </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>检查mysql用户组和用户是否存在，如果没有，则创建</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/group | grep mysql</span><br><span class="line">cat /etc/passwd |grep mysql</span><br><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>下载mysql安装包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>解压到/usr/local/mysql目录下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xzvf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在/usr/local/mysql目录下创建data目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/mysql/data</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br><span class="line">chmod -R 755 /usr/local/mysql</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>编译安装并初始化mysql,<strong>务必记住初始化输出日志末尾的密码（数据库管理员临时密码）</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br><span class="line">./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>编辑配置文件my.cnf</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">port=3306</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections=600</span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">character_set_server=utf8</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>测试启动mysql服务器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>添加软连接，并重启mysql服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql </span><br><span class="line">ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>登录mysql，修改密码(密码为步骤5生成的临时密码)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">set password for root@localhost = password(&#x27;yourpass&#x27;);</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>开放远程连接</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set user.Host=&#x27;%&#x27; where user.User=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>设置开机自动启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、将服务文件拷贝到init.d下，并重命名为mysql</span><br><span class="line">[root@localhost /]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">2、赋予可执行权限</span><br><span class="line">[root@localhost /]# chmod +x /etc/init.d/mysqld</span><br><span class="line">3、添加服务</span><br><span class="line">[root@localhost /]# chkconfig --add mysqld</span><br><span class="line">4、显示服务列表</span><br><span class="line">[root@localhost /]# chkconfig --list</span><br></pre></td></tr></table></figure>



<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h4 id="单机版Eureka服务端"><a href="#单机版Eureka服务端" class="headerlink" title="单机版Eureka服务端"></a>单机版Eureka服务端</h4><ol>
<li>导入maven依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka-server --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--监控--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一般通用配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心,我的职责是维护服务实例,并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defalultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类标明是eureka服务端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动项目，访问服务器地址<a href="http://localhost:7001/">http://localhost:7001</a></li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211222400955.png" alt="image-eureka服务端启动"></p>
<h4 id="单机版Eureka客户端"><a href="#单机版Eureka客户端" class="headerlink" title="单机版Eureka客户端"></a>单机版Eureka客户端</h4><ol>
<li>导入Eureka client依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--监控--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改application.yml配置文件，添加eureka client配置项</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># EurekaServer url</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在启动类上添加注解@EnableEurekaClient</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>先启动EurekaServer，再启动EurekaClient</li>
</ol>
<p><strong>必须先启动服务端，否则客户端连接会报错Connection refused: connect</strong></p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211230437404.png" alt="image-eurekaServer"></p>
<h4 id="单机版和集群版的比较"><a href="#单机版和集群版的比较" class="headerlink" title="单机版和集群版的比较"></a>单机版和集群版的比较</h4><p><strong>单机版本的Eureka会有单点故障的问题。</strong></p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201211234341772.png" alt="image-集群版Eureka"></p>
<p>多台EurekaServer服务器之间的关系是怎样的？<strong>互相注册，相互守望</strong></p>
<h4 id="集群版Eureka服务器"><a href="#集群版Eureka服务器" class="headerlink" title="集群版Eureka服务器"></a>集群版Eureka服务器</h4><p><strong>所谓的集群版是指：有多台EurekaServer服务器，它们互相 注册，相互守望 。</strong></p>
<p>创建的步骤和单机版的Eureka服务器很类似，由于它们要互相注册，相互守望，一个hostname满足不了。</p>
<p>所有，我们需要修改host文件将127.0.0.1本地映射成2个hostname。</p>
<ol>
<li>修改host文件，C:\Windows\System32\drivers\etc</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># mcloud</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> eureka7001.com</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> eureka7002.com</span><br></pre></td></tr></table></figure>

<h5 id="修改hosts不生效解决方法"><a href="#修改hosts不生效解决方法" class="headerlink" title="修改hosts不生效解决方法"></a>修改hosts不生效解决方法</h5><ul>
<li><p>直接修改hosts文件，一般情况下是保存失败的。需要保存到其他目录，在复制进C:\Windows\System32\drivers\etc目录，选择继续替换掉原来的host</p>
</li>
<li><p>如果还不生效，尝试刷新一下DNS缓存。使用命令ipconfig /flushdns</p>
</li>
</ul>
<ol start="2">
<li>修改application.yml配置文件</li>
</ol>
<p> 7001端口的EurekaServer：</p>
<p>注意hostname 和 service-url的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心,我的职责是维护服务实例,并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>

<p>7002端口的EurekaServer：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动服务</li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212110342536.png" alt="image-port7001"></p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212110414933.png" alt="image-port7002"></p>
<h4 id="集群版Eureka客户端"><a href="#集群版Eureka客户端" class="headerlink" title="集群版Eureka客户端"></a>集群版Eureka客户端</h4><p>集群版的客户端主要是application.yml配置文件不同：<strong>service-url注册两个Eureka服务器的地址。</strong></p>
<p>order:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># EurekaServer url</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>

<p>payment:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># EurekaServer url</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>



<h4 id="集群版服务提供者"><a href="#集群版服务提供者" class="headerlink" title="集群版服务提供者"></a>集群版服务提供者</h4><p>由于有多台服务器提供服务，它们都要向注册中心注册服务。</p>
<p>只是application.yml的配置文件不同：比如server.port不同</p>
<p><strong>但是spring.application.name是相同的。集群版服务提供者暴露出一个相同的服务名称，但内部可能由多个端口提供服务。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 当前数据库操作类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mcloud?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># mapper.xml存放位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 实体类不用写全限定类名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.sise.cloud.model</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># EurekaServer url</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，服务使用者order80该怎么去访问集群版的服务提供者提供的服务呢？</p>
<p><strong>只需要使用服务提供者暴露出来的服务名称。</strong></p>
<p>如下，统一使用CLOUD-PAYMENT-SERVICE访问8001和8002提供的服务。</p>
<p>经过测试，通过访问服务提供者application.yml中配置的小写的cloud-payment-service也是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ROOT = <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;String&gt; <span class="title">create</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">        CommonResult commonResult = restTemplate.postForEntity(ROOT + <span class="string">&quot;/payment/create&quot;</span>, payment, CommonResult.class).getBody();</span><br><span class="line">        <span class="keyword">return</span> commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/find/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        CommonResult commonResult = restTemplate.getForEntity(ROOT + <span class="string">&quot;/payment/find/&quot;</span> + id, CommonResult.class).getBody();</span><br><span class="line">        <span class="keyword">return</span> commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果使用order80去访问服务，会出现如下错误：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212131113323.png" alt="image-集群服务提供者访问出现错误"></p>
<p>这是由于有8001和8002多个服务提供者，而order80不知道应该去访问哪个服务。</p>
<p>因为order80是通过restTemplate去访问的服务，应该配置restTemplate的负载均衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再使用order80去访问，就可以访问到服务了。</p>
<p>使用默认的负载均衡策略- 轮询。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212131502623.png" alt="image-8001端口提供的服务"></p>
<p>刷新一下，可能看到的：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212131557705.png" alt="image-8002端口提供的服务"></p>
<h4 id="微服务主机信息和ip信息的配置"><a href="#微服务主机信息和ip信息的配置" class="headerlink" title="微服务主机信息和ip信息的配置"></a>微服务主机信息和ip信息的配置</h4><ol>
<li>配置前需要导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改application.yml配置文件，设置instance-id 和 prefer-ip-address</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># EurekaServer url</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 主机名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span></span><br><span class="line">    <span class="comment"># 访问路径可以显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212134024996.png" alt="image-配置主机信息和ip信息"></p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>对于注册进Eureka的服务，可以通过服务发现获取服务的信息。</p>
<ol>
<li>注入org.springframework.cloud.client.discovery.DiscoveryClient类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/discovery&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">discovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取EurekaServer上的所有服务名称</span></span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个服务名称对应的所有实例信息</span></span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(applicationName);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;services&quot;</span>,services);</span><br><span class="line">    map.put(<span class="string">&quot;instances&quot;</span>,instances);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动类上添加注解@EnableDiscoveryClient，==新版的springboot已经自动配置，可以不用加这个注解==</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment8001Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Payment8001Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212140312487.png" alt="image-服务发现获取服务信息"></p>
<h4 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h4><ol>
<li>为什么需要自我保护的机制？</li>
</ol>
<p>有时候，EurekaClient可以正常运行，但是与EurekaServer网络不通的情况，自我保护机制不会立刻将EurekaClient从服务注册表中删除。</p>
<ol start="2">
<li>什么是自我保护机制？</li>
</ol>
<p>EurekaServer将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p>
<p>当某时刻某一个微服务不可用了（在一定时间内（默认90s）没有接收到某个微服务实例的心跳），EurekaServer不会立即清理，依旧会对该微服务的信息进行保存。</p>
<ol start="3">
<li>如何关闭自我保护机制？</li>
</ol>
<p>EurekaServer的自我保护机制默认是开启的。可以在服务端的配置文件中设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">server:</span></span><br><span class="line">        <span class="comment"># 设置接收心跳的时间间隔</span></span><br><span class="line">        <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br><span class="line">        <span class="comment"># 关闭自我保护,默认值为true，保证不可用服务及时剔除	</span></span><br><span class="line">        <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>为了方便测试，设置EurekaClient发送心跳的时间间隔和服务器等待时间上限：</p>
<p>如下，每隔1s，客户端向服务器发送心跳。服务端在接收到最后一次心跳后，最长等待2s。</p>
<p>如果2s后没有再次接收到客户端的心跳信息，服务端又关闭了自我保护机制的话，客户端实例会被服务端从服务注册表中删除。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 主机名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="comment"># 访问路径可以显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 客户端向服务端发送心跳的时间间隔，默认为30s</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 服务端在收到最后一次心跳后等待时间上限,默认为90s</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201212153620657.png" alt="image-自我保护机制"></p>
<h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>引入spring-cloud-starter-netflix-eureka-client的时候就自动引入了ribbon</p>
<h4 id="修改默认的负载均衡算法"><a href="#修改默认的负载均衡算法" class="headerlink" title="修改默认的负载均衡算法"></a>修改默认的负载均衡算法</h4><ol>
<li><p>实现自己的配置类，返回新的IRule实例。</p>
<p><strong>注意，配置类不能放在启动类能扫描到的包或子包下。</strong></p>
</li>
</ol>
<p><img src="C:\Users\zjm16\AppData\Roaming\Typora\typora-user-images\image-20201213163211853.png" alt="image-配置类的存放路径"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRuleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">iRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 修改为随机的负载均衡算法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在启动类上加上注解RibbonClient，指定配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;cloud-payment-service&quot;,configuration = CustomerRuleConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h4><p><strong>rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务位置下标</strong></p>
<p>每次服务重启后，rest接口计数从1开始。</p>
<p>使用自旋锁和CAS实现轮询算法：</p>
<ol>
<li>定义接口，定义方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从多个服务实例中选择一个实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instances 多个服务实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ServiceInstance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ServiceInstance <span class="title">instance</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现LoadBanlance接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instance</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.getIndexAndIncrement(instances.size());</span><br><span class="line">        <span class="keyword">return</span> instances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前服务的下标,并自增1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 服务的集群实例总数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实际调用服务位置下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndexAndIncrement</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自旋锁 和 CAS 实现轮询算法</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> current = atomicInteger.get();</span><br><span class="line">            <span class="keyword">int</span> next = (current + <span class="number">1</span>) % size;</span><br><span class="line">            <span class="comment">// 如果下标更新成功了,返回。更新不成功,自旋直至更新成功</span></span><br><span class="line">            <span class="keyword">if</span>(atomicInteger.compareAndSet(current, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注入LoadBalance，调用服务</li>
</ol>
<p>在调用自己实现的LoadBalance之前，记得去掉RestTemplate的@LocdBalance注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;round/find/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">findByIdAndRound</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;cloud-payment-service&quot;</span>);</span><br><span class="line">    ServiceInstance instance = loadBalance.instance(instances);</span><br><span class="line">    URI uri = instance.getUri();</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(uri +<span class="string">&quot;/payment/find/&quot;</span> + id, CommonResult.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>OpenFeign集成了Ribbon和RestTemplate，提供了一种接口+@FeginClient进行服务调用的机制。</p>
<ol>
<li>引入maven依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml配置文件</li>
</ol>
<p>此处不将其注册为EurekaService的服务，设置了register-with-eureka: false</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-openFeign-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写启动类，加上@EnableFeignClients</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOpenFeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderOpenFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写接口，加上@FeignClient</li>
</ol>
<p>@FeignClient的name属性是服务提供者的服务名称。</p>
<p>接口中的方法与服务提供者Controller的方法相同，url也应该相同。</p>
<p>服务消费者的PaymentService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;cloud-payment-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Long&gt; <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/find/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务提供者的PaymentController:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Long&gt; <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span>  Payment payment)</span></span>&#123;</span><br><span class="line">        Integer row = paymentService.create(payment);</span><br><span class="line">        <span class="keyword">return</span> row != <span class="keyword">null</span> ? <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">200</span>,<span class="string">&quot;ok&quot;</span> + port, payment.getId())</span><br><span class="line">                : <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">500</span>,<span class="string">&quot;create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/find/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        Payment payment = paymentService.findById(id);</span><br><span class="line">        <span class="keyword">return</span> payment != <span class="keyword">null</span> ? <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">200</span>,<span class="string">&quot;ok&quot;</span> + port,payment)</span><br><span class="line">                : <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">404</span>,<span class="string">&quot;not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写服务消费者的controller，直接调用PaymentService,不需要使用Ribbon</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Long&gt; <span class="title">create</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/find/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> paymentService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h4><p>OpenFeign的默认超时时间是1s，请求超出这个时间，会报timeout的错误。</p>
<p>设置超时时间：</p>
<p>由于OpenFeign底层是ribbon，设置的是ribbon的属性。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><p>OpenFeign提供了日志对接口的调用情况进行监控和输出。</p>
<p>日志级别：</p>
<ul>
<li>NONE：默认的，不显示任何日志</li>
<li>BASIC：仅记录请求方法、URL、响应状态码以及执行时间</li>
<li>HEADERS：除了BASIC定义的信息之外，还有请求和响应的头信息</li>
<li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文以及元数据</li>
</ul>
<ol>
<li>添加配置类，设置日志级别</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeginConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">logLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 设置类的日志级别</span></span><br><span class="line">    <span class="attr">com.sise.cloud.service.PaymentService:</span>  <span class="string">debug</span></span><br></pre></td></tr></table></figure>



<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>服务降级（fallback）</p>
</blockquote>
<p>哪些情况会发生服务降级：</p>
<ul>
<li>异常</li>
<li>超时</li>
<li>服务熔断</li>
<li>线程池/信号量打满</li>
</ul>
<blockquote>
<p>服务熔断（break）</p>
</blockquote>
<p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级</p>
<blockquote>
<p>服务限流（flow limit）</p>
</blockquote>
<p>秒杀高并发等操作，一秒钟N个，有序进行。</p>
<p>服务降级 -&gt; 进而熔断 -&gt; 限流</p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> @HystrixCommand注解的使用</li>
</ol>
<p>@HystrixCommand指定当发生超时或异常时，执行fallbackMethod指定的降级方法。</p>
<p>@HystrixProperty指定超时上限，当超过这个时间时，会执行fallbackMethod指定的降级方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;timeoutOrExceptionHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1000&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">timeout</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;hystrix,timeout,id:&quot;</span> + id + <span class="string">&quot;耗时:3s&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">timeoutOrExceptionHandler</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;发生超时，或者发生异常. id:&quot;</span> + id;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类开启Hystrix</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixPayment8001Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixPayment8001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ol>
<li>fallbackMethod指定的方法可以放在controller层，但是指定的方法和@HystrixCommand必须在同一个文件，否则报错fallback method wasn’t found</li>
<li>若发生异常，异常并不会抛出，直接执行了fallbackMethod指定的方法</li>
<li>服务降级可以添加在服务器，也可以添加在客户端</li>
<li>若客户端和服务端都做了服务降级，优先执行客户端的降级方法</li>
<li>fallbackMethod方法的参数要和对应的服务的方法形参类型一致</li>
</ol>
<h4 id="全局服务降级"><a href="#全局服务降级" class="headerlink" title="全局服务降级"></a>全局服务降级</h4><p>为每一个方法写一个fallbackMethod真的是太麻烦了。我们希望有一个全局的方法，当我方法上没指定fallbackMethod的时候，使用全局的fallbackMethod方法，当方法上指定了fallbackMethod的时候，使用方法上指定的fallbackMethod方法。</p>
<ol>
<li>使用@DefaultProperties在类上标记fallbackMethod</li>
<li>使用@HystrixCommand在方法上标记，当方法出现异常或超时，又没有指定fallbackMethod时，使用@DefaultProperties标记的fallbackMethod方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;timeoutOrExceptionHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function">String <span class="title">ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> paymentService.ok(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@HystrixCommand(fallbackMethod = &quot;timeoutOrExceptionHandler&quot;,commandProperties = &#123;</span></span><br><span class="line">    <span class="comment">//        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;6000&quot;)</span></span><br><span class="line">    <span class="comment">//&#125;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function">String <span class="title">timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.timeout(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">timeoutOrExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;80发生超时，或者发生异常.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局服务降级可以为同一个类中的方法统一一个fallbackMethod，但是与类形成了耦合，无法在多个类中共用。</p>
<h4 id="Feign支持的松耦合服务降级"><a href="#Feign支持的松耦合服务降级" class="headerlink" title="Feign支持的松耦合服务降级"></a>Feign支持的松耦合服务降级</h4><p>当使用Fegin的时候，调用的方法都是来自一个标记了@FeignClient的接口，我们就可以利用这个接口结合Feign，对接口中的每一个方法实现一个fallbackMethod方法。</p>
<ol>
<li>编写一个类实现提供服务的接口，并加入到容器当中</li>
</ol>
<p>当在服务接口指定了fallbackMethod对应的类，而这个类没有加入到容器中时，启动的时候扫描不到，会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackMethod</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ok</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentService ok method is exception or timeout&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">timeout</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentService timeout method is exception or timeout&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在服务提供接口指定fallbackMethod</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;cloud-hystrix-payment-service&quot;,fallback = PaymentFallbackMethod.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/payment/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/payment/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>application.yml开启Feign对Hystrix的支持</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<strong>当检测到该节点微服务调用响应正常后，恢复调用链路。</strong></p>
<p>在SpringCloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，默认是5s内20次调用失败，就会启动熔断机制。</p>
<p>熔断机制的注解是@HystrixCommand.</p>
<p>下列代码表明：在10s内服务调用超过了10次，且失败了6次（60%），会启动熔断机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;timeoutOrExceptionHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">           // 开启服务熔断</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name=&quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">           // 请求次数，次数超过阈值后，才会开启断路器</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">           // 时间范围</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),</span></span><br><span class="line"><span class="meta">           // 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;id 不能为负数&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ok,id:&quot;</span> + UUID.randomUUID();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">timeoutOrExceptionHandler</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;8001发生超时，或者发生异常. id:&quot;</span> + id ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>三个重要参数：</p>
<ul>
<li>快照时间戳：断路器统计一些请求和错误信息的统计时间范围，默认为最近的10秒</li>
<li>请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认值是20，意味着在10秒内，如果调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开</li>
<li>错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如，发生了30次调用，而有15次调用失败，也就是50%的错误百分比，这时候断路器就会打开。默认值是50%</li>
</ul>
<p><strong>断路器开启/关闭的条件：</strong></p>
<ul>
<li>当满足一定请求阈值的时候（默认10秒内超过20个请求）</li>
<li>并且失败率达到阈值的时候（默认10秒内超过50%的请求失败）</li>
<li>到达以上阈值，断路器将会开启，所有的请求都不会进行转发</li>
<li>一段时间之后（默认是5秒），这个时间断路器是半开状态，会让其中一个请求进行转发，如果成功，断路器会关闭，若失败，继续开启，重复以上步骤</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">断路器的打开和关闭,是按照一下<span class="number">5</span>步决定的</span><br><span class="line">  	<span class="number">1</span>,并发此时是否达到我们指定的阈值</span><br><span class="line">  	<span class="number">2</span>,错误百分比,比如我们配置了<span class="number">60</span>%,那么如果并发请求中,<span class="number">10</span>次有<span class="number">6</span>次是失败的,就开启断路器</span><br><span class="line">  	<span class="number">3</span>,上面的条件符合,断路器改变状态为open(开启)</span><br><span class="line">  	<span class="number">4</span>,这个服务的断路器开启,所有请求无法访问</span><br><span class="line">  	<span class="number">5</span>,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复</span><br><span class="line">  		如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态</span><br></pre></td></tr></table></figure>





<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h4><ol>
<li>引入依赖，注意gateway不需要引入web和actuator</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml配置路由</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_rout</span></span><br><span class="line">          <span class="comment"># 真实的访问url</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span></span><br><span class="line">          <span class="comment"># **表示匹配参数</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/find/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/create/**</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gateway9527Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Gateway9527Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:9527/payment/find/1</span></span><br><span class="line">http:<span class="comment">//localhost:8001/payment/find/1</span></span><br><span class="line">访问的是相同的页面，隐藏了<span class="number">8001</span>端口，对外暴露出<span class="number">9527</span>的端口</span><br></pre></td></tr></table></figure>



<h4 id="编码方式配置路由"><a href="#编码方式配置路由" class="headerlink" title="编码方式配置路由"></a>编码方式配置路由</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入RouteLocatorBuilder构建RouteLocator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customerRouter</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">        RouteLocatorBuilder.Builder routes = builder.routes();</span><br><span class="line">        <span class="comment">// 构建一个/blog 指向 http://www.caixukun8.top</span></span><br><span class="line">        routes.route(<span class="string">&quot;blog_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/fuck&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="通过微服务名实现动态路由"><a href="#通过微服务名实现动态路由" class="headerlink" title="通过微服务名实现动态路由"></a>通过微服务名实现动态路由</h4><p>上面的uri配置是写死在application.yml文件中的，我们可以利用gateway的动态路由，通过微服务的名称，负载均衡的查找服务。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名称进行路由</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_rout</span></span><br><span class="line">          <span class="comment"># 真实的访问url</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001</span></span><br><span class="line">          <span class="comment"># lb是写死的,loadBalance,表示负载均衡</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="comment"># **表示匹配参数</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/find/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/create/**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>当访问<a href="http://localhost:9527/payment/find/1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%9A%E8%BF%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%BB%E6%9F%A5%E6%89%BE8001%E6%88%968002%E7%AB%AF%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82">http://localhost:9527/payment/find/1的时候，通过负载均衡去查找8001或8002端口提供的服务。</a></p>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><hr>
<h4 id="读取远程仓库的配置文件"><a href="#读取远程仓库的配置文件" class="headerlink" title="读取远程仓库的配置文件"></a>读取远程仓库的配置文件</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml配置文件</li>
</ol>
<ul>
<li>配置中心无需配置name属性和profile属性，只有别的服务来访问配置中心时，别的服务才需要配置name属性和profile属性</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 文件名-前面的</span></span><br><span class="line">      <span class="comment"># name: config</span></span><br><span class="line">      <span class="comment"># 文件名-后面的</span></span><br><span class="line">      <span class="comment"># profile: dev</span></span><br><span class="line">      <span class="comment"># 远程仓库地址</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:JinMing8/mcloud.git</span></span><br><span class="line">          <span class="comment"># 配置文件在远程仓库的存放目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mcloud</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config3344Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Config3344Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<p>假设github上存在以下两个配置文件：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201219142706651.png" alt="image-20201219142706651"></p>
<p>通过浏览器访问：<a href="">http://localhost:3344/master/config-prod.yml</a>得到以下结果：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">mater</span> <span class="string">branch,config-prod,version</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>或者通过<a href="">http://localhost:3344/config-prod/master</a> 得到JSON格式的返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;config-prod&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;master&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;label&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;6abe5f2cbb64765bc7ffa0ca3a8574f8b57256f8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;state&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;propertySources&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;git@github.com:JinMing8/mcloud.git/config-prod.yml&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;config.info&quot;</span>: <span class="string">&quot;mater branch,config-prod,version 1&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问的路径在远程仓库中不存在，会返回以下的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;config-prod.yml&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;master&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;label&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;6abe5f2cbb64765bc7ffa0ca3a8574f8b57256f8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;state&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;propertySources&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问的文件在远程仓库中不存在，会返回以下的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置中心的搭建"><a href="#配置中心的搭建" class="headerlink" title="配置中心的搭建"></a>配置中心的搭建</h4><p>以上只是单独创建了一个服务，去访问远程仓库的配置文件。</p>
<p>如果想让它成为配置中心，也非常简单，将其注册成为EurekaSerrver的一个服务即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>启动类上加入注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config3344Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Config3344Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="其他服务访问配置中心"><a href="#其他服务访问配置中心" class="headerlink" title="其他服务访问配置中心"></a>其他服务访问配置中心</h4><p>其他服务不直接访问访问远程仓库获取配置信息，而是访问配置中心获取配置文件的信息。</p>
<ol>
<li>引入依赖，config的客户端</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bootstarp.yml的配置文件</li>
</ol>
<ul>
<li>config的客户端使用的配置文件是bootstrap.yml，而不是application.yml</li>
</ul>
<blockquote>
<p>application.yml 和 bootstrap.yml文件的区别：</p>
<table>
<thead>
<tr>
<th align="center">application.yml</th>
<th>bootstrap.yml</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户级别的资源配置项</td>
<td>系统级别，优先级更加高</td>
</tr>
<tr>
<td align="center">上下文是ApplicationContext</td>
<td>上下文是BootstrapContext,是ApplicationContext的父上下文。BootstrapContext负责从外部源加载配置属性并解析配置，这两个上下文共享一个从外部获取的Environment</td>
</tr>
</tbody></table>
<ul>
<li>Bootstrap有高优先级，默认情况下，它们不会被本地配置覆盖。</li>
<li>Bootstrap和Application有不同的上下文，保证配置的分离</li>
</ul>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-clinet-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 配置文件-前面的</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="comment"># 配置文件-后面的</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="comment"># 读取配置文件的地址</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config3355Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Config3355Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写测试Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 直接读取配置文件的信息</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">configInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的controller中直接从配置文件中读取配置信息，如果配置中心中不存在对应的配置中心，@Value读取失败，启动的时候就报错了。</p>
<ol start="5">
<li>测试</li>
</ol>
<p>访问<a href="">http://localhost:3355/configInfo</a>，返回以下结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">mater branch,config-prod,version <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果访问<a href="">http://localhost:3355/master/config-prod.yml</a>,会报404</p>
<p>此时，我们修改远程仓库的配置文件，将version 1 改成 version 2:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">    <span class="attr">info:</span> <span class="string">mater</span> <span class="string">branch,config-prod,version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>再次访问<a href="">http://localhost:3355/configInfo</a>，结果并没有刷新：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">mater branch,config-prod,version <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果访问[<a href="http://localhost:3344/master/config-prod.yml]%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A">http://localhost:3344/master/config-prod.yml]，返回结果是修改后的配置文件：</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: mater branch,config-prod,version <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>也就是说，修改了远程仓库的配置文件，配置中心会立即刷新，而其他服务去访问配置中心，却不会刷新。</strong></p>
<h4 id="手动刷新其他服务的配置"><a href="#手动刷新其他服务的配置" class="headerlink" title="手动刷新其他服务的配置"></a>手动刷新其他服务的配置</h4><ol>
<li>引入actuator监控依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件中暴露监控端口</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在需要刷新配置信息的类上添加注解@RefreshScope</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">configInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用actuator监控的特点，发生POST请求刷新服务</li>
</ol>
<p>利用curl命令，发生POST请求到[<a href="http://localhost:3355/actuator/refresh].%E5%88%B7%E6%96%B03355%E8%BF%99%E4%B8%AA%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">http://localhost:3355/actuator/refresh].刷新3355这个端口的配置信息</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:3355/actuator/refresh</span><br></pre></td></tr></table></figure>



<p>通过@RefreshScope和发生post请求去刷新，这种方式虽然可以刷新配置信息。但是这种方式不是最好的，如果有100个服务，需要手动发送100次POST请求(或许你可以使用脚本)。</p>
<p>由于100个服务都是从配置中心读取的配置文件，那么我们可不可以只刷新配置中心，让配置中心去刷新其他服务的配置信息呢？这就需要利用Spring Cloud Bus 。</p>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。</p>
<p>Spring Cloud Bus目前支持RabbitMQ和Kafka。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每个ConfigClient实例都监听MQ中同一个topic（默认是SpringCloudBus）,当一个服务刷新数据的时候，它会把这个信息放入到topic中，这样其他监听同一topic的服务就能得到通知，然后去更新自身的配置信息。</p>
<p>那么，我们就有2种方案来实现配置信息的刷新：</p>
<ul>
<li>通知ConfigClient中的其中一个客户端，这个客户端刷新数据的时候，会把更新的信息放入到topic中，其他客户端得到通知而更新自身配置</li>
<li>通知配置中心，由配置中心广播给其他客户端</li>
</ul>
<p>我们采用通知配置中心的方案来更新配置信息，第一种方案有如下缺点：</p>
<ul>
<li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责</li>
<li>破坏了微服务各个节点的对等性</li>
</ul>
<h4 id="通知配置中心，实现配置的自动刷新"><a href="#通知配置中心，实现配置的自动刷新" class="headerlink" title="通知配置中心，实现配置的自动刷新"></a>通知配置中心，实现配置的自动刷新</h4><ol>
<li>配置中心引入actuator,rabbitmq依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加消息总线RabbitMQ支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--监控--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件中设置rabbitMQ设置,暴露监听端口</li>
</ol>
<p>配置中心完整的配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 远程仓库地址</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:JinMing8/mcloud.git</span></span><br><span class="line">          <span class="comment"># 配置文件在远程仓库的存放目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mcloud</span></span><br><span class="line">  <span class="comment"># rabbitmq配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ming</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line"><span class="comment"># 暴露监听端口</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;bus-refresh&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ConfigClient也需要引入rabbitMQ依赖，并在配置文件中引入rabbitMQ的支持</li>
</ol>
<p>ConfigClient完整的配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-clinet-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 配置文件-前面的</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="comment"># 配置文件-后面的</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">prod</span></span><br><span class="line">      <span class="comment"># 读取配置文件的地址</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span></span><br><span class="line">  <span class="comment">#rabbitMQ配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ming</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<p>在远程仓库中修改配置文件信息后，发送POST请求通知配置中心，其他ConfigClient会收到配置中心的通知，从而更新自身的配置信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:3344/actuator/bus-refresh</span><br></pre></td></tr></table></figure>



<h4 id="定点通知"><a href="#定点通知" class="headerlink" title="定点通知"></a>定点通知</h4><p>所谓定点通知，即通知部分ConfigClient，而不是全部的ConfigClient。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//localhost:$&#123;serverport&#125;/actuator/bus-refresh/$&#123;destnation&#125;</span></span><br></pre></td></tr></table></figure>

<p>/bus/refresh请求不再发送到具体的服务实例上，而是发给配置中心，并通过destnation参数指定需要更新配置的服务实例。</p>
<p>这里的destnation实际上是服务名称（spring.application.name指定）+端口号。</p>
<p>比如上面的栗子，只通知localhost:3355这个服务实例更新配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:3344/actuator/bus-refresh/cloud-config-clinet-service:3355</span><br></pre></td></tr></table></figure>



<h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201219235538034.png" alt="image-Stream通信模型"></p>
<blockquote>
<p>Source和Sink</p>
</blockquote>
<ul>
<li>发送消息端（生产者）是Source</li>
<li>消息接收端（消费者）是Sink</li>
</ul>
<blockquote>
<p>Channel</p>
</blockquote>
<p>队列的一种抽象，在消息通讯系统中就是实现存储和转发的媒介。</p>
<h4 id="构建生产者"><a href="#构建生产者" class="headerlink" title="构建生产者"></a>构建生产者</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件</li>
</ol>
<p>生产者的配置文件：与stream整合需要一个binder，而binder指定消息服务的具体环境（比如使用rabbitMQ的host，username等）</p>
<p><strong>rabbitmq的配置是写在spring内的。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provide-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span></span><br><span class="line">        <span class="comment"># 自定义一个binder的名称，用于stream的整合配置</span></span><br><span class="line">        <span class="attr">default-rabbit:</span></span><br><span class="line">          <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="comment"># rabbitMQ相关的环境配置</span></span><br><span class="line">          <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">ming</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment"># stream的整合配置</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">output:</span></span><br><span class="line">          <span class="comment"># 生产者生产的消息放到哪个通道</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span></span><br><span class="line">          <span class="comment"># 消息类型，本次为json，如果是文本则设置为text/plain</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">text/plain</span></span><br><span class="line">          <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">default-rabbit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 主机名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801</span></span><br><span class="line">    <span class="comment"># 显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamProvide8801Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamProvide8801Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Source类生产消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Date</span> 2020/12/20 00:20</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> 消息生产者</span></span><br><span class="line"><span class="comment"> * 1. Source 是org.springframework.cloud.stream.messaging.Source包的</span></span><br><span class="line"><span class="comment"> * 2. 不需要使用<span class="doctag">@Service</span>将其加入到容器，<span class="doctag">@EnableBinding</span>已经指定这是一个Binder,</span></span><br><span class="line"><span class="comment"> *      将Channel和exchange绑定在一起</span></span><br><span class="line"><span class="comment"> * 3. 注意不要引错包</span></span><br><span class="line"><span class="comment"> * import org.springframework.messaging.Message;</span></span><br><span class="line"><span class="comment"> * import org.springframework.messaging.MessageChannel;</span></span><br><span class="line"><span class="comment"> * import org.springframework.messaging.support.MessageBuilder;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入消息管道,messageChannel接口有多个实现类，我们需要使用的是Source类,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;output&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建Message,消息内容为UUID</span></span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder.withPayload(UUID.randomUUID().toString()).build();</span><br><span class="line">        <span class="comment">// 输出消息内容</span></span><br><span class="line">        System.out.println(message.getPayload());</span><br><span class="line">        <span class="comment">// 将消息发送至Channel</span></span><br><span class="line">        output.send(message);</span><br><span class="line">        <span class="keyword">return</span> message.getPayload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageChannel有多个实现类，这里的output与配置文件中配置的需要一致。</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201220003426084.png" alt="image-MessageChannel的注入"></p>
<ol start="5">
<li>测试</li>
</ol>
<p>登录rabbitMQ的管理界面，可以看到我们自定义的studyExchange:</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201220153356198.png" alt="image-studyExchange"></p>
<h4 id="构建消费者"><a href="#构建消费者" class="headerlink" title="构建消费者"></a>构建消费者</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件</li>
</ol>
<p>消费者主要是配置rabbitMQ的相关配置，并且配置从哪个Channel取出消息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-customer-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span></span><br><span class="line">        <span class="comment"># 自定义一个binder的名称，用于stream的整合配置</span></span><br><span class="line">        <span class="attr">default-rabbit:</span></span><br><span class="line">          <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="comment"># rabbitMQ相关的环境配置</span></span><br><span class="line">          <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">ming</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment"># stream的整合配置</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">input:</span></span><br><span class="line">          <span class="comment"># 消费者消费的消息从哪个通道取</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span></span><br><span class="line">          <span class="comment"># 消息类型，本次为json，如果是文本则设置为text/plain</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">text/plain</span></span><br><span class="line">          <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">default-rabbit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 主机名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">customer-8802</span></span><br><span class="line">    <span class="comment"># 显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamCustomer8802Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamCustomer8802Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>业务类取出消息</li>
</ol>
<p>方法上使用注解@StreamListener，方法形参绑定发送者发送的消息类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        String output = <span class="string">&quot;消费者:&quot;</span> + serverPort +<span class="string">&quot;,获得的消息是：&quot;</span>+message.getPayload();</span><br><span class="line">        System.out.println(output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<p>访问生产者<a href="">http://localhost:8801/provide/send</a>，产生一条消息:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">a9841d4e<span class="number">-5510</span><span class="number">-4395</span>-ada5<span class="number">-53</span>edad88b5f7</span><br></pre></td></tr></table></figure>

<p>此时消费者8802接收到消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消费者:<span class="number">8802</span>,获得的消息是：a9841d4e-<span class="number">5510</span>-<span class="number">4395</span>-ada5-53edad88b5f7</span><br></pre></td></tr></table></figure>

<p>如果此时还有其他的消费者，比如消费者8803：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消费者:<span class="number">8803</span>,获得的消息是：a9841d4e-<span class="number">5510</span>-<span class="number">4395</span>-ada5-53edad88b5f7</span><br></pre></td></tr></table></figure>

<p>可见，生产者生产的一条消息，多个消费者都收到了，并且重复消费了。</p>
<h4 id="分组解决重复消费问题"><a href="#分组解决重复消费问题" class="headerlink" title="分组解决重复消费问题"></a>分组解决重复消费问题</h4><p>在Stream中，处于同一个group中的多个消费者是竞争关系，能够保证消息只会被其中一个消费者消费一次。</p>
<p>不同group是可以重复消费的。</p>
<p>查看rabbitMQ的界面，可以查看，默认情况下两个消费者属于不同的分组，因此它们可以重复消费。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201220160328224.png" alt="image-group"></p>
<p>我们可以为消费者设置相同的分组，解决重复消费的问题。分别在多个消费者的配置文件中配置group:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stream的整合配置</span></span><br><span class="line">     <span class="attr">bindings:</span></span><br><span class="line">       <span class="attr">input:</span></span><br><span class="line">         <span class="comment"># 消费者消费的消息从哪个通道取</span></span><br><span class="line">         <span class="attr">destination:</span> <span class="string">studyExchange</span></span><br><span class="line">         <span class="comment"># 消息类型，本次为json，如果是文本则设置为text/plain</span></span><br><span class="line">         <span class="attr">content-type:</span> <span class="string">text/plain</span></span><br><span class="line">         <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">         <span class="attr">binder:</span> <span class="string">default-rabbit</span></span><br><span class="line">         <span class="comment"># 指定分组</span></span><br><span class="line">         <span class="attr">group:</span> <span class="string">customerA</span></span><br></pre></td></tr></table></figure>



<p>重启后，生产者生产一条消息，只会被同组内的一个消费者消费。</p>
<p>查看rabbitMQ管理界面也可以看到我们设置的分组生效了：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201220160757195.png" alt="image-同一个group"></p>
<h4 id="持久化问题"><a href="#持久化问题" class="headerlink" title="持久化问题"></a>持久化问题</h4><p>假设消费者的服务挂掉了，但是生产者还一直在生产消息，那么这么消息会被怎么处理呢？</p>
<ul>
<li>如果指定了分组，这些消息会被持久化，当消费者重新启动的时候，这些消息会被消费</li>
<li>如果没有指定分组，这些消息会丢失</li>
</ul>
<p>测试：</p>
<p>消费者8802不指定分组，消费者8803指定分组customerA。同时关闭消费者8802和消费者8803，访问生产者生产3条消息。重新消费者服务:</p>
<p>消费者8803指定了分组，一启动消费之前持久化的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消费者:<span class="number">8803</span>,获得的消息是：756d6ec3-23d3-4af4-93f3-5a650ca6ee67</span><br><span class="line">消费者:<span class="number">8803</span>,获得的消息是：f37512be-f8e4-42f4-9a59-b53ec1e5668e</span><br><span class="line">消费者:<span class="number">8803</span>,获得的消息是：35b57408-263c-4dd4-9aa5-b0b00a5e773e</span><br></pre></td></tr></table></figure>

<p>而消费者8802重启之后，之前的消息丢失。</p>
<h3 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h3><hr>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前端请求都回形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延迟或者错误都会引起整个请求最后的失败。而Sleuth就是用于追踪每个请求的整体链路。</p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="comment"># 指定数据显示在哪里</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">        <span class="comment"># 采样率,介于0到1直接,1则表示全部采集</span></span><br><span class="line">        <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动java -jar java -jar zipkin-server-2.12.9-exec.jar</li>
</ol>
<p>这个jar包需要单独下载，这个jar就是图形界面的展示。</p>
<p>启动完成后，访问<a href="">http://localhost:9411/zipkin/</a>,可以查看链路。</p>
<p>span指的是访问的url。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201220164008117.png" alt="image-zipkin"></p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h4 id="服务提供者搭建"><a href="#服务提供者搭建" class="headerlink" title="服务提供者搭建"></a>服务提供者搭建</h4><ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件</li>
</ol>
<p>nacos不需要其他的服务注册模块了，不需要引入Eureka那一套了。</p>
<p><strong>注意server-addr的写法，写成<a href="">http://47.96.224.198:8848</a>是不行的，启动会报错。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span> <span class="comment"># nacos服务器地址</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosPayment9001Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosPayment9001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<p>登录[<a href="http://47.96.224.198:8848/nacos]%EF%BC%8C%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81%E9%BB%98%E8%AE%A4%E9%83%BD%E4%B8%BAnacos%E3%80%82%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%E6%B3%A8%E5%86%8C%E4%BA%86%E3%80%82">http://47.96.224.198:8848/nacos]，账户密码默认都为nacos。可以看到服务已经完成注册了。</a></p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221194659396.png" alt="image-服务注册"></p>
<p>访问<a href="">http://localhost:9001/payment/nacos/1</a>,返回结果符合预期。</p>
<h4 id="服务消费者搭建"><a href="#服务消费者搭建" class="headerlink" title="服务消费者搭建"></a>服务消费者搭建</h4><ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义配置，要调用的服务地址</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">payment-service-url:</span> <span class="string">http://nacos-payment-service</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosOrder83Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosOrder83Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>业务类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.payment-service-url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(paymentService+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>配置类</li>
</ol>
<p>配置restTemplate，注意加上负载均衡的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>测试</li>
</ol>
<p>打开nacos的管理界面，消费者order83已经完成注册。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221195103011.png" alt="image消费者完成注册"></p>
<p>访问<a href="">http://localhost:83/order/nacos/1</a>,返回结果预期。多次刷新页面，打印的端口也在变化，实现了负载均衡。</p>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><p>通过公式 <strong>${prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</strong> 从nacos中拉取配置。</p>
<blockquote>
<p>prefix默认为spring.application.name指定的值，也可以通过spring.cloud.nacos.config.prefix配置</p>
<p>spring.profiles.active为当前环境对应的profile,(dev,prod，test等)</p>
<p>file-extension为配置内容的数据格式，可以通过spring.cloud.nacos.file-extension来配置</p>
</blockquote>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221203317319.png" alt="image-配置文件命名规则"></p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件，bootstrap.yml 和 application.yml</li>
</ol>
<p>bootstrap.yml:</p>
<p>除了指定服务注册中心的地址之外，还需要执行配置中心的地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment"># 配置中心的地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment"># 只支持yaml,不支持yml</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">config</span></span><br></pre></td></tr></table></figure>

<p>application.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfig3377Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosConfig3377Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>业务类</li>
</ol>
<p>通过Spring Cloud的注解@RefreshScope实现配置的自动刷新，与Spring Clound Config相比，不再需要发送post请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<p>在nacos的配置中心根据${profix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}创建配置文件：config-dev.yaml</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221202509643.png" alt="image-config-dev.yaml"></p>
<p>启动服务nacos-config-3377，访问<a href="">http://localhost:3377/config/info</a>,得到以下结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">nacos config,DEFAULT_GROUP,version = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>从nacos的配置中心获取到了文件，尝试修改config-dev.yaml文件，将其version = 2</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">    <span class="attr">info:</span> <span class="string">nacos</span> <span class="string">config,DEFAULT_GROUP,version</span> <span class="string">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>不需要重启服务，不需要发送post请求，再次访问<a href="">http://localhost:3377/config/info</a>，配置信息自动刷新了，得到以下结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">nacos config,DEFAULT_GROUP,version = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>假设把配置文件中的prefix: config去掉，prefix默认值为${spring.application.name}的值，创建nacos-config-service-dev.yaml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">    <span class="attr">info:</span> <span class="string">nacos</span> <span class="string">config,DEFAULT_GROUP,version</span> <span class="string">=</span> <span class="number">3333</span></span><br></pre></td></tr></table></figure>

<p>此时，需要重启服务，重启后访问<a href="">http://localhost:3377/config/info</a>,得到以下结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">nacos config,DEFAULT_GROUP,version = <span class="number">3333</span></span><br></pre></td></tr></table></figure>





<h4 id="配置的隔离"><a href="#配置的隔离" class="headerlink" title="配置的隔离"></a>配置的隔离</h4><p>配置文件这里有namespace、group、DataId这3个概念，用来区分不同的环境。</p>
<p>namespace是可以用来区分部署环境的，Group和DataId逻辑上区分两个目标对象。</p>
<p><strong>默认值：</strong></p>
<p>namespace=public，group=DEFAULT_GROUP，默认Cluster(集群)是DEFAULT</p>
<p>Nacos默认的命名空间是public，namespace主要是用来实现隔离。比如说我们现在有3个环境：开发，测试，生产环境，我们就可以创建三个namespace，不同的namaspace之间是隔离的。</p>
<p>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组。</p>
<ol>
<li>默认namespace + DEFAULT_GROUP + 不同的DataId</li>
</ol>
<p>通过不同的DataId(即不同的配置文件名称)，通过切换spring.profiles.active的值来切换不同的配置文件。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221204841920.png" alt="image-DataId隔离配置文件"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line"><span class="comment">#    active: dev # 加载nacos-config-service-dev.yaml配置文件</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment"># 加载nacos-config-service-prod.yaml配置文件</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>默认的namespace + 相同的DataId + 不同的Group</li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221205245234.png" alt="image-Group隔离配置文件"></p>
<p>通过配置文件中指定的group属性，切换不同的配置文件：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221205446832.png" alt="image-通过group切换不同配置文件"></p>
<ol start="3">
<li>不同的namespace + 相同的Group + 相同的DataId</li>
</ol>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221205756914.png" alt="image-namespace隔离配置文件"></p>
<p>通过配置文件中指定的group属性，切换不同的配置文件：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221205920721.png" alt="image-通过namespace切换不同配置文件"></p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201221210119238.png" alt="image-不同的namespace"></p>
<h4 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h4><p>Nacos默认使用嵌入式数据库实现数据的存储。所以，如果启动多个配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySql的存储。</p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment"># dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sentinel8401Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Sentinel8401Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>业务类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------&gt;testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------&gt;testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<p>sentinel默认是懒加载的，只有访问了url之后，页面才会有显示。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222200953755.png" alt="image-sentinel控制台"></p>
<h4 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h4><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222201255069.png" alt="image-新增流控规则"></p>
<p>上面的配置表示，当访问/testA时，每秒钟的访问量超过1（阈值），后面的请求就直接失败，快速失败默认的处理方式是抛出异常。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>

<p>这里有关QPS和线程数的说明：</p>
<ul>
<li>QPS：每秒的请求数量，和时间有关</li>
<li>线程数：跟线程的数量有关，当线程数量超过阈值，会进行限流</li>
</ul>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222203120210.png" alt="image-线程数的配置"></p>
<p>如果流控模式选择关联，当关联的资源达到阈值，就限流自己。</p>
<p>比如支付接口达到阈值，就要限流订单接口。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222203702580.png" alt="image-关联"></p>
<p>warm up：根据codeFactory（冷加载因子，默认3）的值，从阈值codeFactory经过预热时长，才达到设置的QPS阈值。</p>
<p>应用场景：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进了，慢慢的把阈值增长到设置的阈值。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222204548485.png" alt="image-预热"></p>
<p>排队等待：让请求以均匀的速度通过，阈值类型必须设置成QPS，否则无效。</p>
<p>应用场景：用于处理间隔性突发的流量，比如消息队列。在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201222205812768.png" alt="image-排队等待"></p>
<h4 id="SentinelResource"><a href="#SentinelResource" class="headerlink" title="SentinelResource"></a>SentinelResource</h4><p>使用@SentinelResource可以自定义异常处理方法。类似于Hystrix的@HystrixCommand.</p>
<p>@SententinelResource的value属性可以指定资源名称，在sentinel界面配置流控规则的时候，可以使用资源名称，也可以使用url。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201223205817336.png" alt="image-使用资源名称配置流控规则"></p>
<p>使用blockHandler属性指明自定义的处理方法。当/testA(testA)被限流的时候，会进入到自定义的处理方法。自定义处理方法可以绑定一个BlockException。<strong>标记@SentinelResource的方法形参有什么参数，自定义的处理方法也要有对应的形参。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testA&quot;,blockHandler = &quot;handlerException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------&gt;testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;自定义的处理方法...,发生错误:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了代码的耦合性低，可以将自定义方法写在一个类中，使用blockHandlerClass属性指明自定义方法所在的类，blockHandler指明要处理的自定义方法。</p>
<p>只要标明了blockHandlerClass属性，就会到对应的类中去查找自定义方法，即使本类中指定了同名的自定义方法也无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testA&quot;,blockHandlerClass = CustomerHandler.class,blockHandler = &quot;handlerException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------&gt;testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;本类中的自定义的处理方法...,发生错误:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomerHander是自定义所在方法的类。<strong>类中的自定义处理方法必须使用static修饰。</strong></p>
<p>自定义处理方法类无需加入容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">handlerException</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;自定义类中的自定义的处理方法...,发生错误:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在@SentinelResource内属性blockHandler没有识别到匹配的方法，会将属性fallback的内容替代blockHandler内容.</p>
<p>fallback指定的自定义方法上，异常对象绑定的是Throwable，如果绑定BlockException会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testA&quot;,blockHandler = &quot;handlerException111&quot;,fallback = &quot;fallbackHandler&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------&gt;testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;本类中的自定义的处理方法...,发生错误:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallbackHandler</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;如果在@SentinelResource内属性blockHandler没有识别到匹配的方法，会将属性fallback的内容替代blockHandler内容:&quot;</span>+ e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小结：</p>
<ul>
<li><p><strong>标记@SentinelResource的方法形参有什么参数，自定义的处理方法也要有对应的形参。</strong></p>
</li>
<li><p><strong>类中的自定义处理方法必须使用static修饰。</strong></p>
</li>
<li><p><strong>如果在@SentinelResource内属性blockHandler没有识别到匹配的方法，会将属性fallback的内容替代blockHandler内容.</strong></p>
</li>
<li><p><strong>如果使用了@SentinelResource的value属性标记了资源名，流控规则不能配置为url的路径了。</strong></p>
</li>
<li><p><strong>如果出现了message not variable的错误，很有可能的自定义方法的形参绑定错误了。</strong></p>
</li>
<li><p><strong>流控规则不是持久化的，当重启了服务，配置的流控规则就会消失</strong></p>
</li>
<li><p><strong>标记@SentinelResource的方法不能是private</strong></p>
</li>
</ul>
<h4 id="fallback和blockHandler"><a href="#fallback和blockHandler" class="headerlink" title="fallback和blockHandler"></a>fallback和blockHandler</h4><p>fallback指定的方法主要用来处理java中发生的异常，blockHandler指定的方法主要用来处理sentinel中规则的异常。</p>
<blockquote>
<ol>
<li>只指定fallback</li>
</ol>
</blockquote>
<p>如果只指定了fallback方法，发生java异常会执行fallback指定的方法。</p>
<p>如果此时又违反了sentinel的规则，sentinel默认快速失败抛出的异常也会被fallback捕捉到进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackHandler&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">limitHandler</span><span class="params">(String id, BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;limitHandler处理sentinel配置的规则，e:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="2">
<li>只指定blockHandler方法</li>
</ol>
</blockquote>
<p>如果出现java异常，没有fallback方法处理，会直接在浏览器页面抛出异常。</p>
<p>如果违反了sentinel配置的规则，会进入blockHandler指定的方法进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;,blockHandler = &quot;limitHandler&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">limitHandler</span><span class="params">(String id, BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;limitHandler处理sentinel配置的规则，e:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="3">
<li>指定fallback和blockhandler</li>
</ol>
</blockquote>
<p>出现的java异常通过fallback指定的方法处理，违反sentinel规则的通过blockHandler指定的方法处理。</p>
<p>但如果同时出现java异常和违反sentinel规则，则blockHandler指定的方法优先级高于fallback指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackHandler&quot;,blockHandler = &quot;limitHandler&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallbackHandler</span><span class="params">(String id, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fallbackHandler处理java中的异常，e:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">limitHandler</span><span class="params">(String id, BlockException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;limitHandler处理sentinel配置的规则，e:&quot;</span> + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h4><p>默认情况下，服务重启后，之前配置的流控规则等就会消失，可以将其保存到nacos持久化保存。</p>
<ol>
<li>添加持久化依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加配置</li>
</ol>
<p>在配置文件中指明持久化的配置位于nacos配置中心的namespace、group、dataId等属性。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-payment-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">      <span class="comment"># 持久化设置</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">datasource1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">sentinel-payment-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在nacos配置中心添加文件</li>
</ol>
<p><img src="C:\Users\zjm16\AppData\Roaming\Typora\typora-user-images\image-20201224223359921.png" alt="image-nacos持久化配置"></p>
<p>关于参数的介绍：</p>
<blockquote>
<p>resource:资源名称，也可以指定url的路径</p>
<p>limitApp:来源应用</p>
<p>grade:阈值类型，0表示线程数，1表示QPS</p>
<p>count:单机阈值</p>
<p>strategy:流控模式，0表示直接，1表示关联，2表示链路</p>
<p>controlBehavior:流控效果，0表示快速失败，1表示Warm up，2表示排队等待</p>
<p>clusterMode:是否集群</p>
</blockquote>
<h3 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h3><h4 id="server端配置"><a href="#server端配置" class="headerlink" title="server端配置"></a>server端配置</h4><ol>
<li>修改file.conf和registry.conf文件</li>
</ol>
<p>在进行文件修改之前，先备份。</p>
<p>file.conf:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># transaction log store, only used in seata-server</span></span></span><br><span class="line">store &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># store mode: file、db、redis  存储模式修改为db</span></span></span><br><span class="line">  mode = &quot;db&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># file store property</span></span></span><br><span class="line">  file &#123;</span><br><span class="line">    ## store location dir</span><br><span class="line">    dir = &quot;sessionStore&quot;</span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># database store property</span></span></span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp)/HikariDataSource(hikari) etc.</span><br><span class="line">    datasource = &quot;druid&quot;</span><br><span class="line">    ## mysql/oracle/postgresql/h2/oceanbase etc.</span><br><span class="line">    dbType = &quot;mysql&quot;</span><br><span class="line">    driverClassName = &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    url = &quot;jdbc:mysql://localhost:3306/seata&quot;  # 需要创建seata库，并导入sql语句，生成3张表</span><br><span class="line">    user = &quot;root&quot;</span><br><span class="line">    password = &quot;123&quot;</span><br><span class="line">    minConn = 5</span><br><span class="line">    maxConn = 100</span><br><span class="line">    globalTable = &quot;global_table&quot;</span><br><span class="line">    branchTable = &quot;branch_table&quot;</span><br><span class="line">    lockTable = &quot;lock_table&quot;</span><br><span class="line">    queryLimit = 100</span><br><span class="line">    maxWait = 5000</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># redis store property</span></span></span><br><span class="line">  redis &#123;</span><br><span class="line">    host = &quot;127.0.0.1&quot;</span><br><span class="line">    port = &quot;6379&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">    database = &quot;0&quot;</span><br><span class="line">    minConn = 1</span><br><span class="line">    maxConn = 10</span><br><span class="line">    maxTotal = 100</span><br><span class="line">    queryLimit = 100</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>registry.conf:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class="line">  type = &quot;nacos&quot;  # 注册中心使用nacos</span><br><span class="line">  loadBalance = &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes = 10</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application = &quot;seata-server&quot;  # seata作为注册中心的一个服务，服务名称叫什么</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot; # nacos注册中心地址</span><br><span class="line">    group = &quot;SEATA_GROUP&quot; # 服务分组，不是配置分组</span><br><span class="line">    namespace = &quot;&quot; # 服务注册时的命名空间，不填为默认的public</span><br><span class="line">    cluster = &quot;default&quot; # 不用改</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = &quot;http://localhost:8761/eureka&quot;</span><br><span class="line">    application = &quot;default&quot;</span><br><span class="line">    weight = &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = &quot;localhost:6379&quot;</span><br><span class="line">    db = 0</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    timeout = 0</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:9603&quot;</span><br><span class="line">    application = &quot;default&quot;</span><br><span class="line">    region = &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter = &quot;DefaultDataCenter&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime = &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class="line">  type = &quot;nacos&quot; # 配置中心使用nacos</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot; # nasos配置中心的地址</span><br><span class="line">    namespace = &quot;&quot; # 配置中心的命名空间</span><br><span class="line">    group = &quot;SEATA_GROUP&quot; </span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    appId = &quot;seata-server&quot;</span><br><span class="line">    apolloMeta = &quot;http://192.168.1.204:8801&quot;</span><br><span class="line">    namespace = &quot;application&quot;</span><br><span class="line">    apolloAccesskeySecret = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行sql，导入seata的3张表</li>
</ol>
<p>创建一个数据库seata，这与file.conf文件中的指定属性相同。</p>
<p>导入db_store.sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF <span class="keyword">EXISTS</span> `global_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `global_table` (</span><br><span class="line">	`xid` <span class="type">VARCHAR</span> (<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">	`status` TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`application_id` <span class="type">VARCHAR</span> (<span class="number">32</span>),</span><br><span class="line">	`transaction_service_group` <span class="type">VARCHAR</span> (<span class="number">32</span>),</span><br><span class="line">	`transaction_name` <span class="type">VARCHAR</span> (<span class="number">128</span>),</span><br><span class="line">	`timeout` <span class="type">INT</span>,</span><br><span class="line">	`begin_time` <span class="type">BIGINT</span>,</span><br><span class="line">	`application_data` <span class="type">VARCHAR</span> (<span class="number">2000</span>),</span><br><span class="line">	`gmt_create` datetime,</span><br><span class="line">	`gmt_modified` datetime,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">	KEY `idx_gmt_modified_status` (`gmt_modified`, `status`),</span><br><span class="line">	KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF <span class="keyword">EXISTS</span> `branch_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `branch_table` (</span><br><span class="line">	`branch_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`xid` <span class="type">VARCHAR</span> (<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">	`resource_group_id` <span class="type">VARCHAR</span> (<span class="number">32</span>),</span><br><span class="line">	`resource_id` <span class="type">VARCHAR</span> (<span class="number">256</span>),</span><br><span class="line">	`lock_key` <span class="type">VARCHAR</span> (<span class="number">128</span>),</span><br><span class="line">	`branch_type` <span class="type">VARCHAR</span> (<span class="number">8</span>),</span><br><span class="line">	`status` TINYINT,</span><br><span class="line">	`client_id` <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">	`application_data` <span class="type">VARCHAR</span> (<span class="number">2000</span>),</span><br><span class="line">	`gmt_create` datetime,</span><br><span class="line">	`gmt_modified` datetime,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">	KEY `idx_xid` (`xid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF <span class="keyword">EXISTS</span> `lock_table`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock_table` (</span><br><span class="line">	`row_key` <span class="type">VARCHAR</span> (<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`xid` <span class="type">VARCHAR</span> (<span class="number">96</span>),</span><br><span class="line">	`transaction_id` LONG,</span><br><span class="line">	`branch_id` LONG,</span><br><span class="line">	`resource_id` <span class="type">VARCHAR</span> (<span class="number">256</span>),</span><br><span class="line">	`table_name` <span class="type">VARCHAR</span> (<span class="number">32</span>),</span><br><span class="line">	`pk` <span class="type">VARCHAR</span> (<span class="number">36</span>),</span><br><span class="line">	`gmt_create` datetime,</span><br><span class="line">	`gmt_modified` datetime,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`row_key`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将配置文件导入nacos</li>
</ol>
<p>config.txt是seata各种详细的配置，执行 nacos-config.sh 即可将这些配置导入到nacos，这样就不需要将file.conf和registry.conf放到我们client端的项目中了，需要什么配置就直接从nacos中读取。</p>
<p>config.txt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transport.type=TCP</span><br><span class="line">transport.server=NIO</span><br><span class="line">transport.heartbeat=true</span><br><span class="line">transport.thread-factory.boss-thread-prefix=NettyBoss</span><br><span class="line">transport.thread-factory.worker-thread-prefix=NettyServerNIOWorker</span><br><span class="line">transport.thread-factory.server-executor-thread-prefix=NettyServerBizHandler</span><br><span class="line">transport.thread-factory.share-boss-worker=false</span><br><span class="line">transport.thread-factory.client-selector-thread-prefix=NettyClientSelector</span><br><span class="line">transport.thread-factory.client-selector-thread-size=1</span><br><span class="line">transport.thread-factory.client-worker-thread-prefix=NettyClientWorkerThread</span><br><span class="line">transport.thread-factory.boss-thread-size=1</span><br><span class="line">transport.thread-factory.worker-thread-size=8</span><br><span class="line">transport.shutdown.wait=3</span><br><span class="line"># nacos配置中心和springboot中的值都需要和这里一致</span><br><span class="line">service.vgroup_mapping.my_test_tx_group=default</span><br><span class="line">service.enableDegrade=false</span><br><span class="line">service.disable=false</span><br><span class="line">service.max.commit.retry.timeout=-1</span><br><span class="line">service.max.rollback.retry.timeout=-1</span><br><span class="line">client.async.commit.buffer.limit=10000</span><br><span class="line">client.lock.retry.internal=10</span><br><span class="line">client.lock.retry.times=30</span><br><span class="line">client.lock.retry.policy.branch-rollback-on-conflict=true</span><br><span class="line">client.table.meta.check.enable=true</span><br><span class="line">client.report.retry.count=5</span><br><span class="line">client.tm.commit.retry.count=1</span><br><span class="line">client.tm.rollback.retry.count=1</span><br><span class="line">store.mode=file</span><br><span class="line">store.file.dir=file_store/data</span><br><span class="line">store.file.max-branch-session-size=16384</span><br><span class="line">store.file.max-global-session-size=512</span><br><span class="line">store.file.file-write-buffer-cache-size=16384</span><br><span class="line">store.file.flush-disk-mode=async</span><br><span class="line">store.file.session.reload.read_size=100</span><br><span class="line">store.db.datasource=dbcp</span><br><span class="line"></span><br><span class="line">store.db.datasource=druid</span><br><span class="line">store.db.db-type=mysql</span><br><span class="line">store.db.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true</span><br><span class="line">store.db.user=root</span><br><span class="line">store.db.password=123</span><br><span class="line"></span><br><span class="line">store.db.min-conn=1</span><br><span class="line">store.db.max-conn=3</span><br><span class="line">store.db.global.table=global_table</span><br><span class="line">store.db.branch.table=branch_table</span><br><span class="line">store.db.query-limit=100</span><br><span class="line">store.db.lock-table=lock_table</span><br><span class="line">recovery.committing-retry-period=1000</span><br><span class="line">recovery.asyn-committing-retry-period=1000</span><br><span class="line">recovery.rollbacking-retry-period=1000</span><br><span class="line">recovery.timeout-retry-period=1000</span><br><span class="line">transaction.undo.data.validation=true</span><br><span class="line">transaction.undo.log.serialization=jackson</span><br><span class="line">transaction.undo.log.save.days=7</span><br><span class="line">transaction.undo.log.delete.period=86400000</span><br><span class="line">transaction.undo.log.table=undo_log</span><br><span class="line">transport.serialization=seata</span><br><span class="line">transport.compressor=none</span><br><span class="line">metrics.enabled=false</span><br><span class="line">metrics.registry-type=compact</span><br><span class="line">metrics.exporter-list=prometheus</span><br><span class="line">metrics.exporter-prometheus-port=9898</span><br><span class="line">support.spring.datasource.autoproxy=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用nacos-config.sh将配置导入到nacos的配置中心。</p>
<p>如果nacos-config.sh不是可执行文件，需要增加权限 chmod 777 nacos-config.sh</p>
<p>config存放的目录位于nacos-config.sh的上一级目录。</p>
<ul>
<li>config.txt : /usr/local/seata/seata</li>
<li>config-config.sh : /usr/local/seata/seata/conf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh nacos-config.sh -h localhost -p 8848 -g SEATA_GROUP -t 7ff58f98-79e2-41ad-b96e-a2721c7864af</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>-h: host，默认值 localhost</p>
<p>-p: port，默认值 8848</p>
<p>-g: 配置分组，默认值为 ‘SEATA_GROUP’</p>
<p>-t: 租户信息，对应 Nacos 的命名空间ID字段, 默认值为空 ‘’</p>
<ol start="4">
<li>创建logs文件夹</li>
</ol>
<p>在/usr/local/seata/seata目录下创建文件夹logs，并在logs下创建seata_gc.log文件</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201228214652142.png" alt="image-logs文件夹"></p>
<ol start="5">
<li>启动seata</li>
</ol>
<p>在bin目录下./seata-server.sh启动。</p>
<p>如果启动的时候报内存不足的错误，可以修改seata-server.sh文件，修改其中一行的配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec &quot;$JAVACMD&quot; $JAVA_OPTS -server -Xmx256m -Xms256m -Xmn256m -Xss512k </span><br></pre></td></tr></table></figure>

<p>出现以下提示说明启动成功：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201228214951974.png" alt="image-seata启动"></p>
<p>此时，查看nacos：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201228215112833.png" alt="image-nacos中查看seata服务"></p>
<p>registry.conf的其中一段配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nacos &#123;</span><br><span class="line">    application = &quot;seata-server&quot;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace = &quot;7ff58f98-79e2-41ad-b96e-a2721c7864af&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看nacos的配置中心：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201228215401610.png" alt="image-nacos查看seata的配置"></p>
<h4 id="client端配置"><a href="#client端配置" class="headerlink" title="client端配置"></a>client端配置</h4><ol>
<li>需要使用seata的客户端需要引入依赖，版本依赖于父级POM</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 导入undo_log</li>
</ol>
<ol start="3">
<li>springboot配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span> <span class="comment"># 事务群组（可以每个应用独立取名，也可以使用相同的名字）</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">rm-report-success-enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">rm-table-meta-check-enable:</span> <span class="literal">false</span> <span class="comment"># 自动刷新缓存中的表结构（默认false）</span></span><br><span class="line">    <span class="attr">rm-report-retry-count:</span> <span class="number">5</span> <span class="comment"># 一阶段结果上报TC重试次数（默认5）</span></span><br><span class="line">    <span class="attr">rm-async-commit-buffer-limit:</span> <span class="number">1000</span> <span class="comment"># 异步提交缓存队列长度（默认10000）</span></span><br><span class="line">    <span class="attr">rm:</span></span><br><span class="line">      <span class="attr">lock:</span></span><br><span class="line">        <span class="attr">lock-retry-internal:</span> <span class="number">10</span> <span class="comment"># 校验或占用全局锁重试间隔（默认10ms）</span></span><br><span class="line">        <span class="attr">lock-retry-times:</span>    <span class="number">30</span> <span class="comment"># 校验或占用全局锁重试次数（默认30）</span></span><br><span class="line">        <span class="attr">lock-retry-policy-branch-rollback-on-conflict:</span> <span class="literal">true</span> <span class="comment"># 分支事务与其它全局回滚事务冲突时锁策略（优先释放本地锁让回滚成功）</span></span><br><span class="line">    <span class="attr">tm-commit-retry-count:</span>   <span class="number">3</span> <span class="comment"># 一阶段全局提交结果上报TC重试次数（默认1次，建议大于1）</span></span><br><span class="line">    <span class="attr">tm-rollback-retry-count:</span> <span class="number">3</span> <span class="comment"># 一阶段全局回滚结果上报TC重试次数（默认1次，建议大于1）</span></span><br><span class="line">    <span class="attr">undo:</span></span><br><span class="line">      <span class="attr">undo-data-validation:</span> <span class="literal">true</span> <span class="comment"># 二阶段回滚镜像校验（默认true开启）</span></span><br><span class="line">      <span class="attr">undo-log-serialization:</span> <span class="string">jackson</span> <span class="comment"># undo序列化方式（默认jackson）</span></span><br><span class="line">      <span class="attr">undo-log-table:</span> <span class="string">undo_log</span>  <span class="comment"># 自定义undo表名（默认undo_log）</span></span><br><span class="line">    <span class="attr">log:</span></span><br><span class="line">      <span class="attr">exceptionRate:</span> <span class="number">100</span> <span class="comment"># 日志异常输出概率（默认100）</span></span><br><span class="line">    <span class="attr">support:</span></span><br><span class="line">      <span class="attr">spring-datasource-autoproxy:</span> <span class="literal">true</span> <span class="comment"># 数据源自动代理开关（默认false关闭）</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span> <span class="comment"># TC 集群（必须与seata-server保持一致）</span></span><br><span class="line">    <span class="attr">enable-degrade:</span> <span class="literal">false</span> <span class="comment"># 降级开关</span></span><br><span class="line">    <span class="attr">disable-global-transaction:</span> <span class="literal">false</span> <span class="comment"># 禁用全局事务（默认false）</span></span><br><span class="line">  <span class="attr">transport:</span></span><br><span class="line">    <span class="attr">enable-client-batch-send-request:</span> <span class="literal">true</span> <span class="comment"># 客户端事务消息请求是否批量合并发送（默认true）</span></span><br><span class="line">  <span class="comment"># 注册中心</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="comment"># 配置中心</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">47.96</span><span class="number">.224</span><span class="number">.198</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">7ff58f98-79e2-41ad-b96e-a2721c7864af</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>方法一 你可以通过file.conf来配置使用环境<br>file.conf如以下修改<br>vgroup_mapping.xxxx-fescar-service-group = “default”<br>xxx是你的application名</p>
<p>方法二 通过环境变量改变使用环境配置<br>在启动脚本追加以下命令<br>export SEATA_CONFIG_ENV=default</p>
<p>registry.conf 对应的是 default<br>registry-dev.conf 对应 dev开发环境<br>registry-test.conf 对应 test测试环境<br>registry-prod.conf 对应 prod生产环境</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/21/Mysql/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1.索引的本质"></a>1.索引的本质</h3><p>如果发现一条执行很慢的sql,首先考虑<code>查执行计划,看索引是否命中。</code></p>
<p><code>索引</code>是帮助Mysql高效获取数据的<code>排好序的数据结构</code>。</p>
<p>索引的数据结构:</p>
<ol>
<li>哈希表<ul>
<li>对索引的key进行一次hash运算就可以定位出数据存储的位置</li>
<li>很多时候hash索引要比B+Tree索引更高效</li>
<li>仅能满足”=”,”IN”的数据查找,<code>不支持范围查询</code></li>
</ul>
</li>
<li>二叉树(如果数据是递增的,会形成单支数,影响查询效率,因为索引的节点也是存储在磁盘上)</li>
<li>B-Tree</li>
<li>红黑树(又叫二叉平衡树,在数据量大的时候,依然没有解决数高的问题)</li>
<li>B+Tree:<ul>
<li>非叶子节点不存储data,只存储索引(冗余)和索引在磁盘的地址,可以放更多的索引</li>
<li>叶子节点包含所有索引字段</li>
<li>叶子节点用指针连接,提高区间访问的性能</li>
<li>每一页的默认大小是16K,</li>
<li>Mysql高版本的时候,非叶子节点保存在内存中,不需要去加载IO。只有加载叶子节点的时候,才会去加载IO</li>
</ul>
</li>
</ol>
<h3 id="2-索引的存储"><a href="#2-索引的存储" class="headerlink" title="2.索引的存储"></a>2.索引的存储</h3><blockquote>
<p>Mysql在磁盘中的存储文件：</p>
</blockquote>
<p>如果是<code>MYISAM</code>存储引擎,在data目录下会有3个文件:</p>
<p>.frm:存储表结构</p>
<p>.myd:存储数据的文件,文件后缀以<code>存储引擎+d(data)</code>结尾</p>
<p>.myi:如果建索引,则存在该文件存储索引。文件后缀以<code>存储引擎+i(index)</code>结尾。</p>
<p>如果是<code>Innodb</code>引擎,由于数据和索引是通过B+Tree组织的,在data目录下会有2个文件:</p>
<p>.frm:存储表结构</p>
<p>.ibd:存储数据和索引</p>
<blockquote>
<p>MYISAM和Innodb索引的查找</p>
</blockquote>
<p>聚集索引包含了完整的数据记录。Innodb的主键索引就是聚集索引。</p>
<p>Innodb存储引擎,如果是<code>主键索引树</code>,行数据是存储在索引树的叶子节点的。在进行数据查找的时候,可以直接在内存中查找到数据,不需要通过IO到磁盘查找。如果是<code>普通索引树</code>,普通索引树的叶子节点存储的是主键的值,可能需要通过<code>回表</code>操作到主键索引树进行查找数据。</p>
<p>MYISAM存储引擎,数据和索引是存在不同的文件中,查找数据是先通过.myi查找到数据所在行的内存地址,再通过内存地址到.myd文件中查找数据。</p>
<blockquote>
<p>聚集索引和非聚集索引</p>
</blockquote>
<p>聚集索引包含了完整的数据记录。如Innodb的主键索引,叶子节点存储的是完整的行数据,它就是聚集索引。</p>
<p>而Innodb的普通索引,叶子节点存储的是主键的值,或者MYISAM引擎,数据和索引是存储在不同的文件,它就是非聚集索引。</p>
<p><code>区分聚集索引和非聚集索引主要就是看是否包含了完整的数据记录。</code></p>
<blockquote>
<p>为什么建议Innodb表必须建主键,并且推荐使用整形的自增主键?</p>
</blockquote>
<p>Innodb的存储引擎,是通过B+Tree来组织数据的。如果没有建主键,Innodb引擎会自动找一个<code>唯一的列</code>作为主键。如果找不到唯一的列,Innodb将会维护一个6字节的rowid作为主键。如果我们自己建主键,Innodb就不会进行这些操作,从而<code>提高性能</code>。</p>
<p>使用整形存储,比使用字符存储,更加节省存储空间。而且在查找数据进行比较的时候,整形的比较比字符串(uuid)的效率高,因为字符串还要转换成ASCII来比较。</p>
<p>使用自增主键,插入数据的时候,直接在最后添加数据,而不会产生页分裂的情况。</p>
<blockquote>
<p>为什么非主键索引结构叶子节点存储的是主键值?</p>
</blockquote>
<p>一致性和节省存储空间。</p>
<blockquote>
<p>为什么B+Tree的非叶子节点不存数据?</p>
</blockquote>
<p>索引树的每个节点存储的是页,而页是有固定大小的。如果在每个节点中存数据,那么一个页能存储的索引就少了,从而增加了树高,增加了查找数据的效率。</p>
<h3 id="3-innodb后台进程"><a href="#3-innodb后台进程" class="headerlink" title="3.innodb后台进程"></a>3.innodb后台进程</h3><p>innodb存储引擎是<code>多线程</code>的模型,后台进程作用有：</p>
<ol>
<li>负责刷新内存池中的数据,保证缓冲池中的数据是最近的数据</li>
<li>将已修改的数据文件刷新到磁盘中</li>
</ol>
<p>后台进程可以分为以下4类:</p>
<ol>
<li>Master Thread : 负责将缓冲池中的数据<code>异步</code>刷新到磁盘,保证数据的一致性。</li>
<li>IO Thread : 负责写IO请求的回调。在Innodb1.2以后的版本中,有4个read thread,4个write thread,1个log thread,1个insert buffer thread.可以通过<code>show variables like &#39;%innodb_%io_thread&#39;</code>来查看threads的数量。</li>
<li>Purge Thread : 负责UNDO页的回收。在Innodb1.1版本之前,UNDO页的回收由Master Thread来完成。在Innodb1.2版本后,支持多个Purge Thread,可以在配置文件中设置<code>innodb_purge_threads=4</code>来独立启动Purge Thread.通过<code>show variables like &#39;%innodb_purge_thread%&#39;</code>可以查看Purge Thread的数量。</li>
<li>Page Cleaner Thread : 负责脏页数据的刷新。在Innodb1.1版本之前,脏页的回收由Master Thread来完成。在Innodb1.2版本后,脏页数据的刷新放到独立的线程中执行,从而减轻Master Thread的工作,提高Innodb引擎的性能。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>路由.md</title>
    <url>/2020/12/06/Vue/router/</url>
    <content><![CDATA[<h3 id="切换路由"><a href="#切换路由" class="headerlink" title="切换路由"></a>切换路由</h3><ul>
<li>导入router，调用push方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    const currentRouter = window.location.pathname</span><br><span class="line">    function changeView () &#123;</span><br><span class="line">      router.push(&#x27;/about&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentRouter,</span><br><span class="line">      changeView</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong></p>
<ul>
<li>当前访问路径可以通过window.location.pathname 获取</li>
<li>import的时候，如果目录下只有一个index.js，可以写成import router from ‘./router’ 而不用写成 import router from ‘./router/index.js’</li>
</ul>
<h3 id="router-view监听子组件的事件"><a href="#router-view监听子组件的事件" class="headerlink" title="router-view监听子组件的事件"></a>router-view监听子组件的事件</h3><p>如果有多层组件，子组件的事件只能一层层往上冒泡，顶层不能直接监听到子组件的事件。</p>
<p>栗子：App.vue 包含了Home.vue，Home.vue包含了组件swiper</p>
<p>1.swiper向Home.vue组件传递事件img-click</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img :src=&quot;src&quot; :alt=&quot;alt&quot; class=&quot;swiper&quot; @click=&quot;$emit(&#x27;img-click&#x27;)&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;src&#x27;, &#x27;alt&#x27;],</span><br><span class="line">  name: &#x27;swiper&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2.Home.vue监听到img-click事件，向App.vue传递事件home-click</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;swiper :src=&quot;pic&quot; :alt=&quot;漂亮的图片&quot; @img-click=&quot;onHomeClick&quot;&gt;&lt;/swiper&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// @ is an alias to /src</span><br><span class="line">import swiper from &#x27;../components/swiper&#x27;</span><br><span class="line">import pic from &#x27;@/assets/beautiful.jpg&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    function onHomeClick () &#123;</span><br><span class="line">      console.log(&#x27;接收到img-click事件&#x27;)</span><br><span class="line">      context.emit(&#x27;home-click&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      pic,</span><br><span class="line">      onHomeClick</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    // eslint-disable-next-line vue/no-unused-components</span><br><span class="line">    swiper</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.App.vue不能直接监听到img-click事件，只能监听Home.vue的home-click事件，监听到事件后，路由跳转到/about页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;changeView&quot;&gt;点击切换页面&lt;/button&gt;</span><br><span class="line">    &lt;router-link to=&quot;currentRouter&quot; &gt;&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;router-view @home-click=&quot;onImgClick&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    function onImgClick () &#123;</span><br><span class="line">      console.log(&#x27;接收到home-click事件&#x27;)</span><br><span class="line">      router.push(&#x27;/about&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const currentRouter = window.location.pathname</span><br><span class="line">    function changeView () &#123;</span><br><span class="line">      router.push(&#x27;/about&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentRouter,</span><br><span class="line">      changeView,</span><br><span class="line">      onImgClick</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ul>
<li>路由的监听事件是写在router-view中，而不是router-link</li>
</ul>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul>
<li>配置路由的children属性，是一个数组</li>
<li>在页面中使用<router-view/>才能显示子页面</li>
<li>使用children属性配置的路由，只有在父页面的router-view才能显示</li>
</ul>
<p>栗子：在Detail页面中，跳转到Detail页面的子页面SubDetail</p>
<p>1.Detail.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is an about page&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;goSubPage&quot;&gt;点击去到子页面&lt;/button&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import router from &#x27;@/router&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    // eslint-disable-next-line no-unused-vars</span><br><span class="line">    function goSubPage () &#123;</span><br><span class="line">      router.push(&#x27;/detail/sub-detail&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      goSubPage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.SubDetail.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;this is sub-detail page&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;SubDetail&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>3.路由配置</p>
<p><strong>这里配置的sub-detail只有在/detail页面的<router-view/>才能显示。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/detail&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/Detail.vue&#x27;</span>),</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 这里不能加/</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;sub-detail&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: SubDetail,</span><br><span class="line">        <span class="attr">component</span>: SubDetail</span><br><span class="line">        <span class="comment">// 两种写法都可以</span></span><br><span class="line">        <span class="comment">// component: () =&gt; import(&#x27;../views/SubDetail&#x27;)</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>一种更好的做法是：</p>
<p>​    不配置children属性，而是配置成平行的。子组件通过传递同一个自定义事件到最上层，通过自定义事件将路由传递到最上层，统一由最上层的事件进行router的跳转。</p>
<p>栗子：App.vue是最上层，监听着子组件的home-click事件。</p>
<p>Home.vue 和 Detail.vue 都可以通过向App.vue传递home-click自定义事件，带上自己跳转的路由参数，统一由App.vue进行路由的跳转。</p>
<p>1.App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view @home-click=&quot;onImgClick&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    function onImgClick (event) &#123;</span><br><span class="line">      console.log(&#x27;接收到home-click事件&#x27;)</span><br><span class="line">      router.push(event)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      onImgClick</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Home.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;swiper :src=&quot;pic&quot; :alt=&quot;漂亮的图片&quot; @img-click=&quot;onHomeClick&quot;&gt;&lt;/swiper&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> setup (props, context) &#123;</span><br><span class="line">    function onHomeClick () &#123;</span><br><span class="line">      console.log(&#x27;接收到img-click事件&#x27;)</span><br><span class="line">	  // 传递/detail</span><br><span class="line">      context.emit(&#x27;home-click&#x27;, &#x27;/detail&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      pic,</span><br><span class="line">      onHomeClick</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>3.Detail.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;goSubPage&quot;&gt;点击去到子页面&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">   	// 传递/sub-detail</span><br><span class="line">    function goSubPage () &#123;</span><br><span class="line">      context.emit(&#x27;home-click&#x27;, &#x27;/sub-detail&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      goSubPage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>1.定义路由参数 :参数名 ， 如果定义了参数而不传参，会找不到路由，出现空白页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/detail/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Detail</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2.传递参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onHomeClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;接收到img-click事件&#x27;</span>)</span><br><span class="line">	context.emit(<span class="string">&#x27;home-click&#x27;</span>, <span class="string">&#x27;/detail/3&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.接收参数</p>
<p>通过router可以获取到当前路由currentRoute，再通过value.params.参数名获取路由参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(router.currentRoute.value.params.id)</span><br></pre></td></tr></table></figure>



<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>可以通过name来当路由，写法是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.emit(<span class="string">&#x27;home-click&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 没有参数时，传递空对象</span></span><br><span class="line"> context.emit(<span class="string">&#x27;home-click&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;SubDetail&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>跳转路由时可以直接将子组件传递的对象当为参数。但是需要保证每个子组件传递的参数格式一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">onImgClick</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;接收到home-click事件&#x27;</span>)</span><br><span class="line">     <span class="built_in">console</span>.log(event)</span><br><span class="line">     router.push(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组件切换的几种方法"><a href="#组件切换的几种方法" class="headerlink" title="组件切换的几种方法"></a>组件切换的几种方法</h3><ul>
<li>使用router</li>
<li>使用v-if隐藏显示</li>
<li>使用<component>动态组件</li>
</ul>
<h3 id="动态组件和缓存组件的状态"><a href="#动态组件和缓存组件的状态" class="headerlink" title="动态组件和缓存组件的状态"></a>动态组件和缓存组件的状态</h3><p><component>的is属性能根据组件的名称，动态切换组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;changeView(&#x27;keep&#x27;)&quot;&gt;切换keep组件&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;changeView(&#x27;stat&#x27;)&quot;&gt;切换stat组件&lt;/button&gt;</span><br><span class="line">  &lt;keep-alive exclude=&quot;keep&quot;&gt;</span><br><span class="line">  	&lt;component :is=&quot;currentPage&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import keep from &#x27;@/components/keep.vue&#x27;</span><br><span class="line">import stat from &#x27;@/components/stat.vue&#x27;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    const currentPage = ref(&#x27;keep&#x27;)</span><br><span class="line">    function changeView (c) &#123;</span><br><span class="line">      this.currentPage = c</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentPage,</span><br><span class="line">      changeView</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    keep,</span><br><span class="line">    stat</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>currentPage属性控制着应该显示哪个组件。通过按钮点击动态改变currentPage的值，达到动态切换组件。</p>
<p><strong>注意，这里的currentPage应该是响应式对象才能切换。</strong></p>
<p>当组件切换后，原有组件的值不会被保存。此时可以使用keep-alive来缓存切换前组件的值。</p>
<p>keep-alive有两个属性include和exclude，可以根据组件的name来包含或排除应该缓存的组件。</p>
<p><strong>注意，这里组件的值是大小写敏感的。多个组件的值可以使用，分割。</strong></p>
<h3 id="全局状态变量传参"><a href="#全局状态变量传参" class="headerlink" title="全局状态变量传参"></a>全局状态变量传参</h3><p><strong>在store中定义方法，在其他组件中使用store.commit方法触发方法，并传递参数。</strong></p>
<p>方法的第一个参数为store中定义的state</p>
<ul>
<li>传递单个参数</li>
</ul>
<p>store:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    getParams (state, url) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(url)</span><br><span class="line">      state.url = url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.vue:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeView</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.currentPage = url</span><br><span class="line">    <span class="keyword">const</span> id = <span class="number">3</span></span><br><span class="line">    store.commit(<span class="string">&#x27;getParams&#x27;</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传递多个参数</li>
</ul>
<p>store：多个参数使用payload接收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    getParams (state, payload) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(state)</span><br><span class="line">      <span class="built_in">console</span>.log(payload.id)</span><br><span class="line">      <span class="built_in">console</span>.log(payload.url)</span><br><span class="line">      state.url = payload.url</span><br><span class="line">      state.id = payload.id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>App.vue：commit的时候使用对象传递多个参数，这里使用的是ES6的语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeView</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.currentPage = url</span><br><span class="line">    <span class="keyword">const</span> id = <span class="number">3</span></span><br><span class="line">    store.commit(<span class="string">&#x27;getParams&#x27;</span>, &#123;</span><br><span class="line">        url,</span><br><span class="line">        id</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commit的参数也能写成一个对象的形式，使用type属性指明要触发的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeView</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.currentPage = url</span><br><span class="line">    <span class="keyword">const</span> id = <span class="number">3</span></span><br><span class="line">    store.commit(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;getParams&#x27;</span>,</span><br><span class="line">        id,</span><br><span class="line">        url</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过全局参数切换路由"><a href="#通过全局参数切换路由" class="headerlink" title="通过全局参数切换路由"></a>通过全局参数切换路由</h3><p>之前的切换路由的方法，如果一个页面包含很多子组件，只能一层层往上传递事件。</p>
<p>使用全局参数，可以实现切换路由。思路如下：</p>
<ul>
<li>在子组件中修改全局参数的值</li>
<li>在父组件监听全局参数的值，一旦发生改变，通过router.push完成路由切换</li>
</ul>
<p>1.子组件Home.vue修改全局参数url的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onHomeClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接修改全局变量url</span></span><br><span class="line">    store.state.url = <span class="string">&#x27;/detail&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接修改state的方式太粗暴了，可以通过传参的方式改变全局参数的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onHomeClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接修改全局变量url</span></span><br><span class="line">    store.commit(<span class="string">&#x27;changeView&#x27;</span>, <span class="string">&#x27;/detail&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，在全局参数store的文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        changeView (state, url) &#123;</span><br><span class="line">            state.url = url</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">modules</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>2.父组件中不再使用事件，直接监听全局参数的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch(<span class="function">() =&gt;</span> store.state.url, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.state.url)</span><br><span class="line">    router.push(newVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以通过监听computed properties：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetRoute = computed(<span class="function">() =&gt;</span> store.state.url)</span><br><span class="line">watch(targetRoute, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.state.url)</span><br><span class="line">    router.push(newVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="带参数的全局参数路由跳转"><a href="#带参数的全局参数路由跳转" class="headerlink" title="带参数的全局参数路由跳转"></a>带参数的全局参数路由跳转</h3><p>设置一个对象类型的全局参数，其格式与router.push的参数相同。当子组件设置全局参数时，直接监听全局参数的改变，跳转路由。</p>
<p>store:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">routerParams</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    changeView (state, payload) &#123;</span><br><span class="line">      state.routerParams = payload.routerParams</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>子组件设置全局参数，参数的形式与router.push的参数格式一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onHomeClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.commit(<span class="string">&#x27;changeView&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">routerParams</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">            <span class="attr">params</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在App.vue中监听全局参数的变化，跳转路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch(<span class="function">() =&gt;</span> store.state.routerParams, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">    router.push(newVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举.md</title>
    <url>/2020/12/03/Java/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h3><blockquote>
<p>枚举类 和 枚举类型混淆</p>
</blockquote>
<p>​    <strong>如下代码所示，AuditType是枚举类，AuditType中定义的PURCHASE、TENDER等是枚举类型。</strong></p>
<ul>
<li>values()获取枚举类下所有的枚举类型，返回一个枚举类型的数组</li>
<li>valueof()通过枚举的名字获取一个枚举类型。如果不存在给定名字的枚举类型，会抛出异常java.lang.IllegalArgumentException: No enum constant enumeration.AuditType.PURCHASE1</li>
<li>name()获取枚举类型的名称，与toString方法效果相同</li>
<li>ordinal()返回一个int值，代表枚举类型在声明时的次序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AuditType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PURCHASE(<span class="string">&quot;采购申请&quot;</span>),</span><br><span class="line">    TENDER(<span class="string">&quot;招标文件&quot;</span>),</span><br><span class="line">    CONTRACT(<span class="string">&quot;合同&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    AuditType(String description)&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取枚举的次序,从0开始  0</span></span><br><span class="line">        System.out.println(AuditType.PURCHASE.ordinal());</span><br><span class="line">        <span class="comment">// 获取枚举的名字  PURCHASE</span></span><br><span class="line">        System.out.println(AuditType.PURCHASE.name());</span><br><span class="line">        <span class="comment">// 枚举类实现了Comparator接口,按照次序比较 1</span></span><br><span class="line">        System.out.println(AuditType.TENDER.compareTo(PURCHASE));</span><br><span class="line">        <span class="comment">//values()获取所有类型的枚举 和 枚举的比较  true</span></span><br><span class="line">        <span class="keyword">for</span> (AuditType type : AuditType.values()) &#123;</span><br><span class="line">            System.out.println(AuditType.PURCHASE.equals(type));</span><br><span class="line">            System.out.println(AuditType.PURCHASE == type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取定义枚举的枚举类 class enumeration.AuditType</span></span><br><span class="line">        System.out.println(AuditType.PURCHASE.getDeclaringClass());</span><br><span class="line">        <span class="comment">// 通过枚举名字获取枚举类型</span></span><br><span class="line">        AuditType purchaseType = AuditType.valueOf(<span class="string">&quot;PURCHASE&quot;</span>);</span><br><span class="line">        System.out.println(purchaseType == AuditType.PURCHASE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小小知识点"><a href="#小小知识点" class="headerlink" title="小小知识点"></a>小小知识点</h3><ul>
<li>枚举默认继承了Enum类，并实现了Serializalbe和Comparable接口。所以它具有CompareTo()方法</li>
<li>编译器会提供equals()和hashcode()方法，所以枚举可以通过equals或==来进行比较</li>
<li>枚举类必须在定于方法和属性之前定义枚举类型，否则在编译时就会报错</li>
<li>枚举类的构造方法默认就是private的</li>
<li>只能在枚举类内部使用构造函数，也就是说不能通过构造器传参给枚举类</li>
<li>在Switch中使用枚举类型，可以直接使用枚举类型。比如使用PURCHASE而不是AuditType.PURCHASE</li>
<li>values()方法是编译器添加的static方法，在Enum类中并没有。如果向上转型为Enum类型，不能使用values()方法，可以通过Class的getEnumConstants()方法获取所有的枚举类型</li>
<li>valueOf()方法也是编译器添加的static方法，虽然在Ecum类中有valueOf方法，但它是两个参数的，而枚举类的ValueOf()是一个参数的</li>
<li>Enum类实现了Serializalbe和Comparable接口</li>
<li>枚举类被final修饰，无法被继承</li>
<li></li>
</ul>
<h3 id="Enum的“values”方法"><a href="#Enum的“values”方法" class="headerlink" title="Enum的“values”方法"></a>Enum的“values”方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enum e = AuditType.PURCHASE;</span><br><span class="line"><span class="keyword">for</span> (Enum enumConstant : e.getClass().getEnumConstants()) &#123;</span><br><span class="line">    System.out.println(enumConstant.name());</span><br><span class="line">    System.out.println(enumConstant.equals(AuditType.PURCHASE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>ref.md</title>
    <url>/2020/12/01/Vue/ref/</url>
    <content><![CDATA[<h3 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h3><p>废话少说，上栗子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;</span><br><span class="line">    &#123;&#123;age&#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;change&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    const &#123; createApp, ref, reactive&#125; = Vue</span><br><span class="line"></span><br><span class="line">    let age =ref(18)</span><br><span class="line"></span><br><span class="line">    const app = &#123;</span><br><span class="line">        setup()&#123;</span><br><span class="line">            function change()&#123;</span><br><span class="line">                // 因为age是全局变量,这里才能访问到</span><br><span class="line">                console.log(age)</span><br><span class="line">                // 因为age是ref包装的响应式对象,获取值需要.value</span><br><span class="line">                console.log(age.value)</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            return &#123;</span><br><span class="line">                age,</span><br><span class="line">                change</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createApp(app).mount(&quot;#container&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201201224014403.png" alt="image-执行结果1"></p>
<p>知识点：</p>
<ul>
<li>ref可以将基本类型的值包装成响应式对象，获取对象的值需要通过.value的形式</li>
<li>在template中渲染ref包装的响应式对象不需要通过.value，Vue会自动解析。</li>
<li>通过_v_isRef字段可以判断是否ref包装的响应式对象。也可以通过Vue对象中的isRef方法来判断</li>
<li>只有响应式对象才会进行双向绑定</li>
<li>v-model只能用于input、textarea、select</li>
<li>Vue2.5使用defineProperty实现响应式对象，Vue3.0使用Proxy实现响应式对象</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ref</tag>
      </tags>
  </entry>
  <entry>
    <title>watch.md</title>
    <url>/2020/11/29/Vue/watch/</url>
    <content><![CDATA[<h3 id="watch的写法-gt-Vue2"><a href="#watch的写法-gt-Vue2" class="headerlink" title="watch的写法 -&gt; Vue2"></a>watch的写法 -&gt; Vue2</h3><p>1.通过watch对象，指定要监听的属性为方法名称，方法有两个参数newVal，oldValue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">		firstName(newVal,oldVal)&#123;</span><br><span class="line">			this.fullName = newVal + this.lastName</span><br><span class="line">		&#125;,</span><br><span class="line">		lastName(newVal,oldVal)&#123;</span><br><span class="line">			this.fullName = this.firstName + newVal</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过钩子函数，this.$watch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">		this.$watch(&#x27;firstName&#x27;,(newVal,oldVal) =&gt; &#123;</span><br><span class="line">			this.fullName = newVal + this.lastName</span><br><span class="line">		&#125;)</span><br><span class="line">		this.$watch(&#x27;lastName&#x27;,(newVal,oldVal) =&gt; &#123;</span><br><span class="line">			this.fullName = this.firstName + newVal</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch写法-gt-Vue3"><a href="#watch写法-gt-Vue3" class="headerlink" title="watch写法 -&gt; Vue3"></a>watch写法 -&gt; Vue3</h3><blockquote>
<p>监听对象的一个属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; createApp, ref ,reactive, watch&#125; = Vue</span><br><span class="line"></span><br><span class="line">    let firstName = ref(&#x27;&#x27;)</span><br><span class="line">    let lastName = ref(&#x27;&#x27;)</span><br><span class="line">    let fullName = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">    const rootComponent = &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        watch(firstName,(newVal,oldVal) =&gt; &#123;</span><br><span class="line">            console.log(newVal)</span><br><span class="line">                fullName.value = newVal + lastName.value</span><br><span class="line">        &#125;);</span><br><span class="line">        watch(lastName,(newVal) =&gt; &#123;</span><br><span class="line">            console.log(newVal)</span><br><span class="line">                fullName.value = firstName.value + newVal</span><br><span class="line">        &#125;)</span><br><span class="line">            return &#123;</span><br><span class="line">            firstName,</span><br><span class="line">            lastName,</span><br><span class="line">            fullName,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>监听对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; createApp, ref ,reactive, watch&#125; = Vue</span><br><span class="line"></span><br><span class="line">    const name = reactive(&#123;</span><br><span class="line">        firstName: &quot;&quot;,</span><br><span class="line">        lastName:&quot;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let fullName = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">    const rootComponent = &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        // 只要对象的属性变化,整个对象也会变化</span><br><span class="line">        watch(name,(newValue) =&gt; &#123;</span><br><span class="line">            // 监听的是一个对象,newVal是一个Proxy对象</span><br><span class="line">            console.log(newValue)</span><br><span class="line">                fullName.value = name.firstName + name.lastName</span><br><span class="line">        &#125;)</span><br><span class="line">            return &#123;</span><br><span class="line">            name,</span><br><span class="line">            fullName,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>reactive包装的响应式对象是嵌套的。对象中的属性也会被包装成响应式对象，因此对象的属性变化也会进行双向绑定。</li>
<li></li>
</ul>
<blockquote>
<p>监听对象的某个属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	const &#123; createApp, ref ,reactive, watch&#125; = Vue</span><br><span class="line"></span><br><span class="line">	const name = reactive(&#123;</span><br><span class="line">		firstName: &quot;&quot;,</span><br><span class="line">		lastName:&quot;&quot;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	let fullName = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">	const rootComponent = &#123;</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// 监听对象中的某个属性</span><br><span class="line">			watch(() =&gt; name.firstName,(newValue) =&gt; &#123;</span><br><span class="line">				// 监听的是一个对象,newVal是一个Proxy对象</span><br><span class="line">				console.log(newValue)</span><br><span class="line">				fullName.value = newValue + name.lastName</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line">			watch(() =&gt; name.lastName,(newVal) =&gt; &#123;</span><br><span class="line">				fullName.value = name.firstName + newVal</span><br><span class="line">			&#125;)</span><br><span class="line">			return &#123;</span><br><span class="line">				name,</span><br><span class="line">				fullName,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="computed的使用"><a href="#computed的使用" class="headerlink" title="computed的使用"></a>computed的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; createApp, ref ,reactive, watch, computed&#125; = Vue</span><br><span class="line"></span><br><span class="line">	const firstName = ref(&#x27;&#x27;)</span><br><span class="line">	const lastName = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	const rootComponent = &#123;</span><br><span class="line">		setup()&#123;</span><br><span class="line">			const fullName = computed(() =&gt; firstName.value + lastName.value)</span><br><span class="line">			console.log(fullName)</span><br><span class="line">			return &#123;</span><br><span class="line">				firstName,</span><br><span class="line">				lastName,</span><br><span class="line">				fullName</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>computed也是需要return的</li>
<li>computed的返回值是只读的，它是一个对象</li>
</ul>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201202214941679.png" alt="image-computed返回的对象"></p>
<h3 id="computed的setter方法"><a href="#computed的setter方法" class="headerlink" title="computed的setter方法"></a>computed的setter方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const firstName = ref(&#x27;1&#x27;)</span><br><span class="line">	const lastName = ref(&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	const rootComponent = &#123;</span><br><span class="line">		setup()&#123;</span><br><span class="line">			const fullName = computed(&#123;</span><br><span class="line">				get : () =&gt; firstName.value + lastName.value,</span><br><span class="line">				set : (value) =&gt; lastName.value = value</span><br><span class="line">			&#125;)</span><br><span class="line">			// 加了setter,fullName才可以修改。而firstName和lstName本身就可以进行修改,不需要setter</span><br><span class="line">			// 修改fullName,最终的值取决于setter的逻辑</span><br><span class="line">			// firstName.value = 7  72</span><br><span class="line">			// fullName.value = &#x27;8&#x27;;   18</span><br><span class="line"></span><br><span class="line">			return &#123;</span><br><span class="line">				firstName,</span><br><span class="line">				lastName,</span><br><span class="line">				fullName</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean Validation 验证枚举值.md</title>
    <url>/2020/11/02/SpringBoot/Bean%20Validation%20%E9%AA%8C%E8%AF%81%E6%9E%9A%E4%B8%BE%E5%80%BC/</url>
    <content><![CDATA[<h3 id="自定义注解验证枚举类型的值"><a href="#自定义注解验证枚举类型的值" class="headerlink" title="自定义注解验证枚举类型的值"></a>自定义注解验证枚举类型的值</h3><p>使用场景：在前后端分离的开发中，如果后端的一个参数对应的是一个枚举类型的值，前端是无法传递枚举值的。</p>
<p>只能通过与后端约定好的格式进行传递。比如后端定义枚举BooleanEumn：1 -&gt; 是，0 -&gt; 否。</p>
<p>但如果前端不按照约定传参，比如传值2，就会发生错误。</p>
<p>此时，可以通过自定义BeanValidation的注解来校验枚举值。需要指定枚举类和校验的方法即可。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ol>
<li>要求校验方法是静态方法(反射无法调用枚举的实例方法)。如果想使用实例方法也行，需要修改反射的invoke方法。</li>
</ol>
<p>静态方法：Boolean result = (Boolean)method.invoke(null, value);</p>
<p>实例方法：Boolean result = (Boolean)method.invoke(enumClass.newInstance(), value</p>
<ol start="2">
<li>原则上校验值的类型要和校验方法的类型一致，都为包装类型。但在Validator中做了兼容，如果存在普通类型形参的校验方法，也可以被调用。</li>
</ol>
<p>枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BooleanEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    NO(<span class="number">0</span>,<span class="string">&quot;否&quot;</span>),</span><br><span class="line">    YES(<span class="number">1</span>,<span class="string">&quot;是&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existed</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(BooleanEnum.values()).anyMatch(t -&gt; t.value == value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BooleanEnum(<span class="keyword">int</span> value,String description)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义校验注解：使用内部类的方式实现Validator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/01 21:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 校验是否是枚举值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumValue.EnumValueValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;参数有误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Enum&lt;?&gt;&gt; enumClass();</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">enumMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EnumValueValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EnumValue</span>,<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Enum&lt;?&gt;&gt; enumClass;</span><br><span class="line"></span><br><span class="line">        String enumMethod;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EnumValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.enumClass = constraintAnnotation.enumClass();</span><br><span class="line">            <span class="keyword">this</span>.enumMethod = constraintAnnotation.enumMethod();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Object value, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 标记注解的值为空,不进行校验</span></span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有指定注解的校验类不进行校验</span></span><br><span class="line">            <span class="keyword">if</span>(enumClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取校验值的class</span></span><br><span class="line">            Class&lt;?&gt; valueClass = value.getClass();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反射获取方法不会进行自动拆装箱,如果不存在与valueClass相同类型的形参会报错</span></span><br><span class="line">                    method = enumClass.getMethod(enumMethod, valueClass);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="comment">// 获取不到包装类型的方法,尝试获取基本类型参数的方法</span></span><br><span class="line">                    method = enumClass.getMethod(enumMethod,transPrimitiveType(valueClass));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是不是静态方法</span></span><br><span class="line">                <span class="keyword">if</span>(!Modifier.isStatic(method.getModifiers()))&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">30006</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验方法的返回值</span></span><br><span class="line">                Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果校验方法的返回值不是boolean类型或Boolean,抛出异常</span></span><br><span class="line">                <span class="keyword">if</span>(!Boolean.TYPE.equals(returnType) || !<span class="keyword">boolean</span>.class.equals(returnType))&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">30001</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Boolean result = (Boolean)method.invoke(<span class="keyword">null</span>, value);</span><br><span class="line">                <span class="comment">// 避免Boolean返回的是null</span></span><br><span class="line">                <span class="keyword">return</span> result == <span class="keyword">null</span> ? <span class="keyword">false</span> : result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">30005</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由于实现ConstraintValidator&lt;EnumValue,Object&gt;接口中指明注解的值是Object类型</span></span><br><span class="line"><span class="comment">         * 也就是参数值的Class一定是包装类型的,如果验证方法中存在基本类型的方法,通过反射获取方法会抛出异常</span></span><br><span class="line"><span class="comment">         * 此方法对包装类的Class进行转换基本类型,这样在验证方法中可以调用基本类型和包装类型的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> valueClass 包装类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 基本类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt; transPrimitiveType(Class&lt;?&gt; valueClass)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">int</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Boolean.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">boolean</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Byte.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">byte</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Short.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> Short.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Long.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">long</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Float.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">float</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Double.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">double</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.class.equals(valueClass))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">char</span>.class;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Positive</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> Long spuId;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>校验</tag>
      </tags>
  </entry>
  <entry>
    <title>编程思考.md</title>
    <url>/2020/10/24/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="应该抛出异常还是提前return？"><a href="#应该抛出异常还是提前return？" class="headerlink" title="应该抛出异常还是提前return？"></a>应该抛出异常还是提前return？</h3><p>业务场景：更新状态和更新sku库存在同一事务中，只要任何一个操作发送异常，就需要回滚数据。</p>
<p>分析为什么result != 1的时候，可以使用retutn？</p>
<p>更新订单状态失败的情况有2种：</p>
<ol>
<li><p>执行sql的时候发送了异常</p>
</li>
<li><p>sql正常执行，但受影响的行为0(未达到更新条件)</p>
</li>
</ol>
<p>第一种情况，发送了异常，事务是会回滚数据的。</p>
<p>第二种情况，受影响的行为0，实际上相当于什么操作都没执行，此时不需要依靠事务的回滚，提前return方法的执行即可，调用方法前后，数据并没有发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新订单状态 待支付 -&gt; 取消</span></span><br><span class="line"><span class="keyword">int</span> result = orderRepository.cancelOrder(userId, orderId);</span><br><span class="line"><span class="comment">// 如果订单状态没更新成功，则不去更新库存了</span></span><br><span class="line"><span class="comment">// 订单的状态没更新成功有2中情况：</span></span><br><span class="line"><span class="comment">// 1.发生了异常</span></span><br><span class="line"><span class="comment">// 2.没有发生异常，但是执行影响的行数为0，其实是相当于什么都没有操作的</span></span><br><span class="line"><span class="keyword">if</span>(result != <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Order order = orderRepository.findByUserIdAndId(userId, orderId)</span><br><span class="line">    .orElseThrow(() -&gt; <span class="keyword">new</span> NotFoundException(<span class="number">30008</span>));</span><br><span class="line"><span class="comment">// 更新sku库存</span></span><br><span class="line">order.getSnapItems().forEach(sku -&gt; skuRepository.recoverStock(sku.getId(),sku.getCount()));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8日期时间.md</title>
    <url>/2020/10/18/Java/Java8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h3 id="LocalDate、LocalTime"><a href="#LocalDate、LocalTime" class="headerlink" title="LocalDate、LocalTime"></a>LocalDate、LocalTime</h3><p>LocalDate是一个不可变对象，它只提供了简单的日期，并不含当天的时间信息。另外，它也不附带任何与时区相关的信息。</p>
<ul>
<li>使用静态方法of创建</li>
<li>通过解析代表它们的字符串来创建，一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，会抛出DateTimeParseException。</li>
<li>多种方法获取年份、月份、星期几等。TemporalField是一个接口，它定义了如何访问temporal对象某个字段的值。ChronoField枚举实现了这一接口，可以很方便地使用get方法得到枚举元素的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">System.out.println(localDate.getYear()); <span class="comment">// 2020</span></span><br><span class="line">System.out.println(localDate.get(ChronoField.YEAR)); <span class="comment">// 2020</span></span><br><span class="line"></span><br><span class="line">Month month = localDate.getMonth();</span><br><span class="line">System.out.println(localDate.get(ChronoField.MONTH_OF_YEAR));<span class="comment">// 1</span></span><br><span class="line">System.out.println(month.getLong(ChronoField.MONTH_OF_YEAR));<span class="comment">// 1</span></span><br><span class="line">System.out.println(month.getValue());<span class="comment">// 1</span></span><br><span class="line">System.out.println(localDate.lengthOfMonth());<span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line">System.out.println(localDate.getDayOfYear());<span class="comment">// 15</span></span><br><span class="line">System.out.println(localDate.getDayOfMonth());<span class="comment">// 15</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek.getValue());<span class="comment">// 3</span></span><br><span class="line">System.out.println(dayOfWeek.getLong(ChronoField.DAY_OF_WEEK));<span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果使用Parse方法解析的字符串是不带毫秒，纳秒的，获得毫秒、纳秒的值为0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.parse(<span class="string">&quot;22:17:32&quot;</span>);</span><br><span class="line"><span class="comment">//LocalTime localTime = LocalTime.now();</span></span><br><span class="line">System.out.println(localTime.getHour());</span><br><span class="line">System.out.println(localTime.getLong(ChronoField.MILLI_OF_SECOND));<span class="comment">// 毫秒</span></span><br><span class="line">System.out.println(localTime.getLong(ChronoField.MICRO_OF_SECOND));<span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>



<h3 id="LocalDataTime和LocalDate、LocalTime的转换"><a href="#LocalDataTime和LocalDate、LocalTime的转换" class="headerlink" title="LocalDataTime和LocalDate、LocalTime的转换"></a>LocalDataTime和LocalDate、LocalTime的转换</h3><ul>
<li>LocalDateTime可以通过静态方法of创建，也可以通过传入LocalDate、LocalTime创建</li>
<li>LocalDateTime可以通过LocalTime传递LocalDate对象来创建，也可以通过LocalDate传递LocalTime对象来创建</li>
<li>LocalDateTime可以通过toLocalDate()、toLocalTime()方法来转换成LocalDate、LocalTime对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime2 = localDate.atTime(<span class="number">22</span>, <span class="number">25</span>, <span class="number">32</span>);</span><br><span class="line">LocalDateTime localDateTime3 = localTime.atDate(localDate);</span><br><span class="line"></span><br><span class="line">LocalDate localDate1 = localDateTime1.toLocalDate();</span><br><span class="line">LocalTime localTime1 = localDateTime1.toLocalTime();</span><br><span class="line">System.out.println(localDateTime1);<span class="comment">// 2020-10-18T22:27:28.825</span></span><br><span class="line">System.out.println(localDateTime2);<span class="comment">// 2020-10-18T22:25:32</span></span><br><span class="line">System.out.println(localDateTime3);<span class="comment">// 2020-10-18T22:27:28.825</span></span><br></pre></td></tr></table></figure>

<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>Instant的设计初衷是为了便于机器使用。它包含的是由秒和纳秒所构成的数字，它无法处理哪些我们非常容易理解的时间单位，但是可以通过Duration和Period类使用Instant。</p>
<h3 id="Duration和Period"><a href="#Duration和Period" class="headerlink" title="Duration和Period"></a>Duration和Period</h3><p>Duration是计算两个LocalTime、LocalDateTime、Instant之间的间隔时间的。</p>
<p>Period是计算两个LocalDate的间隔日期的。</p>
<p>它们都可以通过静态方法between来创建。</p>
<p><strong>注意：由于LocalDateTime和Instant是为了不同的目的而设计的，一个是为了便于人阅读使用，一个是便于机器处理，所以不能讲二者混用，会抛出DateTimeException。</strong></p>
<h3 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h3><p>如果你已经有了一个LocalDate对象，想要创建它的一个修改版，最直接的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。也可以采用更加通用的with方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();<span class="comment">// 2020-10-18</span></span><br><span class="line">LocalDate localDate1 = localDate.withYear(<span class="number">2011</span>);<span class="comment">// 2011-10-18</span></span><br><span class="line">LocalDate localDate2 = localDate.withDayOfMonth(<span class="number">25</span>);<span class="comment">// 2020-10-25</span></span><br><span class="line">LocalDate localDate3 = localDate.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);<span class="comment">// 2020-09-18</span></span><br></pre></td></tr></table></figure>

<h3 id="日期时间的计算"><a href="#日期时间的计算" class="headerlink" title="日期时间的计算"></a>日期时间的计算</h3><p>Temporal接口提供了很多的方法进行日期时间的计算，比如with，get等。所有的日期和时间API类都实现了这两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();<span class="comment">// 2020-10-18</span></span><br><span class="line">LocalDate localDate1 = localDate.plusDays(<span class="number">3</span>);<span class="comment">// 2020-10-21</span></span><br><span class="line">LocalDate localDate2 = localDate.minusYears(<span class="number">1</span>);<span class="comment">// 2019-10-18</span></span><br><span class="line">LocalDate localDate3 = localDate.plus(<span class="number">6</span>, ChronoUnit.MONTHS);<span class="comment">// 2021-04-18</span></span><br></pre></td></tr></table></figure>

<p>有时候，需要将日期调整到下个周日，下个工作日或者是本月的最后一天，可以使用重载的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活得处理日期。</p>
<p>日期和时间API已经提供了大量预定义的TemporalAdjusters，可以通过静态工厂方法访问它们。也可以通过实现TemporalAdjuster接口自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();<span class="comment">// 2020-10-18</span></span><br><span class="line"><span class="comment">// 离现在最近的星期天 2020-10-18</span></span><br><span class="line">LocalDate localDate1 = localDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line"><span class="comment">// 这个月的最后一天 2020-10-31</span></span><br><span class="line">LocalDate localDate2 = localDate.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot注入多例的Bean.md</title>
    <url>/2020/10/14/SpringBoot/Bean/SpringBoot%E6%B3%A8%E5%85%A5%E5%A4%9A%E4%BE%8B%E7%9A%84Bean/</url>
    <content><![CDATA[<h3 id="SpringBoot如何注入多例Bean？"><a href="#SpringBoot如何注入多例Bean？" class="headerlink" title="SpringBoot如何注入多例Bean？"></a>SpringBoot如何注入多例Bean？</h3><p>SpringBoot默认是注入单例模式的Bean，可以在Bean上添加@Scope(value = “prototype”)注解来注入多例的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponChecker</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用成员变量的方式注入CouponChecker实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CouponChecker couponChecker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(couponChecker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>多次访问后，控制台打印如下。我们可以看到多次打印的hasd值都是一样的，那是不是说明@Scope注解没有生效，注入的还是单例的Bean呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sise.ming.logic.CouponChecker@347a792b</span><br><span class="line">com.sise.ming.logic.CouponChecker@347a792b</span><br></pre></td></tr></table></figure>

<p>其实不然，此时已经是多例模式，但由于成员属性的注入只是在类实例实例化的时候注入一次，导出打印出的hash码是一致的。</p>
<p>如果将成员属性的注入方式改为方法属性的注入，可以看到打印的hash值不再一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="meta">@Autowired</span> CouponChecker couponChecker)</span></span>&#123;</span><br><span class="line">        System.out.println(couponChecker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sise.ming.logic.CouponChecker@43eab93e</span><br><span class="line">com.sise.ming.logic.CouponChecker@26b55617</span><br></pre></td></tr></table></figure>



<h3 id="其他几种注入多例的方式"><a href="#其他几种注入多例的方式" class="headerlink" title="其他几种注入多例的方式"></a>其他几种注入多例的方式</h3><ul>
<li><p>使用ObjectFactory<T>,缺点是使用的时候需要调用getObject方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;CouponChecker&gt; factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(factory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用动态代理，注入的是类选择ScopedProxyMode.TARGET_CLASS，注入的是接口选择ScopedProxyMode.INTERFACES</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;prototype&quot;,proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponChecker</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponChecker couponChecker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(couponChecker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登录获取JWT令牌.md</title>
    <url>/2020/10/08/SpringBoot/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96JWP%E4%BB%A4%E7%89%8C/</url>
    <content><![CDATA[<h3 id="小程序登录获取微信服务器验证流程"><a href="#小程序登录获取微信服务器验证流程" class="headerlink" title="小程序登录获取微信服务器验证流程"></a>小程序登录获取微信服务器验证流程</h3><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/api-login.2fcc9f35.jpg" alt="小程序登录验证机制"></p>
<p>小程序通过login方法获取到code，将code发送到服务器，服务器接收到code，加上appid和secret向微信服务器发送POST请求验证。</p>
<p>如果微信服务器验证通过，则开发者的服务器生成JWT令牌返回给前端，从而完成API权限的控制。</p>
<p>这里涉及到几个知识点：</p>
<ul>
<li>如何将配置文件中的模板字符串替换成目标的字符串？</li>
<li>在服务端，如何发送POST请求？怎么解决SSL问题？</li>
<li>如何生成JWT令牌？</li>
</ul>
<h3 id="如何将配置文件中的模板字符串替换成目标的字符串？"><a href="#如何将配置文件中的模板字符串替换成目标的字符串？" class="headerlink" title="如何将配置文件中的模板字符串替换成目标的字符串？"></a>如何将配置文件中的模板字符串替换成目标的字符串？</h3><p>引用同个配置文件中的其他配置项，可以通过${}方式来获取。</p>
<p>在配置文件中的模板字符串要被程序进行处理替换的字符串，可以使用{0}，{1}这种方式占位，在程序中使用MessageFormat来格式化。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">wechat:</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxxxxx</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">code2session:</span> <span class="string">https://api.weixin.qq.com/sns/jscode2session?appid=$&#123;wechat.appid&#125;&amp;secret=$&#123;wechat.secret&#125;&amp;js_code=&#123;0&#125;&amp;grant_type=authorization_code</span></span><br></pre></td></tr></table></figure>

<p>在程序在使用MessageFormat来格式化占位的字符串，方法形参是可变类型参数，对应着配置文件中的{0}，{1}等占位符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = MessageFormat.format(<span class="keyword">this</span>.code2SessionUrl, code);</span><br></pre></td></tr></table></figure>



<h3 id="在服务端，如何发送POST请求？怎么解决SSL问题？"><a href="#在服务端，如何发送POST请求？怎么解决SSL问题？" class="headerlink" title="在服务端，如何发送POST请求？怎么解决SSL问题？"></a>在服务端，如何发送POST请求？怎么解决SSL问题？</h3><p>我们可以利用Spring中的RestTemplate来发送POST请求，并获取返回的结果。</p>
<p>getForObject的第二个参数是结果返回的类型，一般为json字符串，故用String.class.</p>
<p><strong>注意：可以通过new RestTemplate()来创建RestTempalte对象。在这里是使用了@Configuration将RestTemplate加入了IOC容器，并使用依赖注入的方式注入的。因为需要@Configration类解决SSL验证的问题。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resultJson = restTemplate.getForObject(url, String.class);</span><br></pre></td></tr></table></figure>

<p>使用RestTemplate解决SSL验证问题：</p>
<ul>
<li>首先导入工具类SSL</li>
<li>创建@Configuration配置类，将处理过的RestTemplate加入到IOC容器中</li>
</ul>
<p>SSL.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Date</span> 2020/10/08 14:58</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> 解决RestTemplate的SSL验证问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSL</span> <span class="keyword">extends</span> <span class="title">SimpleClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareConnection</span><span class="params">(HttpURLConnection connection, String httpMethod)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;</span><br><span class="line">            prepareHttpsConnection((HttpsURLConnection) connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.prepareConnection(connection, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareHttpsConnection</span><span class="params">(HttpsURLConnection connection)</span> </span>&#123;</span><br><span class="line">        connection.setHostnameVerifier(<span class="keyword">new</span> SkipHostnameVerifier());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setSSLSocketFactory(createSslSocketFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SSLSocketFactory <span class="title">createSslSocketFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SSLContext context = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">        context.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[] &#123; <span class="keyword">new</span> SkipX509TrustManager() &#125;,</span><br><span class="line">                <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        <span class="keyword">return</span> context.getSocketFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipHostnameVerifier</span> <span class="keyword">implements</span> <span class="title">HostnameVerifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String s, SSLSession sslSession)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>@Configuration配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(ClientHttpRequestFactory factory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">simpleClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SSL factory = <span class="keyword">new</span> SSL();</span><br><span class="line">            factory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">            factory.setConnectTimeout(<span class="number">15000</span>);<span class="comment">//单位为ms</span></span><br><span class="line">            <span class="keyword">return</span> factory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="如何生成JWT令牌？"><a href="#如何生成JWT令牌？" class="headerlink" title="如何生成JWT令牌？"></a>如何生成JWT令牌？</h3><p>我们使用auth0的jwt库，来生成JWT令牌。</p>
<p>首先，导入Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现JWT令牌的生成：</strong></p>
<p>withClaim方法主要是自定义信息，</p>
<p>withIssuedAt方法是令牌的生成时间Date，</p>
<p>withExpiresAt方法是令牌的过期时间Date，</p>
<p>sign方法最终生成一个JWT令牌字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Optional&lt;String&gt; <span class="title">getToken</span><span class="params">(Long userId, <span class="keyword">int</span> scopeLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 选择算法</span></span><br><span class="line">        Algorithm algorithm = Algorithm.HMAC256(jwtKey);</span><br><span class="line">        Time time = JwtToken.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Optional.of(JWT.create()</span><br><span class="line">                           .withClaim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                           .withClaim(<span class="string">&quot;scopeLevel&quot;</span>, scopeLevel)</span><br><span class="line">                           .withIssuedAt(time.getCurrentTime())</span><br><span class="line">                           .withExpiresAt(time.getExpiredTime())</span><br><span class="line">                           .sign(algorithm));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JWT令牌的验证：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证JWT令牌,并返回自定义的信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> token JWT令牌</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> Optional&lt;Map&lt;String, Claim&gt;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Map&lt;String, Claim&gt;&gt; getClaims(String token)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Algorithm algorithm = Algorithm.HMAC256(JwtToken.jwtKey);</span><br><span class="line"></span><br><span class="line">        JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">        DecodedJWT decodedJwt = verifier.verify(token);</span><br><span class="line">        <span class="keyword">return</span> Optional.of(decodedJwt.getClaims());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>JWT,小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA的使用.md</title>
    <url>/2020/10/06/JPA/JPA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="JPA查询的使用"><a href="#JPA查询的使用" class="headerlink" title="JPA查询的使用"></a>JPA查询的使用</h3><ol>
<li>创建一个接口，实现JpaRepository&lt;T,R&gt;接口。T是操作的实体，R是操作的实体的主键的类型</li>
</ol>
<h3 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findAll()</span><br></pre></td></tr></table></figure>



<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>PageRequest.of构造Pageable分页对象：</p>
<ul>
<li>pageNumber：页码</li>
<li>size：每页条数</li>
<li>Sort：排序对象，有多个重载方法，descending为倒叙排序</li>
</ul>
<p>findAll方法可以接收一个分页对象Pageable进行查询，查询结果返回Page<T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Spu&gt; <span class="title">getLatestPagingSpu</span><span class="params">(Integer pageNumber, Integer size)</span> </span>&#123;</span><br><span class="line">    Pageable page = PageRequest.of(pageNumber, size, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">    <span class="keyword">return</span> spuRepository.findAll(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Page<T>包含了很多分页的信息，比如分页大小，数据总数，当前页码等，可以用一个实体类封装这些分页信息，并返回给前端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paging</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalPage;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Paging</span><span class="params">(Page&lt;T&gt; page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initPageParams(page);</span><br><span class="line">        <span class="keyword">this</span>.items = page.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPageParams</span><span class="params">(Page&lt;T&gt; page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = page.getTotalElements();</span><br><span class="line">        <span class="keyword">this</span>.count = page.getSize();</span><br><span class="line">        <span class="keyword">this</span>.pageNumber = page.getNumber();</span><br><span class="line">        <span class="keyword">this</span>.totalPage = page.getTotalPages();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候返回前端的是“简化版”的vo，比如JPA返回的分页对象Page<Spu>，而需要返回给前端的是Pageing<SimplifySpu>，就需要将Spu的属性复制到SimplifySpu中，我们可以写一个可以复制对象属性的PagingDozer&lt;Spu,SimplifySpu&gt;类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/12 22:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 可复制属性的分页对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagingDozer</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Paging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mapper mapper = DozerBeanMapperBuilder.buildDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagingDozer</span><span class="params">(Page&lt;T&gt; page, Class&lt;R&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initPageParams(page);</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; items = page.getContent();</span><br><span class="line">        List&lt;R&gt; voList = items.stream()</span><br><span class="line">                .map(item -&gt; mapper.map(item, clazz))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">this</span>.setItems(voList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="原生SQL查询"><a href="#原生SQL查询" class="headerlink" title="原生SQL查询"></a>原生SQL查询</h4><p>设置nativeQuery=true，使用原生的sql查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(nativeQuery = true,value = &quot;select coupon.* from coupon inner join coupon_category on coupon.id = coupon_category.coupon_id inner join category on coupon_category.category_id = category.id&quot;)</span></span><br><span class="line">    Optional&lt;List&lt;Coupon&gt;&gt; findByCategory(Long categoryId, Date now);</span><br></pre></td></tr></table></figure>

<h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><p>使用实体代替数据表，参数通过“：参数名”的格式传递。</p>
<p>如果配置配置导航属性，需要使用ON写连接条件。</p>
<p><strong>注意，必须使用别名。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select c from Coupon c\n&quot; +</span></span><br><span class="line"><span class="meta">           &quot;join c.categoryList ca\n&quot; +</span></span><br><span class="line"><span class="meta">           &quot;join Activity a on a.id = c.activityId \n&quot; +</span></span><br><span class="line"><span class="meta">           &quot;where ca.id = :categoryId \n&quot; +</span></span><br><span class="line"><span class="meta">           &quot;and a.startTime &lt; :now \n&quot; +</span></span><br><span class="line"><span class="meta">           &quot;and a.endTime &gt; :now&quot;)</span></span><br><span class="line">Optional&lt;List&lt;Coupon&gt;&gt; findByCategory(Long categoryId, Date now);</span><br></pre></td></tr></table></figure>

<p>生成的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">        coupon0_.id <span class="keyword">as</span> id1_4_,</span><br><span class="line">        coupon0_.create_time <span class="keyword">as</span> create_t2_4_,</span><br><span class="line">        coupon0_.delete_time <span class="keyword">as</span> delete_t3_4_,</span><br><span class="line">        coupon0_.update_time <span class="keyword">as</span> update_t4_4_,</span><br><span class="line">        coupon0_.activity_id <span class="keyword">as</span> activity5_4_,</span><br><span class="line">        coupon0_.description <span class="keyword">as</span> descript6_4_,</span><br><span class="line">        coupon0_.end_time <span class="keyword">as</span> end_time7_4_,</span><br><span class="line">        coupon0_.full_money <span class="keyword">as</span> full_mon8_4_,</span><br><span class="line">        coupon0_.minus <span class="keyword">as</span> minus9_4_,</span><br><span class="line">        coupon0_.rate <span class="keyword">as</span> rate10_4_,</span><br><span class="line">        coupon0_.remark <span class="keyword">as</span> remark11_4_,</span><br><span class="line">        coupon0_.start_time <span class="keyword">as</span> start_t12_4_,</span><br><span class="line">        coupon0_.title <span class="keyword">as</span> title13_4_,</span><br><span class="line">        coupon0_.type <span class="keyword">as</span> type14_4_,</span><br><span class="line">        coupon0_.valitiy <span class="keyword">as</span> valitiy15_4_,</span><br><span class="line">        coupon0_.whole_store <span class="keyword">as</span> whole_s16_4_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        coupon coupon0_ </span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">        coupon_category categoryli1_ </span><br><span class="line">            <span class="keyword">on</span> coupon0_.id<span class="operator">=</span>categoryli1_.coupon_id </span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">        category category2_ </span><br><span class="line">            <span class="keyword">on</span> categoryli1_.category_id<span class="operator">=</span>category2_.id </span><br><span class="line">            <span class="keyword">and</span> (</span><br><span class="line">                category2_.delete_time <span class="keyword">is</span> <span class="keyword">null</span> </span><br><span class="line">                <span class="keyword">and</span> category2_.online <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            ) </span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">        activity activity3_ </span><br><span class="line">            <span class="keyword">on</span> (</span><br><span class="line">                activity3_.id<span class="operator">=</span>coupon0_.activity_id</span><br><span class="line">            ) </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        category2_.id<span class="operator">=</span>? </span><br><span class="line">        <span class="keyword">and</span> activity3_.start_time<span class="operator">&lt;</span>? </span><br><span class="line">        <span class="keyword">and</span> activity3_.end_time<span class="operator">&gt;</span>?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登录获取JWP.md</title>
    <url>/2020/10/05/SpringBoot/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96JWT%E4%BB%A4%E7%89%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>拷贝属性</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝属性.md</title>
    <url>/2020/10/05/SpringBoot/%E6%8B%B7%E8%B4%9D%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanUtils.copyProperties(Object source,Object target);</span><br></pre></td></tr></table></figure>



<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>添加dozer-mapper依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.dozermapper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dozer-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.5</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mapper mapper = DozerBeanMapperBuilder.buildDefault();</span><br><span class="line">mapper.map(Object o ,Class&lt;?&gt; clazz)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>拷贝属性</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化设置.md</title>
    <url>/2020/10/05/SpringBoot/%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="jackson序列化常用设置"><a href="#jackson序列化常用设置" class="headerlink" title="jackson序列化常用设置"></a>jackson序列化常用设置</h3><ul>
<li><p>忽略某个属性的序列化：@JsonIgnore</p>
</li>
<li><p>设置以_分割的key：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">property-naming-strategy:</span> <span class="string">SNAKE_CASE</span></span><br></pre></td></tr></table></figure></li>
<li><p>以时间戳的形式返回时间：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">serialization:</span></span><br><span class="line">      <span class="attr">write-dates-as-timestamps:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA配置导航属性.md</title>
    <url>/2020/10/04/JPA/JPA%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%88%AA%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="SpringBoot使用JPA配置"><a href="#SpringBoot使用JPA配置" class="headerlink" title="SpringBoot使用JPA配置"></a>SpringBoot使用JPA配置</h3><ol>
<li><p>添加maven依赖：data-jpa、starter-jdbc、mysql-connector-java</p>
</li>
<li><p>配置JPA</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20201004164138673.png" alt="jpa配置"></p>
</li>
</ol>
<h3 id="JPA常用注解"><a href="#JPA常用注解" class="headerlink" title="JPA常用注解"></a>JPA常用注解</h3><ul>
<li>@Entity：表示一个实体类</li>
<li>@Id：设置主键</li>
<li>@Table：在实体类上使用，设置数据表名称</li>
<li>@Transient：在属性中存在，但不映射到数据表</li>
<li>@OneToMany：一对多的关系，可以通过fetch属性来设置懒加载、急加载，默认是懒加载</li>
<li>@ManyToOne：多对一的关系</li>
<li>@JoinColumn(name=””)：设置外键</li>
<li>@GeneratedValue(strategy = GenerationType.IDENTITY)：自增长</li>
<li>@ManyToMany：多对多的关系</li>
<li>@JoinTable(name = “theme_spu”,joinColumns = @JoinColumn(name = “theme_id”),<pre><code>inverseJoinColumns = @JoinColumn(name = &quot;spu_id&quot;))：设置中间表的属性
</code></pre>
</li>
<li>@ForeignKey(name =”null”)：禁止生成物理外键</li>
</ul>
<h3 id="单向一对多的配置"><a href="#单向一对多的配置" class="headerlink" title="单向一对多的配置"></a>单向一对多的配置</h3><p>假设有两个实体类Banner和BannerItem，它们是一对多的关系。</p>
<p>实体类Banner的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类BannerItem的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerItem</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想配置Banner类中有多个BannerItem这种单向一对多的关系，需要在Banner类中添加属性：List<BannerItem> bannerItems，并使用注解@OneToMany标记在bannerItems类上，表示一对多的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BannerItem&gt; bannerItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，实际运行会发现，数据库生成了3张表，banner，banner_item，banner_banner_items，其中banner_banner_items是中间表，用来维护一对多的这种关系。</p>
<p>其实，一对多的关系并不需要生成一张中间表来维护。我们就需要告诉JPA，在生成数据表的时候，不要给我生成中间表，此时，就需要使用@JoinColumn来指明外键了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;banner_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BannerItem&gt; bannerItems;</span><br></pre></td></tr></table></figure>

<p>这样，就只会生成banner和banner_item表，且在banner_item中自动生成了一个banner_id字段来表示外键关系，通过查看查看外键，也证明了banner_id存在物理外键。</p>
<h3 id="双向一对多的配置"><a href="#双向一对多的配置" class="headerlink" title="双向一对多的配置"></a>双向一对多的配置</h3><p>有时候，业务有双向一对多的场景。比如，查询Banner的时候，要查询出对应的BannerItem。查询BannerItem的时候，也需要知道BannerItem是属于哪个Banner的。</p>
<p>双向一对多需要在两个实体类都加上注解，@OneToMany和@ManyToOne。</p>
<p>Banner：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;banner&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BannerItem&gt; bannerItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BannerItem：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerItem</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;banner_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到一个细节：Banner类上@OneToMany多了一个mappedBy属性，值为BannerItem中的属性banner。@JoinColumn不再标记在Banner中，而是标记在了BannerItem中，这是为什么呢？</p>
<p>这里，要提出两个概念：</p>
<ul>
<li>关系维护方(多方)</li>
<li>关系被维护端(一方)</li>
</ul>
<p>在双向多对多的这种关系中，关系维护方是在多方，也就是BannerItem中，所以@JoinColumn需要标记在关系维护方中。</p>
<p><strong>在双向一对多的关系中，@JoinColumn也可以不写，但是mappedBy必须要写。</strong></p>
<h4 id="问题：JPA自动生成了banner-id的外键，我们还可以在BannerItem中定义多一个BannerId的属性吗？"><a href="#问题：JPA自动生成了banner-id的外键，我们还可以在BannerItem中定义多一个BannerId的属性吗？" class="headerlink" title="问题：JPA自动生成了banner_id的外键，我们还可以在BannerItem中定义多一个BannerId的属性吗？"></a>问题：JPA自动生成了banner_id的外键，我们还可以在BannerItem中定义多一个BannerId的属性吗？</h4><p>运行之后，会报错，错误显示有重复的banner_id字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Table [banner_item] contains physical column name [banner_id] referred to by multiple logical column names: [banner_id], [bannerId]</span><br></pre></td></tr></table></figure>

<p>经过测试，有一种办法可以在BannerItem中定义BannerId属性，又不影响JPA自动生成的banner_id外键：</p>
<p>在关系维护端的@JoinColumn添加@JoinColumn(name = “banner_id”,insertable = false,updatable = false)，</p>
<p>但是属性名称必须和@JoinColumn的name属性相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerItem</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long banner_id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;banner_id&quot;,insertable = false,updatable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单向多对多的配置"><a href="#单向多对多的配置" class="headerlink" title="单向多对多的配置"></a>单向多对多的配置</h3><p>假设有两个实体类Theme和Spu，它们是一对多的关系。</p>
<p>实体类Theme：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;theme_spu&quot;,joinColumns = @JoinColumn(name = &quot;theme_id&quot;),</span></span><br><span class="line"><span class="meta">    inverseJoinColumns = @JoinColumn(name = &quot;spu_id&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Spu&gt; spuList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类Spu：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同单向一对多的配置差不多，单向多对多会生成一种中间表来维护关系。@JoinTable是用来指定生成的中间表的属性的。比如name指明了中间表的表名为theme_spu。</p>
<h3 id="双向多对多的配置"><a href="#双向多对多的配置" class="headerlink" title="双向多对多的配置"></a>双向多对多的配置</h3><p>只需要在Spu中添加@ManyToMany注解，并设置mapperBy属性即可。</p>
<p><strong>需要注意的是，同双向一对多的关系不同的是，双向多对多的关系维护方并不是固定的。</strong>比如这里的关系维护方是Theme类，因为@JoinTable注解标记在Theme类中，但也可以标记在Spu类中，使Spu成为关系维护方。</p>
<p><strong>对于查询数据来说，谁是关系维护方并不影响，因为都会查询出关联的数据。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;spuList&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Theme&gt; themeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何禁止JPA生成物理外键？"><a href="#如何禁止JPA生成物理外键？" class="headerlink" title="如何禁止JPA生成物理外键？"></a>如何禁止JPA生成物理外键？</h3><ul>
<li><p>在@JoinColumn或者@JoinTable的属性中添加foreignKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinTable(foreignKey = @ForeignKey(value = ConstraintMode.NO_CONSTRAINT))</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用过时的@ForeignKey注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.hibernate.annotations.ForeignKey(name = <span class="string">&quot;null&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>重写方言Dialet</p>
</li>
</ul>
<h3 id="生成一个父类，不映射成数据表"><a href="#生成一个父类，不映射成数据表" class="headerlink" title="生成一个父类，不映射成数据表"></a>生成一个父类，不映射成数据表</h3><p>标记上@MappedSuperclass表示不映射成数据表，只是作为@Entity的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/07 14:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 标记为abstract,BaseEntity不能单独被new</span></span><br><span class="line"><span class="comment"> *              JsonIgnore表示在序列化的时候忽略,不返回给前端</span></span><br><span class="line"><span class="comment"> *              MappedSuperclass表示不映射成数据表,只是作为Entity的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Date deleteTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean Validation.md</title>
    <url>/2020/10/03/SpringBoot/Bean%20Validation/</url>
    <content><![CDATA[<h3 id="JSR303-参数校验"><a href="#JSR303-参数校验" class="headerlink" title="JSR303 参数校验"></a>JSR303 参数校验</h3><p>参数校验提供了一些简单的注解，可以对前端传递过来的参数进行验证，并且自定义异常信息。常用的注解有：</p>
<ul>
<li>@Min(value=””,message=””)</li>
<li>@Max</li>
<li>@Range</li>
<li>@Length</li>
</ul>
<h3 id="开启参数校验"><a href="#开启参数校验" class="headerlink" title="开启参数校验"></a>开启参数校验</h3><blockquote>
<p>验证简单的参数</p>
</blockquote>
<ul>
<li>在类(Controller)上添加@Validated，开启参数校验</li>
<li>在方法的参数上使用@Min等验证注解</li>
</ul>
<blockquote>
<p>验证DTO中的参数</p>
</blockquote>
<ul>
<li>在方法参数上(一般是Controller中的方法)添加@Validated，开启参数校验</li>
<li>在DTO的成员变量上添加验证注解</li>
</ul>
<blockquote>
<p>级联校验</p>
</blockquote>
<ul>
<li>在方法参数上(一般是Controller中的方法)添加@Validated，开启参数校验</li>
<li>在验证的DTO中关联的DTO上加@Valid，开启级联校验</li>
<li>在关联的DTO中添加验证注解</li>
</ul>
<p><strong>需要说明的一点是，DTO是用服务器用来接收前端传递过来的参数的，可以通过把相关联的DTO属性加入到同一个DTO，从而消除级联的校验。</strong></p>
<h3 id="Validated与-Valid的区别："><a href="#Validated与-Valid的区别：" class="headerlink" title="@Validated与@Valid的区别："></a>@Validated与@Valid的区别：</h3><ul>
<li>它们具有一定的相似性，并不是互斥的关系，在一定情况下可以互换使用</li>
<li>@Valid是Java标准，而@Validated是Spring对@Valid的扩展</li>
<li>一般情况下，@Validate用于开启参数校验，@Valid用于开启级联校验</li>
</ul>
<h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><ol>
<li><p>自定义一个注解，加上模板方法groups、payloads</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>注解上添加@Constraint(validatedBy = xxxx.class)，关联一个类，用来编写校验逻辑</p>
</li>
<li><p>定义一个类，实现ConstraintValidator&lt;T,R&gt;接口，<strong>泛型T表示自定义注解的类型，*泛型R表示自定义注解修饰的目标的类型</strong>。</p>
</li>
<li><p>实现isValid的方法，返回boolean值标志是否通过校验</p>
</li>
<li><p>如果需要获取注解中定义的参数，要实现initialize方法，将注解的数据赋值给成员变量，这样在isValid方法中就可以获取注解中的信息进行判断</p>
</li>
</ol>
<h4 id="一个自定义校验注解的栗子"><a href="#一个自定义校验注解的栗子" class="headerlink" title="一个自定义校验注解的栗子"></a>一个自定义校验注解的栗子</h4><p>自定义一个注解，加上模板方法groups、payloads，注解上添加@Constraint(validatedBy = xxxx.class)，关联一个类，用来编写校验逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = PasswordEqualValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PasswordEqual &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;password is not equal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类编写校验的相关逻辑，T是自定义注解的类型，R是自定义注解修饰的目标的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordEqualValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">PasswordEqual</span>, <span class="title">PersonDTO</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(PersonDTO personDTO, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        String password1 = personDTO.getPassword1();</span><br><span class="line">        String password2 = personDTO.getPassword2();</span><br><span class="line">        <span class="keyword">if</span>(!password1.equals(password2))&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(password1.length() &lt; min)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(password2.length() &gt; max)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(PasswordEqual constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.min = constraintAnnotation.min();</span><br><span class="line">        <span class="keyword">this</span>.max = constraintAnnotation.max();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成自定义注解的编写后，在PersonDTO中使用：</p>
<p><strong>记得开启参数校验，参考上面“开启参数校验”这一章节。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@PasswordEqual(message = &quot;密码错误&quot;,min = 2,max = 4)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Length(min = 2,max = 7)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 7)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password1;</span><br><span class="line">    <span class="keyword">private</span> String password2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参数校验结合全局异常处理"><a href="#参数校验结合全局异常处理" class="headerlink" title="参数校验结合全局异常处理"></a>参数校验结合全局异常处理</h3><p>参数校验分为两种情况：</p>
<ul>
<li>POST请求通过body传递的参数</li>
<li>GET请求通过url传递的参数</li>
</ul>
<blockquote>
<p>POST Body 传递的参数校验异常处理</p>
</blockquote>
<ol>
<li>抛出MethodArgumentNotValidException</li>
<li>存在校验有多个错误信息的可能，需要将所有的错误信息拼接成字符串返回</li>
<li>List<ObjectError>中getDefaultMessage可以获取到错误信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;处理参数校验异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">* 1.参数校验异常使用统一的HTTP状态码 400</span></span><br><span class="line"><span class="comment">* 2.所有的参数校验异常都是抛出MethodArgumentNotValidException</span></span><br><span class="line"><span class="comment">* 3.如果校验有多个错误,将所有的错误信息用分号分割</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request the request of http</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e       the exception that method throw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the unify response message</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UnifyResponse <span class="title">handleMethodArgumentNotValidException</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; requestInfo = getRequestUrlAndMethod(request);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="comment">// get exception message</span></span><br><span class="line">    List&lt;ObjectError&gt; errors = e.getBindingResult().getAllErrors();</span><br><span class="line">    String message = getBeanValidationMessage(errors);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnifyResponse(<span class="number">10001</span>, message, requestInfo.get(<span class="string">&quot;url&quot;</span>), requestInfo.get(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将多个错误拼接成以分号分割的字符串返回</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> errors the errors list that exception throws</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the message about the exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getBeanValidationMessage</span><span class="params">(List&lt;ObjectError&gt; errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> errors.stream()</span><br><span class="line">        .map(DefaultMessageSourceResolvable::getDefaultMessage)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过url传递的参数校验异常处理</p>
</blockquote>
<p>一是使用SpingBoot默认的message</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;处理url参数传递校验异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * 1.参数校验异常使用统一的HTTP状态码 400</span></span><br><span class="line"><span class="comment">     * 2.所有的参数校验异常都是抛出ConstraintViolationException</span></span><br><span class="line"><span class="comment">     * 3.有多种获取异常信息的方式，这里采用第二种</span></span><br><span class="line"><span class="comment">     *  1.遍历e.getConstraintViolations对每一个异常进行处理，可以获取更多异常信息</span></span><br><span class="line"><span class="comment">     *  2.利用e.getMessage已经处理好的异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request of http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e       the exception that method throw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the unify response message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UnifyResponse <span class="title">handleConstraintViolationException</span><span class="params">(HttpServletRequest request, ConstraintViolationException e)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; requestInfo = getRequestUrlAndMethod(request);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnifyResponse(<span class="number">99997</span>, e.getMessage(), requestInfo.get(<span class="string">&quot;url&quot;</span>), requestInfo.get(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二是自己处理的message：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getConstraintViolationMessage</span><span class="params">(ConstraintViolationException e)</span></span>&#123;</span><br><span class="line">    String message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">    <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; constraintViolation : constraintViolations) &#123;</span><br><span class="line">        String path = constraintViolation.getPropertyPath().toString();</span><br><span class="line">        String[] names = path.split(<span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">        String name = names[<span class="number">1</span>];</span><br><span class="line">        message =  name + <span class="string">&quot;:&quot;</span> + constraintViolation.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="抽取出message配置模板"><a href="#抽取出message配置模板" class="headerlink" title="抽取出message配置模板"></a>抽取出message配置模板</h3><p>在resources目录下，创建一个ValidationMessages.properties文件(规定了只能是这个文件)。</p>
<p><strong>注意，在这里用{}来引用配置文件中的key。在配置文件中，也能使用{}来引入注解中的值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id.positive=id不能为负数&#123;max&#125;&#123;min&#125;</span><br><span class="line">name.notBlank=参数不能为空</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;name/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Banner <span class="title">getByName</span><span class="params">(<span class="meta">@PathVariable</span> <span class="meta">@NotBlank(message = &quot;&#123;name.notBlank&#125;&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">    Banner banner = bannerService.getByName(name);</span><br><span class="line">    <span class="keyword">if</span> (banner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="number">30005</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> banner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>校验</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Event.md</title>
    <url>/2020/09/15/Spring/Event/</url>
    <content><![CDATA[<h3 id="ApplicationEvent"><a href="#ApplicationEvent" class="headerlink" title="ApplicationEvent"></a>ApplicationEvent</h3><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200922214737109.png" alt="ApplicationEvent继承关系"></p>
<h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200922215318965.png" alt="ApplicationListener"></p>
<h3 id="ApplicationEventPublish"><a href="#ApplicationEventPublish" class="headerlink" title="ApplicationEventPublish"></a>ApplicationEventPublish</h3><p>ApplicationContext实现了ApplicationEventPublish接口。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>确定bean的运行时类型.md</title>
    <url>/2020/09/15/Spring/%E7%A1%AE%E5%AE%9Abean%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Spring中创建bean的方式"><a href="#Spring中创建bean的方式" class="headerlink" title="Spring中创建bean的方式"></a>Spring中创建bean的方式</h3><h4 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h4><ol>
<li>通过构造方法创建bean</li>
</ol>
<p>如果不知道构造方法，默认使用无参构造方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.entity.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>class属性是必须的,如果没有指定class属性，会报以下错误:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error creating bean with name <span class="string">&#x27;book&#x27;</span> defined in <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">spring</span>-<span class="title">config</span>.<span class="title">xml</span>]: <span class="title">Instantiation</span> <span class="title">of</span> <span class="title">bean</span> <span class="title">failed</span></span>; nested exception is java.lang.IllegalStateException: No bean <span class="class"><span class="keyword">class</span> <span class="title">specified</span> <span class="title">on</span> <span class="title">bean</span> <span class="title">definition</span></span></span><br></pre></td></tr></table></figure>

<p><strong>bean的id只能指定一个且不能重复，但是name属性可以指定多个，使用，或；分隔。</strong></p>
<p>name属性是对bean取别名，通过name和通过id获取的bean是同一个bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean name <span class="string">&#x27;book&#x27;</span> is already used in <span class="keyword">this</span> &lt;beans&gt; element</span><br></pre></td></tr></table></figure>

<p>若需要使用有参构造方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b1;b2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.entity.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>通过静态方法创建bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置静态工厂，静态工厂创建对象的静态方法    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookStaticFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.factory.BookStaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    指定静态工厂创建bean    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.entity.Book&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookStaticFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>factory-method这个属性是配置在静态工厂的bean上的。</strong></p>
<p><strong>bean标签指定的class类型可以和静态工厂返回对象的类型不一样，在bean标签指定的class类型是通过构造方法创建对象时的实际类型，如果是通过静态工厂创建的对象，bean的实际类型是静态工厂返回对象的类型。</strong></p>
<p><strong>静态工厂本身的对象不能通过&amp;beanName来获取，因为它没有实现FactoryBean接口。</strong></p>
</li>
</ol>
<ol start="3">
<li><p>通过实例工厂创建bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置实例工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookInstanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.factory.BookInstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定实例工厂创建bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例工厂的配置和静态工厂有一点不同，<strong>实例工厂的factory-method属性是配置在要创建的bean上的，而静态工厂是配置的工程类的bean上</strong></p>
<p><strong>实例工厂不需要指定bean的class属性。</strong></p>
<p><strong>实例工厂获取被创建的对象是通过对象的bean id获取，而不是通过工厂的bean id。而静态工厂获取被创建的对象是通过静态工厂的bean id获取。</strong></p>
<p><strong>通过实例工厂bean id获取到的是实例工厂本身。</strong></p>
<p><strong>实例工厂可以创建不同的对象，只要指定一个实例工厂，工厂里可以有多个实例方法来创建对象。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置实例工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookInstanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.factory.BookInstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定实例工厂的getBookInstance方法创建book实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定实例工厂的getUserInstance方法创建user实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.通过FactoryBean接口创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.factory.BookFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.column.entity.Book&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要指定class属性，否则抛出异常。</strong></p>
<p><strong>这样配置，可以使用bean的构造方法来创建bean，也可以通过bookFactory来创建bean。使用bean的构造方法创建bean的实际类型取决于class属性，使用bookFactory创建bean的实际类型取决于bookFactory中getObjectType方法的返回值。</strong></p>
<p><strong>FactoryBean的实际类型是创建的对象的类型，如果需要获取FactoryBean的实例，需要使用&amp;+beanName的方式。</strong></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Resource接口.md</title>
    <url>/2020/09/15/Spring/Resource/</url>
    <content><![CDATA[<h3 id="JDK中加载资源的URL有什么缺点？"><a href="#JDK中加载资源的URL有什么缺点？" class="headerlink" title="JDK中加载资源的URL有什么缺点？"></a>JDK中加载资源的URL有什么缺点？</h3><p>JDK中的资源是通过java.net.URL类来加载的，但是它不够强大。但是它有缺点：</p>
<ul>
<li>DK中没有提供标准的URL实现类去加载classpath路径下的资源或者是相对于ServletContext的资源。虽然它能够注册新的处理器去处理特殊的前缀(比如http:// ,file//)，但一般说比较复杂。</li>
<li>URL接口提供的功能不够全面，缺乏很多基本的功能。比如检查所指向的资源是否存在等。</li>
</ul>
<h3 id="Spring中对资源的抽象"><a href="#Spring中对资源的抽象" class="headerlink" title="Spring中对资源的抽象"></a>Spring中对资源的抽象</h3><p>Spring 改进了 Java 资源访问的策略。Spring 为资源访问提供了一个 Resource 接口，该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/1645290-20190908175249585-769163389.png" alt="Resource接口"></p>
<p>getFile()和getURL()方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式用于封装系列的算法，这些算法通常被封装在一个被称为 Context 类中，客户端程序可以自由选择其中一种算法，或让 Context 为客户端选择一个最佳的算法——使用策略模式的优势是为了支持算法的自由切换。</p>
<p>Spring 提供两个标志性接口：</p>
<ul>
<li>ResourceLoader：该接口实现类的实例可以获得一个 Resource 实例。</li>
<li>ResourceLoaderAware：该接口实现类的实例将获得一个 ResourceLoader 的引用。</li>
</ul>
<p>在 ResourceLoader 接口里有如下方法：</p>
<p>Resource getResource(String location)：该接口仅包含这个方法，该方法用于返回一个 Resource 实例。ApplicationContext 的实现类都实现 ResourceLoader 接口，因此 ApplicationContext 可用于直接获取 Resource 实例。</p>
<p>此处 Spring 框架的 ApplicationContext 不仅是 Spring 容器，而且它还是资源访问策略的”决策者”，也就是策略模式中 Context 对象，它将为客户端代码”智能”地选择策略实现。</p>
<p>当 ApplicationContext 实例获取 Resource 实例时，系统将默认采用与 ApplicationContext 相同的资源访问策略。对于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource res = ctx.getResource(<span class="string">&quot;some/resource/path/myTemplate.txt);</span></span><br></pre></td></tr></table></figure>

<p>从上面代码中无法确定 Spring 将哪个实现类来访问指定资源，Spring 将采用和 ApplicationContext 相同的策略来访问资源。也就是说：如果 ApplicationContext 是 FileSystemXmlApplicationContext，res 就是 FileSystemResource 实例；如果 ApplicationContext 是 ClassPathXmlApplicationContext，res 就是 ClassPathResource 实例；如果 ApplicationContext 是 XmlWebApplicationContext，res 是 ServletContextResource 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring/spring-config.xml&quot;</span>);</span><br><span class="line">		Resource resource = applicationContext.getResource(<span class="string">&quot;text.txt&quot;</span>);</span><br><span class="line">    	<span class="comment">// class org.springframework.core.io.DefaultResourceLoader$ClassPathContextResource</span></span><br><span class="line">		System.out.println(resource.getClass());</span><br><span class="line">    	<span class="comment">// filename:text.txt</span></span><br><span class="line">		System.out.println(<span class="string">&quot;filename:&quot;</span>+resource.getFilename());</span><br><span class="line">    	<span class="comment">// description:class path resource [text.txt]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;description:&quot;</span>+resource.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于程序中使用了 ClassPathApplicationContext 来获取资源，所以 Spring 将会从类加载路径下来访问资源，也就是使用 ClassPathResource 实现类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;D:\\IDEA Pro\\spring-framework-5.2.0.RELEASE\\spring-framework-5.2.0.RELEASE\\spring-demo\\src\\main\\resources\\spring\\spring-config.xml&quot;</span>);</span><br><span class="line">		Resource resource = applicationContext.getResource(<span class="string">&quot;text.txt&quot;</span>);</span><br><span class="line">    	<span class="comment">// class org.springframework.core.io.FileSystemResource</span></span><br><span class="line">		System.out.println(resource.getClass());</span><br><span class="line">    	<span class="comment">// filename:text.txt</span></span><br><span class="line">		System.out.println(<span class="string">&quot;filename:&quot;</span>+resource.getFilename());</span><br><span class="line">    	<span class="comment">// description:file [D:\IDEA Pro\spring-framework-5.2.0.RELEASE\spring-framework-5.2.0.RELEASE\text.txt]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;description:&quot;</span>+resource.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的执行结果可以看出，程序的 Resource 实现类发了改变，变为 FileSystemResource 实现类。</p>
<p>另一方面使用 ApplicationContext 来访问资源时，也可不理会 ApplicationContext 的实现类，强制使用指定的 ClassPathResource、FileSystemResource 等实现类，这可通过不同前缀来指定，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;D:\\IDEA Pro\\spring-framework-5.2.0.RELEASE\\spring-framework-5.2.0.RELEASE\\spring-demo\\src\\main\\resources\\spring\\spring-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// class org.springframework.core.io.ClassPathResource</span></span><br><span class="line">    Resource resource = applicationContext.getResource(<span class="string">&quot;classpath:text.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，还可以使用标准的 <code>java.net.URL</code> 前缀来强制使用 <code>UrlResource</code> ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class org.springframework.core.io.FileUrlResource</span></span><br><span class="line">Resource resource = applicationContext.getResource(<span class="string">&quot;file:text.txt&quot;</span>);</span><br><span class="line"><span class="comment">// class org.springframework.core.io.UrlResource</span></span><br></pre></td></tr></table></figure>

<p>以下是常见前缀及对应的访问策略：</p>
<ul>
<li>classpath:以 ClassPathResource 实例来访问类路径里的资源。</li>
<li>file:以 UrlResource 实例访问本地文件系统的资源。</li>
<li>http:以 UrlResource 实例访问基于 HTTP 协议的网络资源。</li>
<li>无前缀:由于 ApplicationContext 的实现类来决定访问策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用指定前缀来加载资源，只对当次有效</span></span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath:spring/spring-config.xml&quot;</span>);</span><br><span class="line">    Resource resource = applicationContext.getResource(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 	class org.springframework.core.io.FileSystemResource</span></span><br><span class="line">    System.out.println(resource.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Spring 容器时，系统将从类加载路径来搜索 spring-config.xml；但使用 ApplicationContext 来访问资源时，依然采用的是 FileSystemResource 实现类，这与 FileSystemXmlApplicationContext 的访问策略是一致的。这表明：通过 classpath: 前缀指定资源访问策略仅仅对当次访问有效，程序后面进行资源访问时，还是会根据 AppliactionContext 的实现类来选择对应的资源访问策略。</p>
<p>因此如果程序需要使用 ApplicationContext 访问资源，建议显式采用对应的实现类来加载配置文件，而不是通过前缀来指定资源访问策略。当然，我们也可在每次进行资源访问时都指定前缀，让程序根据前缀来选择资源访问策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用指定前缀来加载资源，只对当次有效</span></span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath:spring/spring-config.xml&quot;</span>);</span><br><span class="line">    Resource resource = applicationContext.getResource(<span class="string">&quot;classpath:test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 	class org.springframework.core.io.ClassPathResource</span></span><br><span class="line">    System.out.println(resource.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，如果每次进行资源访问时指定了前缀，则系统会采用前缀相应的资源访问策略。</p>
<h3 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h3><p>Resource 接口本身没有提供访问任何底层资源的实现逻辑，针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</p>
<p>Resource 接口就是策略模式的典型应用，Resource 接口就代表资源访问策略，但具体采用哪种策略实现，Resource 接口并不理会。<strong>客户端程序只和 Resource 接口耦合</strong>，并不知道底层采用何种资源访问策略，这样应用可以在不同的资源访问策略之间自由切换。比如，使用SystemFileResource替换ClassPathResource，只需要切换Resource接口的实现类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;classpath:db.properties&quot;</span>);</span><br><span class="line"><span class="comment">// 相关的resource操作方法....</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> SystemFileResource(<span class="string">&quot;D://db.properties&quot;</span>);</span><br><span class="line"><span class="comment">// 相关的resource操作方法....</span></span><br></pre></td></tr></table></figure>

<p>Resource 不仅可在 Spring 的项目中使用，也可直接作为资源访问的工具类使用。意思是说：即使不使用 Spring 框架，也可以使用 Resource 作为工具类，用来代替 URL。当然，使用 Resource 接口会让代码与 Spring 的接口耦合在一起，但这种耦合只是部分工具集的耦合，不会造成太大的代码污染。</p>
<h3 id="Resource的实现类"><a href="#Resource的实现类" class="headerlink" title="Resource的实现类"></a>Resource的实现类</h3><p>Spring将常见的资源按照资源类型和路径分为了7大组，全部都实现了AbstractResource抽象类，分别如下：</p>
<ul>
<li><p>FileSystemResource     代表文件系统资源，以操作系统文件路径的方式访问</p>
</li>
<li><p>PathResource    代表文件系统资源，以Path对象访问</p>
</li>
<li><p>AbstractFileResolvingResource  代表需要解析的路径资源，如类资源Class  、URL资源等等  是个抽象类，有三个具体的实现</p>
</li>
<li><p>ByteArrayResource  代表字节数组资源</p>
</li>
<li><p>VfsResource  代表JBoss的虚拟文件系统VFS</p>
</li>
<li><p>InputStreamResource  代表输入二进制流的资源</p>
</li>
<li><p>DescriptiveResource 代表资源描述的资源，可以理解为资源的元数据(元资源) 不指向任何的实际资源对象</p>
</li>
</ul>
<h4 id="UrlResource的使用"><a href="#UrlResource的使用" class="headerlink" title="UrlResource的使用"></a>UrlResource的使用</h4><p>虽然 UrlResource 是为访问网络资源而设计的，但通过使用 file 前缀也可访问本地磁盘资源。如果需要访问网络资源，可以使用如下两个常用前缀：</p>
<ul>
<li>http:－该前缀用于访问基于 HTTP 协议的网络资源。</li>
<li>ftp:－该前缀用于访问基于 FTP 协议的网络资源。</li>
</ul>
<p>由于 UrlResource 是对 java.net.URL 的封装，所以 UrlResource 支持的前缀与 URL 类所支持的前缀完全相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// test.txt放在当前目录下</span></span><br><span class="line">		Resource resource = <span class="keyword">new</span> UrlResource(<span class="string">&quot;file:test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">// class org.springframework.core.io.UrlResource</span></span><br><span class="line">		System.out.println(resource.getClass());</span><br><span class="line">    	<span class="comment">// filename:test.txt</span></span><br><span class="line">		System.out.println(<span class="string">&quot;filename:&quot;</span>+resource.getFilename());</span><br><span class="line">    	<span class="comment">// description:URL [file:test.txt]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;description:&quot;</span>+resource.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassPathResource的使用"><a href="#ClassPathResource的使用" class="headerlink" title="ClassPathResource的使用"></a>ClassPathResource的使用</h4><p>ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 WEB-INF/classes 下的资源文件，无须使用绝对路径访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// test.txt放在resources文件夹下</span></span><br><span class="line">		Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;classpath:test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">// class org.springframework.core.io.ClassPathResource</span></span><br><span class="line">		System.out.println(resource.getClass());</span><br><span class="line">    	<span class="comment">// filename:classpath:test.txt</span></span><br><span class="line">		System.out.println(<span class="string">&quot;filename:&quot;</span>+resource.getFilename());</span><br><span class="line">    	<span class="comment">// description:class path resource [classpath:test.txt]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;description:&quot;</span>+resource.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassPathResource 实例可使用 ClassPathResource 构造器显式地创建，但更多的时候它都是隐式创建的，当执行 Spring 的某个方法时，该方法接受一个代表资源路径的字符串参数，当 Spring 识别该字符串参数中包含 classpath: 前缀后，系统将会自动创建 ClassPathResource 对象。</p>
<h4 id="FileSystemResource的使用"><a href="#FileSystemResource的使用" class="headerlink" title="FileSystemResource的使用"></a>FileSystemResource的使用</h4><p>与前两种 Resource 作资源访问的区别在于：资源字符串确定的资源，位于本地文件系统内 ，而且无须使用任何前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">&quot;D:\\IDEA Pro\\spring-framework-5.2.0.RELEASE\\spring-framework-5.2.0.RELEASE\\spring-demo\\src\\main\\resources\\test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">// class org.springframework.core.io.FileSystemResource	</span></span><br><span class="line">		System.out.println(resource.getClass());</span><br><span class="line">    	<span class="comment">// filename:test.txt</span></span><br><span class="line">		System.out.println(<span class="string">&quot;filename:&quot;</span>+resource.getFilename());</span><br><span class="line">    	<span class="comment">// description:file [D:\IDEA Pro\spring-framework-5.2.0.RELEASE\spring-framework-5.2.0.RELEASE\spring-demo\src\main\resources\test.txt]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;description:&quot;</span>+resource.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码不难发现，程序使用 UrlResource、FileSystemResource、ClassPathResource 三个实现类来访问资源的代码差异并不大，<strong>唯一的缺点在于客户端代码需要与 Resource 接口的实现类耦合，这依然无法实现高层次解耦。</strong></p>
<p>这对于策略模式来说将没有任何问题，策略模式要解决的就是这个问题，策略模式将会提供一个 Context 类来为客户端代码”智能”地选择策略实现类。</p>
<h3 id="Spring资源访问相关类"><a href="#Spring资源访问相关类" class="headerlink" title="Spring资源访问相关类"></a>Spring资源访问相关类</h3><p>所有资源高度抽象为二进制流，也就是不管你资源文件是什么格式，也不管你资源在哪里，Spring底层访问的都是文件的二进制流，这样就可以统一访问了。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/687300-20190301175101710-1284958427.png" alt="资源访问相关接口"></p>
<ul>
<li><p>EncodedResource类：</p>
<p>EncodedResource类是辅助类，从名字上可以看出，它是一个编码类。资源加载的时候，是采用操作系统默认的编码方式，为解决编码不统一的问题，Spring的IOC获取资源后，需要把资源重新编码一下。例如，在Spring应用程序上下文的 XmlBeanDefinitionReader 类中，获取了 资源后，需要对资源进一步解析，在解析之前，调用 new EncodedResource();</p>
</li>
<li><p>WritableResource接口：</p>
<p>Resource接口定义了资源的可访问等一系列的操作，但有些资源需要可写入的，如文件对象，因此还定义了WritableResource接口，继承了Resource接口，表示资源具有可写入的能力。</p>
<p>FileSystemResource既实现了Resource接口，又实现了Writable接口，实现了可写可读的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  判断资源是否可写入</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取资源写入的二进制流</span></span><br><span class="line">    <span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 获取资源可写入的字节管道对象</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> WritableByteChannel <span class="title">writableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Channels.newChannel(getOutputStream());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ContextResource接口：</p>
<p>ContextResource 接口也继承了Resource接口，表示可以从关闭的上下文Context中获取资源的路径，这样应用程序上下文也就有了返回上下文路径的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContextResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从关闭的上下文Context中获取资源的路径</span></span><br><span class="line">    <span class="function">String <span class="title">getPathWithinContext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractResource类：</p>
<p>AbstractResource 是个抽象类，Resource接口的大部分方法的默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先尝试判断文件是否存在，如果资源是文件形式，判断文件是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (isFile()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> getFile().exists();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果资源不是文件，回溯到二进制流，看二进制流是否能打开，如果可以，则就存在了</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			getInputStream().close();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断资源是否可读，如果资源存在，抽象类认为资源总是可读的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> exists();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断资源是否打开，抽象类认为资源总是关闭的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否是文件，抽象类认为资源不是文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该资源解析为URL，需要具体的子类去实现，这里抽象类假设都不能解析URL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() + <span class="string">&quot; cannot be resolved to URL&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该资源解析为URI</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取子类实现的URL,通过URL解析URI</span></span><br><span class="line">		URL url = getURL();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ResourceUtils.toURI(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Invalid URI [&quot;</span> + url + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该资源解析为File,抽象类认为都不解析为File</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() + <span class="string">&quot; cannot be resolved to absolute file path&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取资源的字节管道</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取资源的长度，通过获取资源二进制流，遍历计算资源的长度  字节为单位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStream is = getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">			<span class="keyword">int</span> read;</span><br><span class="line">			<span class="keyword">while</span> ((read = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				size += read;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更多方法查看源码.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ol>
<li>没有实现资源的根接口 InputStreamSource ，方法getInputStream() 留给具体的子类去实现</li>
</ol>
</li>
</ul>
<ol start="2">
<li>没有实现Resource接口的 getDescription() 方法，留给子类去实现，资源文件默认的equals()、hashCode() 都通过这个来判断</li>
</ol>
<h3 id="ResourceLoader接口"><a href="#ResourceLoader接口" class="headerlink" title="ResourceLoader接口"></a>ResourceLoader接口</h3><p>ResourceLoader接口使用策略模式来提供Resource：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200915225242681.png" alt="ResourceLoader"></p>
<p>DefaultResourceLoader是ResourceLoader的实现类，实现了获取一个resource的方法。</p>
<p>ResourcePatternResolver实现了获取多个resource的方法。ApplicationContext接口是ResourcePatternResolver接口的子接口，也就说明ApplicationContext能获取多个资源。</p>
<p>AbstractApplicationContext既实现了ResourcePatternResolver接口，又继承了DefaultResourceLoader类，所以容器具有获取一个resource和获取多个resource的能力。</p>
<p>我们来看一下DefaultResourceLoader的getResource方法是怎么通过策略模式返回不同的Resource实例的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 协议解析器解析，若指定了前缀file:或者http:等协议前缀，直接返回协议对应的Resource</span></span><br><span class="line"><span class="comment">	* 这也就是为什么可以通过指定前缀获取当次资源的Resource</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">        Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 如果是/开头，返回ClassPathResource</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 如果是classpath:开头，返回ClassPathResource</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">			* 尝试解析成UrlResource,如果是文件，返回FileUrlResource,如果不是返回UrlResource</span></span><br><span class="line"><span class="comment"> 			*/</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">            <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            <span class="comment">// 如果不能解析成UrlResource,使用ClassPathResource</span></span><br><span class="line">            <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="ResourceLoaderAware接口"><a href="#ResourceLoaderAware接口" class="headerlink" title="ResourceLoaderAware接口"></a>ResourceLoaderAware接口</h3><p>ResourceLoaderAware 接口则用于指定该接口的实现类必须持有一个 ResourceLoader 实例。</p>
<p>类似于 Spring 提供的 BeanFactoryAware、BeanNameAware 接口，ResourceLoaderAware 接口也提供了一个 setResourceLoader() 方法，该方法将由 Spring 容器负责调用，Spring 容器会将一个 ResourceLoader 对象作为该方法的参数传入。</p>
<p>当我们把将 ResourceLoaderAware 实例部署在 Spring 容器中后，Spring 容器会将自身当成 ResourceLoader 作为 setResourceLoader() 方法的参数传入，由于 ApplicationContext 的实现类都实现了 ResourceLoader 接口，Spring 容器自身完全可作为 ResourceLoader 使用。</p>
<h3 id="使用Resource作为属性"><a href="#使用Resource作为属性" class="headerlink" title="使用Resource作为属性"></a>使用Resource作为属性</h3><p>前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。</p>
<p>从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。</p>
<p>归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案：</p>
<ul>
<li>代码中获取 Resource 实例。</li>
<li>使用依赖注入。</li>
</ul>
<p>对于第一种方式的资源访问，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。</p>
<h3 id="加载多份配置文件"><a href="#加载多份配置文件" class="headerlink" title="加载多份配置文件"></a>加载多份配置文件</h3><p>classpath* : 前缀提供了装载多个 XML 配置文件的能力，当使用 classpath*: 前缀来指定 XML 配置文件时，系统将搜索类加载路径，找出所有与文件名的文件，分别装载文件中的配置定义，最后合并成一个 ApplicationContext。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath*:spring/spring-config.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在类路径下放置两份相同文件名的配置文件：</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200915214633261.png" alt="两份文件名相同的配置文件"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Loading XML bean definitions from URL [file:/G:/publish/codes/</span><br><span class="line"> 08/<span class="number">8.3</span>/ApplicationContext/classes/spring-config.xml]</span><br><span class="line"> Loading XML bean definitions from URL [file:/G:/publish/codes/</span><br><span class="line"> 08/<span class="number">8.3</span>/ApplicationContext/classes/spring/spring-config.xml]</span><br></pre></td></tr></table></figure>

<p>当使用 classpath*: 前缀时，Spring 将会搜索类加载路径下所有满足该规则的配置文件。</p>
<p>如果不是采用 classpath*: 前缀，而是改为使用 classpath: 前缀，Spring 只加载第一份符合条件的 XML 文件，例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath:spring/spring-config.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>执行上面代码将只看到如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Loading XML bean definitions from <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">spring</span>-<span class="title">config</span>.<span class="title">xml</span>]</span></span><br></pre></td></tr></table></figure>

<p>当使用 classpath: 前缀时，系统通过类加载路径搜索 spring-config.xml文件，如果找到文件名匹配的文件，系统立即停止搜索，装载该文件，即使有多份文件名匹配的文件，系统只装载第一份文件。资源文件的搜索顺序则取决于类加载路径的顺序，排在前面的配置文件将优先被加载。</p>
<p>另外，还有一种可以一次性装载多份配置文件的方式：指定配置文件时指定使用通配符，例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath:bean*.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>位于类加载路径下所有以 bean 开头的 XML 配置文件都将被加载。</p>
<p>除此之外，Spring 甚至允许将 classpath*: 前缀和通配符结合使用，如下语句也是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath*:bean*.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面语句创建 ApplicationContext 实例时，系统将搜索所有的类加载路径下，所有以 bean.xml 开头的 XML 配置文件</p>
<h3 id="file-前缀的用法"><a href="#file-前缀的用法" class="headerlink" title="file:前缀的用法"></a>file:前缀的用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过文件通配符来一次性装载多份配置文件</span></span><br><span class="line">        <span class="comment">//ApplicationContext ctx = newFileSystemXmlApplicationContext(&quot;bean.xml&quot;);</span></span><br><span class="line">        ApplicationContext ctx = newFileSystemXmlApplicationContext(<span class="string">&quot;/bean.xml&quot;</span>);</span><br><span class="line">        System.out.println(ctx);</span><br><span class="line">        <span class="comment">// 使用 ApplicationContext 的默认策略加载资源，没有指定前缀</span></span><br><span class="line">        Resource r = ctx.getResource(<span class="string">&quot;book.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出 Resource 描述</span></span><br><span class="line">        System.out.println(r.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序有两行粗体字代码用于创建 ApplicationContext，第一行粗体字代码指定资源文件时采用了相对路径的写法,第二行粗体字代码指定资源文件时采用了绝对路径的写法。</p>
<p>任意注释两条语句的其中之一，程序正常执行，没有任何区别，两句代码读取了相同的配置资源文件。问题是：如果程序中明明采用的一个是绝对路径、一个相对路径，为什么执行效果没有任何区别？</p>
<p>产生问题的原因：当 FileSystemXmlApplicationContext 作为 ResourceLoader 使用时，它会发生变化，FileSystemApplicationContext 会简单地让所有绑定的 FileSystemResource 实例把绝对路径都当成相对路径处理，而不管是否以斜杠开头，所以上面两行代码的效果是完全一样的。</p>
<p>如果程序中需要访问绝对路径，则不要直接使用 FileSystemResource 或 FileSystemXmlApplicationContext 来指定绝对路径。建议强制使用 file: 前缀来区分相对路径和绝对路径，例如如下两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问相对路径下的 bean.xml</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;file:bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 访问绝对路径下 bean.xml</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;file:/bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>相对路径以当前工作路径为路径起点，而绝对路径以文件系统根路径为路径起点。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器.md</title>
    <url>/2020/09/15/Spring/Spring%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简单容器BeanFactory"><a href="#简单容器BeanFactory" class="headerlink" title="简单容器BeanFactory"></a>简单容器BeanFactory</h3><p>BeanFactory接口是Spring中的简单容器。它定义了一个常量和多个bean操作相关的方法。</p>
<img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200920122506382.png" alt="BeanFactory简单容器" style="zoom: 67%;" />

<p>其中，FACTORY_BEAN_PREFIX定义了访问FactoryBean的前缀。由于通过FactoryBean的beanName获取的对象是FactoryBean生产的对象，而通过&amp;beanName能获取到FactoryBean本身。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200920131516053.png" alt="BeanFactory继承关系"></p>
<ul>
<li>AutowireCapableBeanFactory：可以用来加载第三方的bean，由于无法在第三方提供的bean源代码中将其加入到Spring容器，所以需要这个接口。其中定义了装配bean的策略，比如byName、byType。</li>
<li>HierarchicalBeanFactory：定义了层级关系， 接口中getParentBeanFactory方法能获取父级容器BeanFactory.</li>
<li>ListableBeanFactory：能以列表的形式返回bean的信息。该接口的方法多数返回值为数组类型</li>
<li>ConfigurableListableBeanFactory：定义了能配置容器的方法，比如ignoreDependencyType能忽略某些依赖的注入</li>
<li>DefaultListableBeanFactory：抽象类，主要实现了容器中一些通用的方法。此外，它还实现了BeanDefinitionRegistry接口，是一个可独立运行的容器。其中定义了一个ConcurrentHashMap的成员变量beanDefinitionMap，这个map就是存放bean的容器。</li>
</ul>
<blockquote>
<p>在整个Spring框架中，只有2个地方定义了beanDefinitionMap，一个是DefaultListableBeanFactory类，一个是SimpleBeanDefinitionRegistry类，Spring默认是使用DefaultListableBeanFactory来存放bean</p>
</blockquote>
<h3 id="高级容器ApplicationContext"><a href="#高级容器ApplicationContext" class="headerlink" title="高级容器ApplicationContext"></a>高级容器ApplicationContext</h3><p>高级容器 ApplicationContext在BeanFactory的基础上实现了更多的接口，提供了更多的功能。相比于BeanFactory，ApplicationContext是面向Spring框架用户使用的，而BeanFactory更多的是Spring内部使用的容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">		<span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>EnvironmentCapable：该接口中的getEnvironment能获取web.xml文件中的信息，比如在使用Spring MVC时，需要获取配置文件存放路径</li>
<li>ResourcePatternResolver：该接口能解析多个Resource资源文件，支持classpath*的前缀</li>
</ul>
<p>ApplictionContext接口提供的方法都是”可读”的方法，而ConfigurableApplicationContext接口提供了可以配置ApplicationContext的方法，比如refresh、close等方法。</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/image-20200920133717208.png" alt="ConfigurableApplicationContext与ApplicationContext的关系"></p>
<p>AbstractApplicationContext类实现了ConfigurableApplicationContext中的通用方法，包括refresh方法：</p>
<p>refresh方法使用了模板方法的设计模式，模板方法设计模式主要包含以下四种方法：</p>
<ul>
<li>模板方法：组合一些方法的执行流程</li>
<li>具体方法：具体实现的一些通用方法</li>
<li>钩子方法：视情况决定是否执行的方法，子类可以实现，也可以不实现</li>
<li>抽象方法：带有abstract关键字，子类必须实现的方法</li>
</ul>
<p>refresh方法就是模板方法，定义了一系列容器初始化，配置解析的方法。</p>
<p>prepareRefresh方法是具体方法，AbstractApplicationContext提供了该方法的实现。</p>
<p>obtainFreshBeanFactory是抽象方法，AbstractApplicationContext并不做具体实现，该方法由子类实现。</p>
<p>postProcessBeanFactory是钩子方法，子类根据情况，决定实现与否。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁保证线程安全，避免在refresh的时候，容器再次被初始化或者destroy</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 容器初始化准备工作，主要是设置容器启动时间，检验必须的属性等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉子类刷新内部容器</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器配置，比如设置resourceLoader等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 钩子方法，默认无实现，将由子类视情况实现.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refresh方法详解"><a href="#refresh方法详解" class="headerlink" title="refresh方法详解"></a>refresh方法详解</h3><p>prepareRefresh方法，容器刷新前的准备工作：</p>
<p>主要是记录容器启动的时间，设置容器的状态，存储事件监听器，创建事件集合等。</p>
<p>this指的是ApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">rotected <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录容器启动时间</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 设置容器状态，closed、active是AtomicBoolean类型的</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化propertySources属性，&lt;context:property-placeholder location=&quot;&quot;/&gt;</span></span><br><span class="line">    <span class="comment">// 该方法由子类实现</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证所有标记为必需的属性都是可解析的，检查是否有必需的属性还没加载进来</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储刷新前注册的监听器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件集合</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obtainFreshBeanFactory：</p>
<p>对于xml的方式，在此方法中创建DefaultListableBeanFactory工厂，将BeanDefinition注册到容器中，返回DefaultListableBeanFactory容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于注解的方式，真正调用的是GenericApplicationContext方法。</p>
<p>注解方式在创建容器的构造方法中，就已经创建了DefaultListableBeanFactory容器，这里置需要将refreshed标志从false改为true(refreshed是AtomicBoolean类型)，设置SerializationId后返回DefaultListableBeanFactory容器即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>prepareBeanFactory(beanFactory);</p>
<p>为DefaultListableBeanFactory设置一些属性，注册一些默认的Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 为DefaultListableBeanFactory工厂设置容器的类加载器，这样就可以去加载外部容器的资源了</span></span><br><span class="line">		beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">		<span class="comment">// 设置表达式解析器，比如spel表达式解析器</span></span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		<span class="comment">// 设置一个默认的属性编辑器</span></span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 设置后置处理器，该处理器的作用是当应用程序定义的bean实现ApplicationContextAware接口时，</span></span><br><span class="line"><span class="comment">		 注入ApplicationContext对象</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 如果某个bean依赖于以下接口的实现类，在自动装配的时候忽略它们</span></span><br><span class="line"><span class="comment">		 Spring会通过其他方式来处理这些依赖</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 设置自动装配的特殊规则，比如是BeanFactory接口的实现类，在运行时修订为当前的BeanFactory</span></span><br><span class="line"><span class="comment">		 *  this指的是AbstractApplicationContext,因为AbstractApplicationContext实现了BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext接口</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注册一个后置处理器，用于检查内部的bean是不是ApplicationListener,如果是则加入到事件监听队列</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register default environment beans.</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>postProcessBeanFactory(beanFactory);</p>
<p>这是一个钩子方法，允许容器的子类去注册后置处理器。</p>
<p>invokeBeanFactoryPostProcessors(beanFactory);</p>
<p>调用容器注册的容器级别的后置处理器。</p>
<p>registerBeanPostProcessors(beanFactory);</p>
<p>处理完BeanFactoryPostProcessors,接着注册BeanPostProcessors</p>
<p>initMessageSource();</p>
<p>国际化消息处理。</p>
<p>initApplicationEventMulticaster()</p>
<p>初始化ApplicationMulitCaster做为事件的发布者，可以存储所有事件监听者的信息，并根据不同的事件，通知不同的事件监听者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取DefaultListableBeanFactory</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    	<span class="comment">// 如果容器中包含了ApplicationMulitCaster，取出赋值</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 容器中没有，使用默认的SimpleApplicationEventMulticaster</span></span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">						<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>onRefresh();</p>
<p>预留给ApplicationContext子类用于初始化其他特殊的bean，该方法需要在所有单例bean初始化之前调用.</p>
<p>finishBeanFactoryInitialization()</p>
<p>初始化ConvertService，实例化bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化ConvertService类型转换器，转换器的作用是为bean属性赋值的时候进行类型转换工作</span></span><br><span class="line">		<span class="comment">// 只有Spring容器本身不支持的类型，才需要类型转换器</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有注册过bean的后置处理器，则注册默认的解析器</span></span><br><span class="line">		<span class="comment">// 解析器主要用于解析properties的PropertiesPlaceholderConfigurer</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 停止使用临时的类加载器</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 允许缓存所有bean定义的元数据，不希望有进一步的修改</span></span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实例化所有非延时加载的单例</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>preInstantiateSingletons()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">		<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">		List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			<span class="comment">// 兼容各种BeanDefinition，GenericBeanDefinition可以转换成RootBeanDefinition</span></span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="comment">// 非抽象类 ，单例且不是延迟加载的</span></span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 处理FactoryBean的实例</span></span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">						<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">						<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 处理普通bean的实例</span></span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">				<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>finishRefresh</p>
<p>清除缓存，发布容器刷新完成的事件等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 清除一些上下文级别的资源缓存</span></span><br><span class="line">		clearResourceCaches();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化生命周期处理器</span></span><br><span class="line">		initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 首先将刷新传播到生命周期处理器</span></span><br><span class="line">		getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发布容器刷新完成的事件给事件监听者</span></span><br><span class="line">		publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">		LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="xml配置文件注册BeanDefinition流程"><a href="#xml配置文件注册BeanDefinition流程" class="headerlink" title="xml配置文件注册BeanDefinition流程"></a>xml配置文件注册BeanDefinition流程</h3><p>configLocation是配置文件的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this(new String[] {configLocation}, true, null);</p>
<p>refresh默认值是true，也就是容器启动的时候，会调用refresh方法。refresh方法在AbstractApplicationContext类中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 容器初始化准备工作，主要是设置容器启动时间，检验必须的属性等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉子类刷新内部容器</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有关postProcessBeanFactory的相关操作...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>obtainFreshBeanFactory():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refreshBeanFactory():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭之前的beanFactory</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新的beanFactory，使用DefaultListableBeanFactory来加载beanDefinition</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载bean定义信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AbstractXmlApplicationContext : loadBeanDefinitions(beanFactory);</p>
<p>创建XmlBeanDefinitionReader来解析xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    <span class="comment">// this -&gt; ClassPathApplicationContext,所有的applicationContext都实现了ClassLoader接口</span></span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 调用重载的方法加载beanDefinition</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractXmlApplicationContext : loadBeanDefinitions(XmlBeanDefinitionReader reader);</p>
<p>根据reader读取的配置文件，去加载beanDefinition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractBeanDefinitionReader:loadBeanDefinitions(String… locations);</p>
<p>该方法可以加载多个配置文件，实际上就通过for循环调用加载一个配置文件的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractBeanDefinitionReader:loadBeanDefinitions(String location);</p>
<p>加载一个配置文件的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractBeanDefinitionReader:loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)</p>
<p>调用本类的其他重载方法。在这个方法中，获取了resourceLoader。通过resourceLoader的实例类型，判断是加载单个资源还是多个资源，最终调用子类的loadBeanDefinitions(Resource… resources)或者loadBeanDefinitions(Resource resources)方法来加载一个或多个资源。此时已经将配置文件的location转换成了Spring抽象的Resource接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// location转换成了Resource</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加载单个资源</span></span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XmlBeanDefinitionReader:loadBeanDefinitions(Resource resource)</p>
<p>如果设置了编码，使用EncodeResource进行编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ThreadLocal,当前资源</span></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取资源流</span></span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转换成InputSource</span></span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="comment">// 如果设置了编码，则进行编码操作</span></span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 真正加载Bean</span></span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XmlBeanDefinitionReader:ldoLoadBeanDefinitions(InputSource inputSource, Resource resource)</p>
<p>解析xml，获取document对象。根据document对象和配置文件的resource来注册beanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解析xml，获取document</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 注册bean</span></span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XmlBeanDefinitionReader:registerBeanDefinitions(Document doc, Resource resource)</p>
<p>创建document的解析对象，调用documentReader.registerBeanDefinitions来注册beanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建DefaultBeanDefinitionDocumentReader来解析document</span></span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="comment">// 注册前bean的数量，registry=DefaultListableRegistry</span></span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="comment">// 注册后bean的数量</span></span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerBeanDefinitions由子类实现，因为创建的是DefaultBeanDefinitionDocumentReader对象来解析document，所以使用DefaultBeanDefinitionDocumentReader实现的registerBeanDefinitions方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultBeanDefinitionDocumentReader:doRegisterBeanDefinitions()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">	<span class="comment">// 验证profile，BeanDefinitionParseDelegate</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                 <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子函数，处理xml前做的事情，默认什么都不执行</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析beanDefinition</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 处理xml后做的事情</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultBeanDefinitionDocumentReader:parseBeanDefinitions()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			NodeList nl = root.getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">				Node node = nl.item(i);</span><br><span class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">					Element ele = (Element) node;</span><br><span class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                          <span class="comment">// 解析spring默认的配置文件</span></span><br><span class="line">						parseDefaultElement(ele, delegate);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="comment">// 解析自定义的配置文件</span></span><br><span class="line">						delegate.parseCustomElement(ele);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			delegate.parseCustomElement(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultBeanDefinitionDocumentReader:parseDefaultElement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 配置文件中import了其他配置文件，将其他配置文件的bean加入到容器中</span></span><br><span class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">			importBeanDefinitionResource(ele);</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 配置文件中指定了alias别名标签</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">			processAliasRegistration(ele);</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 处理配置文件中的bean标签</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">			processBeanDefinition(ele, delegate);</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 处理配置文件中的beans标签，递归处理</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// recurse</span></span><br><span class="line">			doRegisterBeanDefinitions(ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultBeanDefinitionDocumentReader:processBeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// bdHolder封装了BeanDefinition和beanName</span></span><br><span class="line">		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">		<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">				getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">						bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 发生注册完成事件</span></span><br><span class="line">			getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用BeanDefinitionReaderUtils.registerBeanDefinition的方法将bean加入到容器当中：</p>
<p>参数BeanDefinitionRegistry是默认的DefaultListableBeanFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// beanName为key,beanDefinition为value，注册到beanDefinitionMap中</span></span><br><span class="line">		String beanName = definitionHolder.getBeanName();</span><br><span class="line">		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将bean的别名注册到容器当中，这里处理的是bean标签上的name别名，区别于外层处理的alias</span></span><br><span class="line">		String[] aliases = definitionHolder.getAliases();</span><br><span class="line">		<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">				registry.registerAlias(beanName, alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DefaultListableBeanFactory.registerBeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">		Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 验证是否有方法重写</span></span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 容器中是否已经注册过了该beanName</span></span><br><span class="line">		BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">				<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">							existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 如果beanName已经存在，检查是否允许重写，是否有权限等，</span></span><br><span class="line">             <span class="comment">// 检查通过就覆盖原来容器中的bean</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// bean已经开始创建，说明beanDefinition已经注册到容器当中了，是一个增量操作</span></span><br><span class="line">			<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">				<span class="comment">// 锁住原来的容器，往里面添加</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">					List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                      <span class="comment">// 先添加原来容器的beanDefinition</span></span><br><span class="line">					updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                     <span class="comment">// 再添加新增的beanDefinition</span></span><br><span class="line">					updatedDefinitions.add(beanName);</span><br><span class="line">                     <span class="comment">// 覆盖原来的容器</span></span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                     <span class="comment">// 更新原来的单例，因为原来是单例模式的，现在可能不再是单例了</span></span><br><span class="line">					removeManualSingletonName(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 使用原来的容器，添加新的beanDefinition</span></span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查是否有同名的beanDefinition已经在容器中注册</span></span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 重置所有已经注册过的beanDefinition的缓存</span></span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultListableBeanFactory.updateManualSingletonNames</p>
<p>removeManualSingletonName实际上是调用 updateManualSingletonNames方法。</p>
<p>该方法会先判断是否已经创建bean了，如果已经创建了bean，对原来的容器加锁，重新创建新的单例。因为更新之后可能原来是单例的bean，现在已经不是单例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateManualSingletonNames</span><span class="params">(Consumer&lt;Set&lt;String&gt;&gt; action, Predicate&lt;Set&lt;String&gt;&gt; condition)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// 更新原先创建的单例</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">					action.accept(updatedSingletons);</span><br><span class="line">					<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 先前没有创建过，直接将新增的单例对象添加进去</span></span><br><span class="line">			<span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">				action.accept(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultListableBeanFactory.resetBeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 清除合并出来的beanDefinition</span></span><br><span class="line">		clearMergedBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将相关的单例删除掉</span></span><br><span class="line">		destroySingleton(beanName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 做一些后置的清除操作</span></span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (processor <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归，如果一个bean的parent已经重新设置了，它也需要重新设置</span></span><br><span class="line">		<span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">				BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">				<span class="keyword">if</span> (bd != <span class="keyword">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">					resetBeanDefinition(bdName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析到这里，Spring就将在xml配置中的bean标签加入到了容器beanDefinitionMap中，整个过程调用的方法非常多，这是因为Spring为了扩展性，将代码逻辑分成了多个方法。</strong></p>
<p>小结：</p>
<ul>
<li>加载配置文件</li>
<li>创建XmlBeanDefinitionReader读取配置文件，获取document对象</li>
<li>创建DefaultBeanDefinitionDocumentReader解析document<ul>
<li>import标签：importBeanDefinitionResource</li>
<li>alias标签：processAliasRegistration</li>
<li>bean标签：processBeanDefinition</li>
<li>beans标签：递归处理，重复前3步的处理</li>
</ul>
</li>
<li>拿到BeanDefinitionHolder，BeanDefinitionHolder封装了BeanDefinition和beanName。调用BeanDefinitionReaderUtils.registerBeanDefinition方法注册BeanDefinition</li>
<li>BeanDefinitionReaderUtils调用BeanDefinitionRegistry的registerBeanDefinition方法<ul>
<li>validate(),</li>
<li>判断容器中是否已经存在beanName对应的BeanDefinition，如果有已存在的beanName,检查是否有权限，有角色覆盖，有的话就覆盖</li>
<li>判断是否已经创建bean，如果已经创建了bean，说明了容器已经在使用了，这次操作是一个增加操作。需要将原来的容器加锁，并更新原来的单例对象(因为现在的对象可能是多例，而不再是单例)</li>
</ul>
</li>
</ul>
<h3 id="注解方式注册BeanDefinition流程"><a href="#注解方式注册BeanDefinition流程" class="headerlink" title="注解方式注册BeanDefinition流程"></a>注解方式注册BeanDefinition流程</h3><p>xml配置文件的BeanDefinition注册都是在refresh方法中的obtainFreshBeanFactory刷新容器时注册的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>而注解方式的BeanDefinition注册有3中情况：</p>
<ol>
<li>内置BeanDefinition：在容器的构造函数中被调用的时候就注册到容器</li>
<li>用户自定义的标记@Configuration的BeanDefinition：在容器构造函数中调用registry方法注册到容器</li>
<li>常规的BeanDefinition(不标记@Configuration注解)：在refresh方法中的后置处理器中注册到容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    scan(basePackages);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this();</p>
<p>初始化AnnotatedBeanDefinitionReader，ClassPathBeanDefinitionScanner路径扫描器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数this是指AnnotationConfigApplicationContext本身，它的成员变量中还有一个属性beanFactory，默认是DefaultListableBeanFactory.</p>
<p>与xml的方式对比，基于注解的容器创建beanFactory的时机比较早，这是因为有一些内置BeanDefinition需要先注册到容器中。</p>
<p>在创建AnnotatedBeanDefiniftionReader的时候，就已经将内置BeanDefinition注册到容器当中了。</p>
<p>将AnnotationConfigApplicationContext作为BeanDefinitionRegistry传递给AnnotatedBeanDefinitionReader的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AnnotatedBeanDefinitionReader的构造函数中就已经调用registerAnnotationConfigProcessors来注册内部BeanDefiniton了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationConfigUtils.registerAnnotationConfigProcessors:</p>
<p>主要是使用DefaultListableBeanFactory，将内置BeanDefinition加入到容器当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将registry转换成DefaultListableBeanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...如果不存在内置的BeanDefinition,就加入到容器当中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在创建AnnotedBeanDefinitionReader时将内置BeanDefiniton加入到容器中后，创建路径扫描器ClassPathBeanDefinitionScanner。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useDefaultFilters = true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断BeanDefinitionRegistry是不是ResourceLoader的实例，如果是的话，就将它当成ResourceLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>(registry, useDefaultFilters, environment,</span><br><span class="line">         (registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置ClassPathBeanDefinitionScanner的一些属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">        registerDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line">    setEnvironment(environment);</span><br><span class="line">    setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建好AnnotedBeanDefinitionReader和ClassPathBeanDefinitonScanner之后，调用register方法开始注册标记有@Configuration的BeanDefiniton</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">    <span class="comment">// this.reader = AnnotedBeadnDefinitionReader</span></span><br><span class="line">    <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入AnnotedBeanDefinitionReader类中执行register方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环扫描所有标记@Configuration的类，准备注册到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用AnnotedBeanDefinitionReader类中的doRegisterBean方法，将Class包装成BeanDefinition，处理类上标记的注解，再调用BeanDefinitionReaderUtils.registerBeanDefinition将BeanDefinitonHolder包装类注册到容器当中，后面的流程与xml的方式是相同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将Class包装成BeanDefinition</span></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 处理@Scope注解</span></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		<span class="comment">// 如果没有指定beanName,使用默认的生成机制</span></span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		<span class="comment">// 处理@Primary,@Lazy等注解，设置相应的属性</span></span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取BeanDefinition的包装类</span></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		<span class="comment">// 是否依据Spring的Scope生成动态代理对象</span></span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		<span class="comment">// 注册BeanDefinition</span></span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在调用完register方法将标注@Confiuration的BeanDefinition加入到容器后，会调用refresh方法将普通的BeanDefinition（没有标记@Configuration）注册到容器当中。</p>
<p>当使用xml方式注册BeanDefiniton时，调用的是refresh方法中的obtainFreshBeanFactory将BeanDefinition注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>而当使用注解方式注册普通的BeanDefiiton时，调用的是refresh方法中的invokeBeanFactoryPostProcessors来将BeanDefinition注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>

<p>invokeBeanFactoryPostProcessors方法中调用PostProcessorRegistrationDelegate代理来调用invokeBeanFactoryPostProcessors方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 使用PostProcessorRegistrationDelegate来执行后置处理器，</span></span><br><span class="line">    	<span class="comment">// beanFactory = DefaultListableBeanFactory</span></span><br><span class="line">		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">		<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<p>如何注册委托给你AnnotationBeanDefinitionRead类的regist方法来实现</p>
<p>doRegisterBean(beanClass, null, null, null, null);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将Class包装成BeanDefinition</span></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 处理@Scope注解</span></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		<span class="comment">// 如果没有指定beanName,使用默认的生成机制</span></span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		<span class="comment">// 处理@Primary,@Lazy等注解，设置相应的属性</span></span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取BeanDefinition的包装类</span></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		<span class="comment">// 是否依据Spring的Scope生成动态代理对象</span></span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		<span class="comment">// 注册BeanDefinition</span></span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果使用@Component，@Controller，@Service，@Repository注解标记的类，是在refresh方法中才注册到容器当中。</p>
<p>但是与XML的方式不同，XML是在下面一行代码的时候进行注册到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>注解的方式是在容器调用其后置处理器的时候，触发对BeanDefinition的注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>



<h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure>

<p><strong>从三级缓存中获取单例对象，</strong></p>
<p>二级缓存：在一级缓存中获取不到bean实例，且实例正在创建的时候会去二级缓存查找</p>
<p>三级缓存：在二级缓存中获取不到bean实例，且允许循环依赖，会去三级缓存中查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allowEarlyReference：是否允许循环依赖，传参进来是true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 尝试从一级缓存中获取bean实例，一级缓存中保存的都是最终形态的bean</span></span><br><span class="line">		<span class="comment">// 一级缓存是线程安全的ConcurrencyHashMap</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="comment">// 如果从一级缓存中获取不到bean实例，并且单例的bean当前正在创建</span></span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="comment">// 给一级缓存对象加锁，因为要操作缓存了</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">				<span class="comment">// 尝试从二级缓存中获取bean实例，二级缓存中保存的是还没给属性赋值的bean</span></span><br><span class="line">				<span class="comment">// 二级缓存是普通的HashMap,因为有了synchronized关键字,能保证是线程安全的了</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="comment">// 如果从二级缓存中获取不到bean实例，并且允许循环引用</span></span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					<span class="comment">// 尝试从三级缓存中获取bean实例,三级缓存中存储的是ObjectFactory</span></span><br><span class="line">					<span class="comment">// 三级缓存也是普通的HashMap</span></span><br><span class="line">					<span class="comment">// ObjectFactory是Spring内部使用的,通过getObject方法可以获取Factory创建的bean实例</span></span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="comment">// 此时bean实例的属性可能还未被注入,将bean实例放进二级缓存中</span></span><br><span class="line">						<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="comment">// 从三级缓存中移除，因为bean实例只能在三级缓存的任一个缓存中保存</span></span><br><span class="line">						<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 如果获取到单例对象，且参数为空，执行if逻辑<br> 这里判断参数是否为空，如果参数不为空，需要赋值操作，就不是直接返回bean了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="comment">// bean还在创建，说明循环依赖了</span></span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 无论是否循环依赖，都会执行；</span></span><br><span class="line">			<span class="comment">// 如果是普通的bean,则直接返回。如果是BeanFactory,则调用它的getObject()方法</span></span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</p>
<p>判断bean是不是FactoryBean，一系列检查判断后，是的话调用其getObject方法创建bean实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断beanName是否以&amp;开头</span></span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">return</span> beanInstance;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果beanName以&amp;开头，但又不是FactoryBean,抛出异常</span></span><br><span class="line">			<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不是以&amp;开头，是普通的bean，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 以下逻辑为FactoryBean创建bean实例返回</span></span><br><span class="line">		Object object = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 单例模式下，FactoryBean仅会创建出一个bean实例</span></span><br><span class="line">			<span class="comment">// 因此需要优先从缓存获取</span></span><br><span class="line">			<span class="comment">// 这里的缓存不是三级缓存</span></span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			<span class="comment">// 传参进来的BeanDefinition为空，尝试从容器中获取该beanName的BeanDefinition</span></span><br><span class="line">			<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// synthetic标识某个类是不是Spring容器内部生成的bean</span></span><br><span class="line">			<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">             <span class="comment">// 调用getObject方法创建出bean实例，并放在factorybeanObject缓存中，下次直接从缓存中获取</span></span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>object = getObjectFromFactoryBean(factory, beanName, !synthetic);</p>
<p>调用getObject创建bean对象，考虑是否需要单例…并执行后置处理器方法后，将创建后的bean加入factorybeanObject缓存，下次直接从缓存中获取单例对象。</p>
<p>这里保证单例模式，使用的是双重检查机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果需要在工厂模式下维持单例</span></span><br><span class="line">		<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">			<span class="comment">// 双重检查机制保证单例，对一级缓存加锁，防止多线程下,有别的线程已完成对单例bean的实例化</span></span><br><span class="line">			<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">				Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 调用工厂的getObject方法，创建bean实例</span></span><br><span class="line">					object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">					<span class="comment">// 看看此时是否有别的线程先创建好了bean实例，如果是，使用最先创建出来的bean，以保证单例</span></span><br><span class="line">					Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">						object = alreadyThere;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 该bean是否需要后置处理</span></span><br><span class="line">						<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">							<span class="comment">// 如果别的线程正在创建该bean，但是还没有进行后置处理，直接返回</span></span><br><span class="line">							<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">								<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">								<span class="keyword">return</span> object;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="comment">// 后置处理完成前，先加入缓存里锁定起来</span></span><br><span class="line">							beforeSingletonCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">// 触发BeanPostProcessor,第三方框架可以在此用AOP来包装bean实例</span></span><br><span class="line">								object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">										<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								<span class="comment">// 后置处理完成后，从缓存锁定的名字里清除</span></span><br><span class="line">								afterSingletonCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">							<span class="comment">// 将其放入factorybeanObject的缓存，证明单例已经创建完成了</span></span><br><span class="line">							<span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> object;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不是单例，则直接创建返回bean实例</span></span><br><span class="line">			Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">			<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    若scope为prototype,或者是单例模式但是缓存中还不存在，就执行else分支</p>
<p><strong>首先是对循环依赖的判断</strong>，如果存在循环依赖，Spring无法处理，直接抛出异常</p>
<p><strong>如果不是循环依赖，且容器存在父容器，则递归去父容器中获取bean实例</strong>，递归的方式分几种</p>
<ul>
<li>如果父容器是AbstractBeanFactory的实例，调用其doGetBean方法递归</li>
<li>如果父容器不是AbstractBeanFactory的实例<ul>
<li>参数不为空，委托父容器根据beanName和args进行查找</li>
<li>如果参数为空，但getBean传入的Class不为空，委托父容器根据beanName和Class去查找bean实例</li>
<li>如果参数和Class都为空，委托父容器根据beanName查找</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果scope为prototype并且正在创建中，基本上是循环依赖的情况</span></span><br><span class="line">    <span class="comment">// 比如A依赖于B,B又依赖于A(需要创建A),此时A还未创建完成，就形成了循环依赖</span></span><br><span class="line">    <span class="comment">// 针对prototype的循环依赖，spring无解，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="comment">// 如果存在父容器且当前容器中找不到beanName,递归查找父容器</span></span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">        <span class="comment">// 主要是针对FactoryBean,将&amp;重新加上</span></span><br><span class="line">        String nameToLookup = originalBeanName(name);</span><br><span class="line">        <span class="comment">// 如果父容器依旧是AbstractBeanFactory的实例</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// 递归调用方法来查找</span></span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="comment">// 如果有参数，则委派父级容器根据指定名称和显示的参数查找</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="comment">// 委派父级容器根据指定名称和类型查找</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 委派父级容器根据指定名称查找，递归</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能从父容器中递归查找出bean实例，就返回bean实例了。如果查找不到，就要开始创建bean实例了</p>
<p>typeCheckOnly是通过传参进来的，typeCheckOnly=true代表只是进行类型检查， 而不创建bean实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeCheckOnly是为了检查getBean是否仅仅是为了类型检查获取bean,而不是创建bean</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">    <span class="comment">// 如果不是类型检查，则需要重新合并BeanDefinition,并标记已经创建或即将创建的beanName</span></span><br><span class="line">    <span class="comment">// 这一步只是设置了标记位，并未真正的进行操作</span></span><br><span class="line">    markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例前，需要重新合并BeanDefinition，防止原来的数据改动，并且将已经创建或即将创建的beanName加入到alreadyCreated这个set集合中。而在markBeanAsCreated方法中，先设置好标记位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">markBeanAsCreated</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 双重检查机制,</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">      <span class="comment">// 即将操作mergedBeanDefinitions，先上锁保证线程安全</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 将原先合并之后的RootBeanDefinition的需要重新合并的状态设置为true</span></span><br><span class="line">            <span class="comment">// 表示需要重新合并一遍,以防原数据的改动</span></span><br><span class="line">            clearMergedBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 将已经创建好的或正在创建的Bean的名称加到alreadyCreated这个缓存中</span></span><br><span class="line">            <span class="keyword">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，<strong>从当前容器中获取BeanDefinition实例，如果设置了depend-on属性，递归实例化显示依赖的depend-on实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将父类的BeanDefinition与子类的BeanDefinition进行合并覆盖</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 对合并好的BeanDefinition做验证,主要看是否为abstract的</span></span><br><span class="line"><span class="comment">// 如果BeanDefinition是abstract的，会抛出BeanIsAbstractException异常</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"><span class="comment">// 如果当前bean设置了depend-on属性</span></span><br><span class="line"><span class="comment">// depend-on属性用来指定bean初始化以及销毁的顺序</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">        <span class="comment">// 校验是否存在循环依赖,如果有,直接抛出异常</span></span><br><span class="line">        <span class="comment">// 注意这里的key是</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                            <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存依赖调用</span></span><br><span class="line">        registerDependentBean(dep, beanName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 递归调用getBean方法，注册bean之间的依赖</span></span><br><span class="line">            getBean(dep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                            <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dependentBeanMap是一个ConcurrencyHashMap,它的key为beanName,values为dependentBeanName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDependent</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">        <span class="keyword">return</span> isDependent(beanName, dependentBeanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册依赖关系，我依赖于谁，谁又依赖于我</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">    String canonicalName = canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key是beanName,value是beanName所需要的依赖bean实例的beanName</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">        Set&lt;String&gt; dependentBeans =</span><br><span class="line">            <span class="keyword">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key是依赖，values是哪个beanName需要我这个依赖</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">        Set&lt;String&gt; dependenciesForBean =</span><br><span class="line">            <span class="keyword">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">        dependenciesForBean.add(canonicalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在递归处理完显示指定的depend-on依赖后，开始创建bean实例，但是bean有不同的scope，有不同的逻辑处理。</p>
<p>我们来看下单例模式的bean实例创建：</p>
<p>调用子类实现的createBean方法创建bean实例</p>
<p>这里又遇到了老朋友getObjectForBeanInstance，它可以根据beanName是否已&amp;开头，来决定使用哪种方法创建bean</p>
<ul>
<li>如果是FactoryBean，则调用FactoryBean的getObject方法创建实例</li>
<li>如果是普通的bean，则直接返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建出bean实例后，对bean进行类型检查后返回。</p>
<p>小结：</p>
<ol>
<li>尝试从缓存中获取bean</li>
<li>循环依赖的判断</li>
<li>递归去父容器获取bean实例</li>
<li>如果父容器中获取不到，从当前容器中获取BeanDefinition实例</li>
<li>递归实例化显示依赖的depend-on</li>
<li>根据不同的Scope采用不同的策略来创建bean实例</li>
<li>对bean进行类型检查</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>声明性事务.md</title>
    <url>/2020/09/05/Spring/%E5%A3%B0%E6%98%8E%E6%80%A7%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="声明性事务的使用步骤"><a href="#声明性事务的使用步骤" class="headerlink" title="声明性事务的使用步骤"></a>声明性事务的使用步骤</h3><p>1.声明性事务需要spring-tx的包。它依赖于AOP，还需要导入AOP相关的包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">org.springframework.spring-tx</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>2.配置事务管理器，事务管理器需要dataSource。开启事务，需要aop和tx名称空间。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.在需要事务控制的方法上添加@Transactional注解。</p>
<h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul>
<li><p>timeout：超时设置，时间单位为秒。当事务执行时间&gt;timeout，事务还未执行结束，会抛出超时异常，避免长事务的产生。<strong>需要注意的一点是，如果有多个事务，需要把timeout设置在大事务上才有作用。</strong>如下所示，timeout属性应该设置在事务A这个大事务才生效。</p>
</li>
<li><p>```java<br>@Transactional(propagation = Propagation.REQUIRED，timeout = 3)<br>public void A(){</p>
<pre><code>// B事务，REQUIRES_NEW
B();
// C事务，REQUIRES_NEW
C();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* readOnly：设置事务为只读事务，当数据库操作只有读操作时，可以设置为true，提高效率。</span><br><span class="line"></span><br><span class="line">* noRollbackFor：默认发生运行时异常和Error事务会回滚。可以通过noRollbackFor指定哪些运行时异常不回滚。参数是一个class数组。</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  @Transactional(noRollbackFor = &#123;NullPointerException.class&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>noRollbackForClassName：与noRollbackFor的区别在于通过类名指定哪些运行时异常不回滚。参数是一个string数组。</p>
</li>
<li><p>```java<br>@Transactional(noRollbackForClassName = {“NullPointerException.class”})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* rollBackFor：指定哪些checked异常可以回滚</span><br><span class="line"></span><br><span class="line">* noRollbackForClassName：通过类名指定哪些checked异常可以回滚</span><br><span class="line"></span><br><span class="line">* isolation：指定事务隔离级别</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  @Transactional(isolation = Isolation.REPEATABLE_READ)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>当涉及到多个事务时，事务传播行为就是规定事务间的多个关系的。常用的有REQUIRED（同一辆车，翻车一起翻）、REQUIRES_NEW（自己开一辆车，别人翻车，与我物无关）。</p>
<ul>
<li>REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </li>
<li>REQUIRES_NEW：如果存在一个事务，则将当前事务挂起，重新开启一个新的事务。</li>
</ul>
<p>下面举几个栗子说明：</p>
<h4 id="栗子1：同是REQUIRED"><a href="#栗子1：同是REQUIRED" class="headerlink" title="栗子1：同是REQUIRED"></a>栗子1：同是REQUIRED</h4><p>大事务addOrder包含了两个小事务，传播行为都是REQUIRED。三个事务都是在同一辆车上，如果任何一个翻车了，三个事务全部回滚。如下，大事务抛出了运行时异常，insert()和update()方法都会回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRED</span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED</span></span><br><span class="line">    orderService.update();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="栗子2：REQUIRED中包含REQUIRES-NEW，子事务不发生异常"><a href="#栗子2：REQUIRED中包含REQUIRES-NEW，子事务不发生异常" class="headerlink" title="栗子2：REQUIRED中包含REQUIRES_NEW，子事务不发生异常"></a>栗子2：REQUIRED中包含REQUIRES_NEW，子事务不发生异常</h4><p>大事务addOrder()中包含两个小事务。addOrder()和update()事务在同一辆车上，insert()自己开了一辆车。现在addOrder()发生了运行时异常，翻车了。addOrder()和update()事务在同一辆车上，都会回滚操作。但是insert()自己开的车不受影响，会插入成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRES_NEW</span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED</span></span><br><span class="line">    orderService.update();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="栗子3：REQUIRED中包含REQUIRES-NEW，子事务发生异常"><a href="#栗子3：REQUIRED中包含REQUIRES-NEW，子事务发生异常" class="headerlink" title="栗子3：REQUIRED中包含REQUIRES_NEW，子事务发生异常"></a>栗子3：REQUIRED中包含REQUIRES_NEW，子事务发生异常</h4><p>大事务addOrder()中包含两个小事务。addOrder()和update()事务在同一辆车上，insert()自己开了一辆车。现在insert()发生了运行时异常，翻车了。按理说，insert()自己翻车，并不影响addOrder()和update()这辆车，也就是update会执行成功。但结果是insert()和update()都回滚了，原因在于insert发生了异常，异常往上抛出，到了addOrder，addOrder()也发生了运行时异常，导致update()回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRES_NEW insert发生异常</span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED</span></span><br><span class="line">    orderService.update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果，子事务insert()不往上抛出异常，而是子事务内try..catch..，运行结果又是怎样的呢？</p>
<p>insert()和update()都执行成功了。因为insert()自己捕获了运行时异常，insert()的事务不回滚。同时也不会将异常向上抛出，update()也会执行成功。</p>
<h4 id="栗子4：同是REQUIRES-NEW，子事务不发生异常"><a href="#栗子4：同是REQUIRES-NEW，子事务不发生异常" class="headerlink" title="栗子4：同是REQUIRES_NEW，子事务不发生异常"></a>栗子4：同是REQUIRES_NEW，子事务不发生异常</h4><p>大事务addOrder()启动时创建一个事务，两个子事务也是自身启动一个事务，与大事务互不影响。大事务翻车，子事务不受影响，insert()和update()都执行成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRES_NEW </span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED</span></span><br><span class="line">    orderService.update();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果，insert()发生异常，异常往上抛，addOrder也发生了运行时异常。insert()会回滚，而update()都没机会执行，因为还没执行到update()，addOrder就回滚了。</p>
<h4 id="栗子5：同是REQUIRES-NEW，子事务发生异常"><a href="#栗子5：同是REQUIRES-NEW，子事务发生异常" class="headerlink" title="栗子5：同是REQUIRES_NEW，子事务发生异常"></a>栗子5：同是REQUIRES_NEW，子事务发生异常</h4><p>如果，insert()发生异常，异常往上抛，addOrder也发生了运行时异常。insert()会回滚，而update()都没机会执行，因为还没执行到update()，addOrder就回滚了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRES_NEW insert()发生异常</span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED</span></span><br><span class="line">    orderService.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果，update()发生异常，异常会往上抛。addOrder也发生了运行时异常。update()肯定会回滚，而insert()方法不会回滚，因为insert()是自己开的一辆车，它会执行成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// insert REQUIRES_NEW </span></span><br><span class="line">    productService.insert();</span><br><span class="line">    <span class="comment">// update REQUIRED update()发生异常</span></span><br><span class="line">    orderService.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果insert()是REQUIRED的传播行为，受到addOrder运行时异常的影响，insert()也会回滚？ 实际上，这里会发生死锁，insert()与addOrder是同一个事务，插入数据之后，addOrder事务还没有提交，未释放锁，此时update()去更新需要获取到锁，就发生了死锁。</p>
<p><strong>总结：不管哪一个事务发生了异常，在往上抛的时候，只要是REQUIRES_NEW的事务都会执行成功(不会回滚)</strong></p>
<h3 id="本类事务方法方法之间的调用是同一个事务"><a href="#本类事务方法方法之间的调用是同一个事务" class="headerlink" title="本类事务方法方法之间的调用是同一个事务"></a>本类事务方法方法之间的调用是同一个事务</h3><p>addOrder大事务中包含了insert()和update()两个子事务，两个子事务都是REQUIRES_NEW。按理说，addOrder事务发生运行时异常，并不会影响到insert()和update()两个子事务，insert()和update()应该执行成功。</p>
<p>但是，由于这是在本类方法中，都是使用的同一个代理对象，实际上是同一个事务…</p>
<p>只要有一个方法发生了异常，事务都会回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.insert();</span><br><span class="line">    <span class="keyword">this</span>.update();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    orderDao.insert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    productDao.update();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xml配置事务"><a href="#xml配置事务" class="headerlink" title="xml配置事务"></a>xml配置事务</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务管理器，事务相关的属性，相当于注解的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;addOrder&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点，相当于要在哪个方法上标明@Transactional--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.imooc.service.impl3.OrderServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关联事务管理器的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，使用xml配置事务管理器时，可以使用*来切入pointCut下的所有方法，而只读方法可以设置readOnly=true来提高性能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;search*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP.md</title>
    <url>/2020/09/05/Spring/AOP/</url>
    <content><![CDATA[<h3 id="通知的几种类型"><a href="#通知的几种类型" class="headerlink" title="通知的几种类型"></a>通知的几种类型</h3><ul>
<li>前置通知（Before）</li>
<li>后置通知（AfterReturning）</li>
<li>异常通知（AfterThrowing）</li>
<li>最后通知（After）：无论方法是正常结束，还是发生异常，都会执行。相当于写在finally块里的代码</li>
<li>环绕通知（Around）</li>
</ul>
<h3 id="Spring-AOP使用步骤"><a href="#Spring-AOP使用步骤" class="headerlink" title="Spring AOP使用步骤"></a>Spring AOP使用步骤</h3><ol>
<li><p>导入aop相关的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">org.springframework.spring-aop</span><br><span class="line">org.aspectj.aspectjweaver</span><br><span class="line">aopalliance.aopalliance</span><br></pre></td></tr></table></figure></li>
<li><p>开启AOP自动代理、包扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.imooc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启自动代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写切面类，使用@Aspect标注，并加入IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public Integer com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(public Integer com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行结束after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(public Integer com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;法正常返回AfterReturning...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(public Integer com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法发生异常AfterThrowing:&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public int com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        Object proceed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[环绕通知]前置...&quot;</span>);</span><br><span class="line">            <span class="comment">// 控制主方法的执行</span></span><br><span class="line">            proceed = joinPoint.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;[环绕通知]后置...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[环绕中异常通知]...&quot;</span>);</span><br><span class="line">            <span class="comment">// 环绕通知内发生的异常，如果捕获，需要再次抛出，方便下一个AfterThrowing捕获</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;环绕内发生了异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[环绕结束通知]...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="没有环绕通知的执行顺序"><a href="#没有环绕通知的执行顺序" class="headerlink" title="没有环绕通知的执行顺序"></a>没有环绕通知的执行顺序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="comment">// 方法执行</span></span><br><span class="line">    <span class="meta">@AfterReturning</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="meta">@AfterThrowing</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法正常执行：@Before -&gt;  正常方法执行 -&gt;  @After -&gt; @AfterReturning</li>
<li>方法发生异常：@Before -&gt;  正常方法执行 -&gt;  @After -&gt; @AfterThrowing(@AfterReturning执行)</li>
</ul>
<p>注意的是先执行@After通知之后，再执行@AfterReturning通知。</p>
<h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><p>环绕通知相当于拥有其他四种类型的通知,因为它可以拦截目标方法执行。</p>
<p>不调用Object obj = proceedingJoinPoint.proceed();即可拦截原有方法执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proceed = joinPoint.proceed(args);</span><br></pre></td></tr></table></figure>

<p>这一行代码相当于JDK动态代理中的method.invoke(obj,args);在执行方法过后，要把方法返回的对象return。</p>
<h3 id="环绕通知的执行顺序"><a href="#环绕通知的执行顺序" class="headerlink" title="环绕通知的执行顺序"></a>环绕通知的执行顺序</h3><p>环绕通知的执行顺序与其他通知的执行顺序有一点不同，下面代码的执行顺序是：</p>
<ul>
<li>方法正常执行：[环绕通知]前置…  -&gt;   正常方法执行 -&gt;  [环绕通知]后置…  -&gt; [环绕结束通知]…</li>
<li>方法发生异常：[环绕通知]前置…  -&gt;   正常方法执行  -&gt; 环绕内发生了异常  -&gt; [环绕结束通知]…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[环绕通知]前置...&quot;</span>);</span><br><span class="line">    <span class="comment">// 控制主方法的执行</span></span><br><span class="line">    proceed = joinPoint.proceed(args);</span><br><span class="line">    System.out.println(<span class="string">&quot;[环绕通知]后置...&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[环绕中异常通知]...&quot;</span>);</span><br><span class="line">    <span class="comment">// 环绕通知内发生的异常，如果捕获，需要再次抛出，方便下一个AfterThrowing捕获</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;环绕内发生了异常&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[环绕结束通知]...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，如果环绕通知外还有异常通知，需要将异常再次抛出，否则外边的异常通知会失效。</p>
<h3 id="有环绕通知的执行顺序"><a href="#有环绕通知的执行顺序" class="headerlink" title="有环绕通知的执行顺序"></a>有环绕通知的执行顺序</h3><p>以上面的栗子为说明，如果具有环绕通知和其他通知，执行结果如下：</p>
<p>对比没有环绕通知的执行顺序，其实就是把【正常方法执行】这一步骤换成【环绕通知方法执行】,并且环绕通知的优先级高于其他通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========方法正常结束===========</span><br><span class="line">[环绕通知]前置...</span><br><span class="line">方法执行前before...</span><br><span class="line">[环绕通知]后置...</span><br><span class="line">[环绕结束通知]...</span><br><span class="line">方法执行结束after...</span><br><span class="line">方法正常返回AfterReturning...</span><br><span class="line">=========方法发生异常===========</span><br><span class="line">[环绕通知]前置...</span><br><span class="line">方法执行前before...</span><br><span class="line">[环绕中异常通知]...</span><br><span class="line">[环绕结束通知]...</span><br><span class="line">方法执行结束after...</span><br><span class="line">方法发生异常AfterThrowing:环绕内发生了异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多个切面的通知执行顺序"><a href="#多个切面的通知执行顺序" class="headerlink" title="多个切面的通知执行顺序"></a>多个切面的通知执行顺序</h3><p>如果有多个切面切一个方法，切面类是有执行顺序的，其就像一个同心圆，由外到里，再由里到外地执行。</p>
<p>一般来说，会按照切面类类命的首字母来决定执行顺序。但是，可以通过@Order注解来指定优先级。值越小的优先级越大。如果是xml的配置方式，可以通过在xml文件中配置切面类的顺序来控制切面类的执行顺序，当然也可以通过order属性来指定。</p>
<h3 id="JoinPoint获取目标方法的信息"><a href="#JoinPoint获取目标方法的信息" class="headerlink" title="JoinPoint获取目标方法的信息"></a>JoinPoint获取目标方法的信息</h3><ul>
<li><p>除了环绕通知之外的其他通知，可以在切面方法中使用JoinPoint来获取目标方法的信息。环绕通知可以使用ProceedingJoinPoint来获取目标方法的信息。JointPoint是Spring内置的，无需在注解中指定。</p>
</li>
<li><p>```java<br>public Object around(ProceedingJoinPoint joinPoint) throws Throwable {</p>
<pre><code>Object[] args = joinPoint.getArgs();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 对于@AfterReturning，还可以在注解中使用returning指定一个变量，并将变量绑定到方法参数，即可接收目标方法返回值</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  @AfterReturning(value = &quot;execution(public int com.imooc.demo3.Calculator.*(..))&quot;,returning = &quot;result&quot;)</span><br><span class="line">  public void afterReturning(JoinPoint joinPoint,Object result)&#123;</span><br><span class="line">      // 获取方法名</span><br><span class="line">      Signature signature = joinPoint.getSignature();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于@AfterThrowing，还可以在注解中使用throwing指定一个变量，并将变量绑定到方法参数，即可接收目标方法异常信息</p>
</li>
<li><p>```java<br>@AfterThrowing(value = “execution(public int com.imooc.demo3.Calculator.*(..))”,throwing = “e”)<br>public void afterThrowing(Exception e){</p>
<pre><code>System.out.println(&quot;方法发生异常AfterThrowing:&quot;+e.getMessage());
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 直接输出JoinPoint可以获得切入点表达式的信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### PointCut抽取共同的连接点</span><br><span class="line"></span><br><span class="line">随便定义一个空方法，使用@PointCut来定义切入点表达式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Pointcut(value = &quot;execution(public int com.imooc.demo3.Calculator.*(..))&quot;)</span><br><span class="line">private void pointCut()&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用这个共用的切入点表达式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法执行前before...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;pointCut()&quot;,returning = &quot;result&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法名</span></span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;方法正常返回AfterReturning...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，如果想在其他类使用这个切入点表达式，需要写全限定类名。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.imooc.demo3.Calculator.pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法执行前before...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="xml配置AOP"><a href="#xml配置AOP" class="headerlink" title="xml配置AOP"></a>xml配置AOP</h3><ul>
<li>将被代理的对象和切面类加入到IOC容器中</li>
<li>配置AOP切面类，切入点等信息</li>
</ul>
<p><strong>需要注意的是配置通知方法时，不需要加()。比如before而不是before()</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--被代理对象加入容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;calculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.demo3.Calculator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--切面类加入容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logUtils&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.demo3.LogUtils&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置在&lt;aop:aspect&gt;标签外，可以全局使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public int com.imooc.demo3.Calculator.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定切面类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logUtils&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="踩坑1：AOP不生效？"><a href="#踩坑1：AOP不生效？" class="headerlink" title="踩坑1：AOP不生效？"></a>踩坑1：AOP不生效？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculatorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 踩坑1：必须从ioc容器中取出对象才可以</span></span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(calculator.div(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行以上单元测试代码，AOP好像不生效。原因在于第7行代码，Calculator不是从容器中获取的，自然不能使用Spring提供的AOP功能。</p>
<h3 id="踩坑2：IOC容器中保存的是代理对象"><a href="#踩坑2：IOC容器中保存的是代理对象" class="headerlink" title="踩坑2：IOC容器中保存的是代理对象"></a>踩坑2：IOC容器中保存的是代理对象</h3><p>从坑1爬出来之后，自然想到注入Calculator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculatorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(calculator.div(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时执行会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named <span class="string">&#x27;calculator&#x27;</span> is expected to be of type <span class="string">&#x27;com.imooc.demo3.Calculator&#x27;</span> but was actually of type <span class="string">&#x27;com.sun.proxy.$Proxy26&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>AOP的底层是代理，Calculator经过AOP代理之后</strong>，真正保存的是com.sun.proxy.$Proxy26代理对象。可以通过以下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(calculator);<span class="comment">// com.imooc.demo3.Calculator@69c79f09</span></span><br><span class="line">System.out.println(calculator.getClass());<span class="comment">// class com.sun.proxy.$Proxy26</span></span><br></pre></td></tr></table></figure>

<p>而代理对象和被代理对象，唯一的共同点就是实现了同一个接口Calculete。我们使用接口接收注入的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Calculate calculator;</span><br></pre></td></tr></table></figure>

<h3 id="踩坑3：基本类型引发的错误"><a href="#踩坑3：基本类型引发的错误" class="headerlink" title="踩坑3：基本类型引发的错误"></a>踩坑3：基本类型引发的错误</h3><p>在注入Calculate接口后，本以为会一帆风顺，但是结果往往很现实：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Null <span class="keyword">return</span> value from advice does not match primitive <span class="keyword">return</span> type <span class="keyword">for</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> com.imooc.demo3.Calculate.add(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>发生这个错误的原因在于，Calculate接口规定的add方法返回值是int的基本类型，而切面在执行before方法时，返回值类型是void，切面会返回null类型。这就导致了基本类型和null不可兼容的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(public Integer com.imooc.demo3.Calculator.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;方法开始&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>一种简单的解决方案是将Calculate接口的返回值类型修改为包装类，因为包装类与null是兼容的。<strong>同时要注意，修改了接口的返回值，要检查切入点表达式是否满足切入条件。</strong></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理.md</title>
    <url>/2020/09/04/Spring/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="什么是JDK动态代理"><a href="#什么是JDK动态代理" class="headerlink" title="什么是JDK动态代理"></a>什么是JDK动态代理</h3><p>JDK动态代理为实现了接口的类生成一个代理对象。</p>
<p>使用JDK提供的Proxy类可以生成代理对象，使用了Lambda表达式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculate <span class="title">getProxy</span><span class="params">(Calculator calculator)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		ClassLoader loader = calculator.getClass().getClassLoader();</span><br><span class="line">		Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (Calculate)Proxy.newProxyInstance(loader,interfaces,(proxy, method, args) -&gt; &#123;</span><br><span class="line">             <span class="comment">// 方法执行前的操作</span></span><br><span class="line">			System.out.println(method.getName() + <span class="string">&quot;开始执行，方法参数&quot;</span> + Arrays.asList(args));</span><br><span class="line">		   	<span class="comment">// 注意这里执行的是被代理对象的方法，而不是生成的代理对象的方法</span></span><br><span class="line">			<span class="comment">// calculator而不是proxy,proxy一般不做修改，如果不小心修改了，会出现递归的情况</span></span><br><span class="line">			Object result = method.invoke(calculator, args);</span><br><span class="line">             <span class="comment">// 方法执行后的操作</span></span><br><span class="line">			System.out.println(method.getName() + <span class="string">&quot;结束执行&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来了解一下几个参数的含义：</p>
<ul>
<li>loader：类加载器，可以通过Class元类获取</li>
<li>interfaces：被代理对象实现的接口，可以通过Class元类获取。正因为代理对象和被代理对象实现了同一个接口，返回的代理对象可以放心的强制类型转换。</li>
<li>invocationHandler：函数式接口，定义了invoke方法，返回生成的代理对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>proxy：生成的代理对象，供JDK使用，一般不修改它。如果不小心修改了它，会造成“递归”的现象。</li>
<li>method：被代理对象要执行的方法，通过反射调用方法。</li>
<li>args：被代理对象执行方法的参数。</li>
</ul>
<p>有了被代理对象的方法Method和方法参数args，就可以通过反射调用method.invoke执行被代理对象上的方法。<strong>注意的是，这里返回的代理对象是执行invoke方法的返回值。</strong></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>FactoryBean接口.md</title>
    <url>/2020/09/04/Spring/FactoryBean%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="FactoryBean接口简介"><a href="#FactoryBean接口简介" class="headerlink" title="FactoryBean接口简介"></a>FactoryBean接口简介</h3><p>FactoryBean接口是Spring提供的工厂类接口，实现这个接口的实现类拥有一些Spring提供的Bean基本功能。</p>
<p>泛型定义的是产生对象的类型。</p>
<p>FactoryBean接口定义了3个方法：</p>
<ul>
<li>getObjectType：返回的是被创建对象的Class</li>
<li>getObject：返回的是被创建对象的实例</li>
<li>isSingleton：被创建的对象是否单例</li>
</ul>
<p>FactoryBean是懒加载的，容器启动的时候，工厂不会生产对象，直到使用到对象的时候，才会创建对象。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@Author Ming</span></span><br><span class="line"><span class="comment"> *@Date 2020/09/04 21:41</span></span><br><span class="line"><span class="comment"> *@Description FactoryBean接口,创建的对象是Book类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class MyFactoryBean implements FactoryBean<span class="operator">&lt;</span>Book<span class="operator">&gt;</span> &#123;</span><br><span class="line">	<span class="variable">@Override</span></span><br><span class="line">	public Class<span class="operator">&lt;</span>?<span class="operator">&gt;</span> getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Book.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="variable">@Override</span></span><br><span class="line">	public Book getObject() throws Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Book();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="variable">@Override</span></span><br><span class="line">	public <span class="type">boolean</span> isSingleton() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用XML方式生产bean"><a href="#使用XML方式生产bean" class="headerlink" title="使用XML方式生产bean"></a>使用XML方式生产bean</h3><p>在xml中配置需要使用的工厂bean，就可以通过IOC容器获取到该工厂生产的对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.factory.MyFactoryBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:spring/spring-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Object bean1 = applicationContext.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);</span><br><span class="line">		Object bean2 = applicationContext.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);</span><br><span class="line">		System.out.println(bean1);<span class="comment">// com.imooc.entity.Book@1de0aca6</span></span><br><span class="line">		System.out.println(bean2);<span class="comment">// com.imooc.entity.Book@255316f2</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从运行结果看，通过myFactoryBean获取到的不是工厂的实现类，而是工厂产生的对象Book类型，而且由于isSingleton方法返回的是false，生产的对象不是单例的。</p>
<p>有什么办法可以获取到工厂的实现类本身吗？</p>
<p>在BeanFactory接口里定义了这么一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">	 * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">	 * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过&amp;id可以获取到工厂类本身，而不是工厂类产生的对象实例。且Spring中产生的bean默认是单例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bean1 = applicationContext.getBean(<span class="string">&quot;&amp;myFactoryBean&quot;</span>);</span><br><span class="line">Object bean2 = applicationContext.getBean(<span class="string">&quot;&amp;myFactoryBean&quot;</span>);</span><br><span class="line">System.out.println(bean1);<span class="comment">// com.imooc.factory.MyFactoryBean@1de0aca6</span></span><br><span class="line">System.out.println(bean2);<span class="comment">// com.imooc.factory.MyFactoryBean@1de0aca6</span></span><br></pre></td></tr></table></figure>

<h3 id="使用注解方法生产对象"><a href="#使用注解方法生产对象" class="headerlink" title="使用注解方法生产对象"></a>使用注解方法生产对象</h3><p>同XML方式一样，只需要把实现的工厂类加入到IOC容器中，就可以通过容器获取工厂生产的对象。</p>
<p>这里使用@Component加入到IOC容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Book.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Book();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，是通过注解的方式获取ApplicationContext，不再是通过xml的ClassPathXmlApplicationContext.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 扫描com.imooc包下的所有注解</span></span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">&quot;com.imooc&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Object bean1 = applicationContext.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);</span><br><span class="line">		Object bean2 = applicationContext.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);</span><br><span class="line">		System.out.println(bean1);<span class="comment">// com.imooc.entity.Book@4361bd48</span></span><br><span class="line">		System.out.println(bean2);<span class="comment">// com.imooc.entity.Book@53bd815b</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，使用注解的方式同样可以获取到工厂类产生的对象。同样的，如果需要获取到工厂的实现类，只需要通过applicationContext.getBean(“&amp;myFactoryBean”)获取。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql锁.md</title>
    <url>/2020/08/24/Mysql/Mysql%E9%94%81/</url>
    <content><![CDATA[<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加<strong>全局读锁</strong>的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。注意，在备份过程中整个库完全处于只读状态。</p>
<p>但是让整库都只读，听上去就很危险：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>
</ul>
<p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p>
<p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<p>你一定在疑惑，有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
<p>所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</p>
<p>你也许会问，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li>
<li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p>表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。因为读写互斥，t1加了read锁，其他线程的写会被阻塞，读不会被阻塞。t2加了write锁，其他线程的读写会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p>另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p>下面我们来看一个栗子：</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" alt="修改一张小表"></p>
<p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p>
<p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p>
<p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p>
<h4 id="如何安全地给小表加字段？"><a href="#如何安全地给小表加字段？" class="headerlink" title="如何安全地给小表加字段？"></a>如何安全地给小表加字段？</h4><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>
<p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></table></figure>

<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>ySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当出现死锁后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行 delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</li>
<li>第三种，在 20 个连接中同时执行 delete from T limit 500。</li>
</ul>
<p>你会选择哪一种方法呢？为什么呢？</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql锁</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式.md</title>
    <url>/2020/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>为了更好地阐述工厂模式，我们先定义好后续使用的实体类。我们定义一个Mouse接口，包含info()简介鼠标的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述鼠标信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来创建两个实现Mouse接口的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpMouse</span> <span class="keyword">implements</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是惠普鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoMouse</span> <span class="keyword">implements</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是联想鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式使用一个工厂类来管理对象的创建。工厂类提供一个静态的方法，通过方法传参的不同，返回不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/08/27 22:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 简单鼠标工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MouseFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，根据传参的不同返回不同的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mouse <span class="title">createMouse</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Hp&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HpMouse();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LenovoMouse();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建对象时，使用如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mouse hp = MouseFactory.createMouse(<span class="string">&quot;Hp&quot;</span>);</span><br><span class="line">Mouse lenovo = MouseFactory.createMouse(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">hp.info();</span><br><span class="line">lenovo.info();</span><br></pre></td></tr></table></figure>

<p>通过这种简单工厂模式，隐藏了对象的创建细节，统一在工厂类中管理对象的创建。但是它的缺点也很明显，一旦需要增加新的实现类，就需要修改MouseFactory类，这违反了开闭原则。</p>
<p>有没有什么方法可以不违反开闭原则吗？</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。同简单工厂相比，工厂方法模式需要多定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MouseFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂类定义生产对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mouse <span class="title">createMouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个对象对应于一个生产对象的工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpMouseFactory</span> <span class="keyword">implements</span> <span class="title">MouseFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoMouseFactory</span> <span class="keyword">implements</span> <span class="title">MouseFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象时，使用如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HpMouseFactory hpMouseFactory = <span class="keyword">new</span> HpMouseFactory();</span><br><span class="line">Mouse hp = hpMouseFactory.createMouse();</span><br><span class="line">hp.info();</span><br><span class="line"></span><br><span class="line">LenovoMouseFactory lenovoMouseFactory = <span class="keyword">new</span> LenovoMouseFactory();</span><br><span class="line">Mouse lenovo = lenovoMouseFactory.createMouse();</span><br><span class="line">lenovo.info();</span><br></pre></td></tr></table></figure>

<p>工厂方法模式同样也隐藏了对象的创建细节，对比于简单工厂模式，它并没有违反开闭原则，反而实现了单一责则。</p>
<p>其一缺点是只支持同一类产品的创建，因为MouseFactory规定了只创建Mouse的对象。</p>
<p>其二每增加一个实体类，都需要增加对应的工厂类，比较繁琐。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式适用于创建同一产品族的对象。也需要定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建鼠标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mouse <span class="title">createMouse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建键盘对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">KeyBoard <span class="title">createKeyBoard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyBoard <span class="title">createKeyBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpKeyBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyBoard <span class="title">createKeyBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoKeyBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象工厂模式和工厂方法很类似，区别在于抽象工厂模式是对同一产品族对象的创建，而工厂方法是对同一产品对象的创建。</p>
<p>抽象工厂模式同样违反了开闭原则，当ComputerFactory方法新增加一个方法时，其实现类都需要实现这个方法。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引.md</title>
    <url>/2020/08/23/Mysql/Mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="常见的索引结构"><a href="#常见的索引结构" class="headerlink" title="常见的索引结构"></a>常见的索引结构</h3><blockquote>
<p>哈希表</p>
</blockquote>
<p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="D:\Blog\hexo\source\images\0c62b601afda86fe5d0fe57346ace957.png" alt="img"></p>
<p>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p>
<p>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p>
<blockquote>
<p>有序数组</p>
</blockquote>
<p>而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="D:\Blog\hexo\source\images\bfc907a92f99cadf5493cf0afac9ca49.png" alt="img"></p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>
<blockquote>
<p>二叉搜索树</p>
</blockquote>
<p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<p><img src="D:\Blog\hexo\source\images\04fb9d24065635a6a637c25ba9ddde68.png" alt="img"></p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p>
<p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h3 id="Innodb的索引模型"><a href="#Innodb的索引模型" class="headerlink" title="Innodb的索引模型"></a>Innodb的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。。</p>
<p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p>
<p>这个表的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k))engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p>
<p><img src="D:\Blog\hexo\source\images\dcda101051f28502bd5c4402b292e38d.png" alt="img"></p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p>
<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h3 id="是否使用自增主键？"><a href="#是否使用自增主键？" class="headerlink" title="是否使用自增主键？"></a>是否使用自增主键？</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该？</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="索引的查询过程"><a href="#索引的查询过程" class="headerlink" title="索引的查询过程"></a>索引的查询过程</h3><p>在下面这个表 T 中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这个表的初始化语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\hexo\source\images\dcda101051f28502bd5c4402b292e38d.png" alt="img"></p>
<p>现在，我们一起来看看这条 SQL 查询语句的执行流程：</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</p>
<p>假设这个市民表的定义是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tuser` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>
<p>这里，我先和你说结论吧。B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<p><img src="D:\Blog\hexo\source\images\89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"></p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图 3 和图 4，是这两个过程的执行流程图。</p>
<p><img src="D:\Blog\hexo\source\images\b32aa8b1f75611e0759e52f5915539ac.jpg" alt="无索引下推"></p>
<p><img src="D:\Blog\hexo\source\images\76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="索引下推"></p>
<p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p>
<p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<h3 id="问题1：为什么需要重建索引？"><a href="#问题1：为什么需要重建索引？" class="headerlink" title="问题1：为什么需要重建索引？"></a>问题1：为什么需要重建索引？</h3><p>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p>
<h3 id="问题2-重建索引该怎么做？"><a href="#问题2-重建索引该怎么做？" class="headerlink" title="问题2:重建索引该怎么做？"></a>问题2:重建索引该怎么做？</h3><p>对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> index k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> index(k);</span><br></pre></td></tr></table></figure>

<p>如果你要重建主键索引，也可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure>

<p>对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p>
<ol>
<li>直接删掉主键索引是不好的，它会使得所有的二级索引都失效，并且会用ROWID来作主键索引；<ol start="2">
<li>看到mysql官方文档写了三种措施，第一个是整个数据库迁移，先dump出来再重建表（这个一般只适合离线的业务来做）；第二个是用空的alter操作，比如ALTER TABLE t1 ENGINE = InnoDB;这样子就会原地重建表结构（真的吗？）；第三个是用repaire table，不过这个是由存储引擎决定支不支持的（innodb就不行）。</li>
</ol>
</li>
</ol>
<h3 id="问题3：”N叉树”的N值可不可以调整？"><a href="#问题3：”N叉树”的N值可不可以调整？" class="headerlink" title="问题3：”N叉树”的N值可不可以调整？"></a>问题3：”N叉树”的N值可不可以调整？</h3><ol>
<li>通过改变key值来调整<br>N叉树中非叶子节点存放的是索引信息，索引包含Key和Point指针。Point指针固定为6个字节，假如Key为10个字节，那么单个索引就是16个字节。如果B+树中页大小为16K，那么一个页就可以存储1024个索引，此时N就等于1024。我们通过改变Key的大小，就可以改变N的值</li>
<li>改变页的大小<br>页越大，一页存放的索引就越多，N就越大。</li>
</ol>
<h3 id="问题4：innodb-B-树主键索引的叶子节点存的是什么"><a href="#问题4：innodb-B-树主键索引的叶子节点存的是什么" class="headerlink" title="问题4：innodb B+树主键索引的叶子节点存的是什么"></a>问题4：innodb B+树主键索引的叶子节点存的是什么</h3><p> B+树的叶子节点是page （页），一个页里面可以存多个行。</p>
<p>每次搜索到页时才会从页里面遍历行得到对应主键的行数据，内部有个有序数组，通过二分法。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务.md</title>
    <url>/2020/08/23/Mysql/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>READ UNCOMMITED:读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>READ COMMITED:读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>REPEATABLE READ:可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的(一致性读)。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>SERIALIZALBE:串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>可以使用 select @@tx_isolation;或者show variables like ‘tx_isolation’;来查看当前的事务隔离级别。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在实现上，数据库里面会创建一个一致性视图，访问的时候以视图的逻辑结果为准。</p>
<ul>
<li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图，就保证了可重复度的特性。</li>
<li>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的，因为读要求的特性是每次都读到最新已提交的值，就需要在每个SQL语句开始执行的时候创建视图。</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>
</ul>
<h4 id="此视图非彼视图"><a href="#此视图非彼视图" class="headerlink" title="此视图非彼视图"></a>此视图非彼视图</h4><p>在Mysql中，有两个“视图”的概念：</p>
<ul>
<li>一个是view，它是一个用查询语句定义的虚拟表，在调用的时候就执行查询语句并生成结果，创建视图的语法是create view ……，而它的查询方法和表一样</li>
<li>另一个是Innodb在实现MVCC时用到的一致性读视图(consistent read view)，用于支持Read Commited和Repeatbale Read隔离级别的实现。在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作（undo log）。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。它并不是物理上真实存在的，而是每次需要的时候，根据当前版本和undo log计算出来的。</li>
</ul>
<h4 id="一致性视图不是物理真实存在的，那它什么时候被删除？"><a href="#一致性视图不是物理真实存在的，那它什么时候被删除？" class="headerlink" title="一致性视图不是物理真实存在的，那它什么时候被删除？"></a>一致性视图不是物理真实存在的，那它什么时候被删除？</h4><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><ul>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</li>
<li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li>
</ul>
<h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</p>
<h3 id="一个栗子发现事务与行锁的关系"><a href="#一个栗子发现事务与行锁的关系" class="headerlink" title="一个栗子发现事务与行锁的关系"></a>一个栗子发现事务与行锁的关系</h3><p>下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/823acf76e53c0bdba7beab45e72e90d6.png" alt="事务A、B、C的执行流程"></p>
<p>这里，我们需要注意的是事务的启动时机。</p>
<h4 id="事务的启动时机"><a href="#事务的启动时机" class="headerlink" title="事务的启动时机"></a>事务的启动时机</h4><ul>
<li><p>begin/start transaction命令并不是一个事务的起点，一致性视图是在执行第一个操作Innodb表时创建的；</p>
</li>
<li><p>start transaction with consistent snapshot命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p>
</li>
</ul>
<p>在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，对于其他事务的更新，有三种情况：</p>
<ol>
<li><p>其他事务版本未提交，对当前事务不可见；</p>
</li>
<li><p>其他事务版本已提交，但是是在当前事务视图创建后提交的，不可见；</p>
</li>
<li><p>其他事务版本已提交，而且是在当前事务视图创建前提交的，可见。</p>
</li>
</ol>
<p>现在我们用这个规则来分析上图的执行结果。</p>
<p>最先提交的是事务C，事务C是自动提交的，提交过后k=2。</p>
<p>然后，事务B执行更新操作，由于事务C是在事务B之后创建的，对于 事务B不可见(第2点)，事务B读取到k=1，将其更新为k=2,又做了一次查询 k=2。</p>
<p>事务A先于事务B、事务C创建，即使事务C的事务已经提交，但对于事务A是不可见的（第2点），事务B还未提交，对于事务A不可见(第3点)。所以，事务A查询的k=1</p>
<p>上述分析过程，在实际 运行结果中，事务B的分析有误，原因是忽略了更新操作是“当前读”。</p>
<p>如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。</p>
<p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。</p>
<p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p>
<p>所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到事务B未提交的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p>再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？</p>
<p><img src="https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/20200826180008.png" alt="事务C&#39;的提交在事务B之后"></p>
<p>事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？</p>
<p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。</p>
<p>那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？</p>
<p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。</p>
<p>我们再来分析一下执行结果：</p>
<ul>
<li>事务A、事务B、事务C’按顺序启动，事务C’最先更新k=2,对这一行加了写锁，但是未提交事务，锁未释放。</li>
<li>事务B更新k的值，需要获取锁，但是事务C’还未提交，事务B获取不到锁，只能等待事务C’提交完成后，才能继续事务B的当前读，当事务C’释放锁后，事务B更新k=3</li>
<li>事务A执行的时候，事务C’已经提交，但是事务C’是在事务A之后创建的，事务A不可见，所以 事务A查询的k=1。</li>
</ul>
<p><strong>可见，在可重复读的隔离级别下，不管加锁与否，执行结果是一样的，区别只在于如果存在加锁的情况，要等其他事务释放锁才能继续往下执行。</strong></p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<p>在读提交的隔离级别下，我们分析一下执行结果：</p>
<p>start transaction with consistent snapshot;相当于start transaction。在执行到操作表的语句时，事务才真正启动。</p>
<ul>
<li>事务C’首先启动，更新k=2,对这一行加了写锁，但是未提交事务，锁未释放。</li>
<li>事务B更新k的值，需要获取锁，阻塞在当前读，等待C’释放锁后更新k，再次进行查询k=3</li>
<li>事务A执行的时候，事务C’已经提交，事务A可以获取事务C’更新的值，查询到k=2</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。</p>
<p>普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p>
<p><strong>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</strong></p>
<ul>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li>
<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>
</ul>
<p>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</p>
<h3 id="问题1：读提交不创建一致性视图行不行？"><a href="#问题1：读提交不创建一致性视图行不行？" class="headerlink" title="问题1：读提交不创建一致性视图行不行？"></a>问题1：读提交不创建一致性视图行不行？</h3><p>不行。一致性视图的作用是规定哪些数据对于当前事务是可见的，哪些数据对于当前事务是不可见的。</p>
<p>读提交的隔离级别，要求当前事务读取的是别的事务提交后的数据。但是，以下两种“当前读”的情况，即使别的事务还没提交，当前事务就可以读取到其他事务未提交的值，这是违反了读提交隔离级别的特性的。</p>
<ul>
<li>update语句是当前读的</li>
<li>select语句加锁是当前读的</li>
</ul>
<p>所以，读提交的隔离级别需要一致性视图来判断哪些数据对于当前事务是可见的。</p>
<h3 id="问题2-如何避免长事务？"><a href="#问题2-如何避免长事务？" class="headerlink" title="问题2:如何避免长事务？"></a>问题2:如何避免长事务？</h3><p>首先，从应用开发端来看：</p>
<ol>
<li><p>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</p>
</li>
<li><p>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</p>
</li>
</ol>
<p>其次，从数据库端来看：</p>
<ol>
<li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li>
<li>Percona 的 pt-kill 这个工具不错，推荐使用；</li>
<li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li>
<li>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql日志.md</title>
    <url>/2020/08/22/Mysql/Mysql%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="redo-log和bin-log"><a href="#redo-log和bin-log" class="headerlink" title="redo log和bin log"></a>redo log和bin log</h3><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
<p>这两种日志有以下三点不同。</p>
<ul>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ul>
<h3 id="update的过程"><a href="#update的过程" class="headerlink" title="update的过程"></a>update的过程</h3><p>假如有一条update语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p>
<ul>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="D:\Blog\hexo\source\images\2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update语句执行流程"></p>
<p>你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>
<p>1.先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p>
<p>2.先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>
</li>
<li><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>
</li>
<li><p>Mysql中这两个值默认都是1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql逻辑结构.md</title>
    <url>/2020/08/22/Mysql/Mysql%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="Mysql逻辑结构图"><a href="#Mysql逻辑结构图" class="headerlink" title="Mysql逻辑结构图"></a>Mysql逻辑结构图</h3><p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="Mysql逻辑结构组成"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。可以使用select @@version;查询Mysql的版本。</p>
<p>如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p><strong>连接器：</strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接，连接命令一般是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
</li>
<li><p>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。在这里，会把查询出来的权限放在一个变量中，供其他权限检验使用。比如执行器对表的权限校验</p>
</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p><img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" alt="查看空闲连接"></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。可以使用SELECT @@wait_timeout或者SHOW VARIABLES LIKE ‘%wait_timeout%’;命令查看，查询结果是28800，也就是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<h4 id="connection-timeout、wait-timeout区别"><a href="#connection-timeout、wait-timeout区别" class="headerlink" title="connection_timeout、wait_timeout区别"></a>connection_timeout、wait_timeout区别</h4><ul>
<li><p>Connect_timeout 指的是“连接过程中”的等待时间</p>
</li>
<li><p>wait_timeout指的是“连接完成后，使用过程中”的等待时间</p>
</li>
</ul>
<h4 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h4><p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p>
<p>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>
<p>2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection （Mysql为各个编程语言提供的api，不是sql）来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利</strong></p>
<p>可以使用select @@query_cache_type查询是否使用缓存。也可以使用show variables like ‘%query_cache_type%’。</p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p><strong>分析器：</strong>进行词法分析、语法分析</p>
<p>如果没有命中查询缓存，就要开始真正执行语句了。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p>
<h4 id="词法分析、语法分析的区别"><a href="#词法分析、语法分析的区别" class="headerlink" title="词法分析、语法分析的区别"></a>词法分析、语法分析的区别</h4><p>词法分析：根据mysql的关键字进行验证和解析</p>
<p>语法分析：在词法分析的基础上，进一步做表名和字段名称的验证和解析</p>
<p>分析器分析时是从information schema表里面获取表结构信息的。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误（如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。）</p>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>
<h3 id="问题1：如果表-T-中没有字段-k，而你执行了这个语句-select-from-T-where-k-1-那肯定是会报“不存在这个列”的错误：-“Unknown-column-‘k’-in-‘where-clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？"><a href="#问题1：如果表-T-中没有字段-k，而你执行了这个语句-select-from-T-where-k-1-那肯定是会报“不存在这个列”的错误：-“Unknown-column-‘k’-in-‘where-clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？" class="headerlink" title="问题1：如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？"></a>问题1：如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</h3><p>分析器，数据库连接后，会根据这条sql去查询缓存，如果缓存没有命中，就会到达分析器进行词法分析等，解析器处理语法和解析查询，生成一颗对应的解析树。预处理器进一步检查解析树的合法，比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过再提交给优化器。</p>
<h3 id="问题2：为什么对表权限的检查是在执行器，而不是在优化器？"><a href="#问题2：为什么对表权限的检查是在执行器，而不是在优化器？" class="headerlink" title="问题2：为什么对表权限的检查是在执行器，而不是在优化器？"></a>问题2：为什么对表权限的检查是在执行器，而不是在优化器？</h3><p>有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是无能为力的</p>
<h3 id="问题3：我创建了一个没有select权限的用户，执行select-from-T-where-k-1，报错“select-command-denied”，并没有报错“unknown-column”（疑问）"><a href="#问题3：我创建了一个没有select权限的用户，执行select-from-T-where-k-1，报错“select-command-denied”，并没有报错“unknown-column”（疑问）" class="headerlink" title="问题3：我创建了一个没有select权限的用户，执行select * from T where k=1，报错“select command denied”，并没有报错“unknown column”（疑问）"></a>问题3：我创建了一个没有select权限的用户，执行select * from T where k=1，报错“select command denied”，并没有报错“unknown column”（疑问）</h3><p>分析器检查SQL语法的时候，发现unknown column的错误，但是只有在执行器的时候才会对表的权限进行检查，也就是报错select command denied，那为什么分析器发现了语法错误后，还会到执行器呢？</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>逻辑结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA中JSON数据类型转换.md</title>
    <url>/2020/08/10/JPA/JPA%E4%B8%ADJSON%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>当我们在数据表中存储的是json字符串的时候，映射到实体类的时候，Java中只有String类型能和json字符串对应。</p>
<p>那么，如果我们想把json字符串反序列化成对象,有什么办法嘛？</p>
<blockquote>
<p>利用Getter、Setter方法</p>
</blockquote>
<p>在序列化、反序列化的时候，都要调用实体类的利用Getter、Setter方法，我们可以利用这个特点，在Getter方法中进行反序列化，在Setter方法中进行序列化。当然，序列化的方法可以使用Jackson或者FastJson。</p>
<p>缺点：</p>
<ul>
<li>如果某个类中有需要序列化、反序列化的属性，那就得修改这个类的Getter、Setter方法，无法做到通用。</li>
<li>有一种观点认为不应该在实体类中写业务逻辑</li>
</ul>
<blockquote>
<p>利用JPA的Converter</p>
</blockquote>
<p>我们利用JPA的converter，并在实体类中指定要使用的converter，达到序列化和反序列化的效果。</p>
<p>可以将实体的属性反序列化为Map&lt;String,Object&gt;和List<Object>这种数据结构，也可以反序列化为一个具体的实体类。我们以HashMap来举一个栗子。</p>
<ul>
<li>编写converter需要实现AttributeConverter&lt;T,K&gt;接口，T是Java实体中的属性类型，K是数据表中字段的数据类型</li>
<li>需要加上@Converter注解</li>
<li>Jackson序列化主要调用writeValueAsString方法，反序列化主要调用readValue方法</li>
<li>使用SpringBoot内置的Jackson进行序列化，可以通过依赖注入的方式注入ObjectMapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/13 19:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单体JSON对象映射工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Converter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapAndJson</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToDatabaseColumn</span><span class="params">(Map&lt;String, Object&gt; attribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(attribute))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(attribute);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">convertToEntityAttribute</span><span class="params">(String dbData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(dbData))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.EMPTY_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(dbData, HashMap.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类中使用@convert注解标明要使用的converter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Convert(converter = MapAndJson.class)</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Object&gt; specs;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>使用Map和List这种结构，无法调用业务类的方法。例如List<Spec>可以调用Spec这个类的业务方法。而使用List<Object>无法调用类的业务方法。</li>
<li>如果有多个实体类需要序列化、反序列化，需要编写多个Converter</li>
</ul>
<p>我们追求一种通用的写法，可不可以利用泛型呢？</p>
<p>上面的Converter方法中可以使用泛型来达到一种通用的效果，但是Java中泛型是有缺点的。主要体现在反序列化的第二个参数，如果直接使用T.class是不行的。所以我们需要一种机制可以将Class传入到Converter中，但是JPA的Converter无法做到这一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> objectMapper.readValue(dbData, HashMap.class);</span><br></pre></td></tr></table></figure>

<p>我们尝试自己编写一个工具类来实现序列化和反序列化的功能。这样就可以通过传参的方式传入Class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/13 21:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 序列化与反序列化工具类,支持泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndJson</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectMapper</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        GenericAndJson.objectMapper = objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o   需要转换成json字符串的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json字符串,如果是空,返回&quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">objectToJson</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> GenericAndJson.objectMapper.writeValueAsString(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s    json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type typeReference对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的目标对象,如果是空,数组返回[],对象返回&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToObject</span><span class="params">(String s, TypeReference&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> type.getType().getTypeName().contains(<span class="string">&quot;java.util.List&quot;</span>)</span><br><span class="line">                    ? (T) Collections.EMPTY_LIST : (T) Collections.EMPTY_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> GenericAndJson.objectMapper.readValue(s, type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json字符串转换成List,将List&lt;T&gt;中的T当成泛型,但这种方式还是把T转换成了LinkedHashMap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s   json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* public static &lt;T&gt; List&lt;T&gt; jsonToList(String s) &#123;</span></span><br><span class="line"><span class="comment">        if (StringUtils.isBlank(s)) &#123;</span></span><br><span class="line"><span class="comment">            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            List&lt;T&gt; list = GenericAndJson.objectMapper.readValue(s, new TypeReference&lt;List&lt;T&gt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">            return list;</span></span><br><span class="line"><span class="comment">        &#125; catch (JsonProcessingException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">            throw new ServerErrorException(99999);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里因为注入了ObjectMapper对象，所以需要加上@Component注解。同时，这里还巧妙的利用了setter方法注入static的对象。</p>
<p>同时，在实体类中需要使用Getter、Setter方法来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="keyword">private</span> String specs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数据库中获取的字符串对象反序列化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 反序列化后的对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spec&gt; <span class="title">getSpecs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(<span class="keyword">this</span>.specs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> GenericAndJson.jsonToObject(<span class="keyword">this</span>.specs, <span class="keyword">new</span> TypeReference&lt;List&lt;Spec&gt;&gt;() &#123;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 序列化对象保存到数据库</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> specs 对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> json字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">setSpecs</span><span class="params">(List&lt;Spec&gt; specs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (specs == <span class="keyword">null</span> || specs.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> GenericAndJson.objectToJson(specs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>上面的工具类是比较通用的工具类，但是还不够好。</p>
<p>缺点：</p>
<ul>
<li>需要使用TypeReference来传入参数</li>
</ul>
<p>注释掉的方法是对不需要传入TypeReference所做的尝试。</p>
<p>一种思路是把List<T>当成一个泛型T</p>
<p>一种思路是把List<T>中的T当成一个泛型T。这种方法看似可行，但是DEBUG发现，传入的实体类并没有生效，而是使用了LinkedHashMap来实现的，这就达不到可以调用实体类的业务方法的期望。</p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>序列化，工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda.md</title>
    <url>/2020/08/10/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h3><ul>
<li>Lambda表达式，代码更少</li>
<li>Stream API</li>
<li>Optional，最大化减少空指针异常</li>
<li>便于并行</li>
<li>Nashom引擎，允许在JVM上运行JS应用</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>一段可以传递行为的代码….</p>
<p>举个栗子：</p>
<p>1.不使用Lambda表达式：</p>
<p>匿名类…注意需要加上；结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; c = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = c.compare(<span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p>2.使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; c = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">    <span class="keyword">int</span> result = c.compare(<span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.使用函数引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; c =  Integer::compare;</span><br><span class="line">    <span class="keyword">int</span> result = c.compare(<span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的使用"><a href="#Lambda表达式的使用" class="headerlink" title="Lambda表达式的使用"></a>Lambda表达式的使用</h3><ul>
<li><p>本质：函数式接口的实例对象。    </p>
<pre><code>* 函数式接口：只有一个抽象方法的接口
</code></pre>
<ul>
<li>函数式接口才能使用Lambda表达式</li>
</ul>
</li>
<li><p>格式</p>
<p>-&gt;  lambda操作符</p>
<p>(o1,o2)：形参列表，其实就是接口中的抽象方法的形参列表)</p>
<p>右边：抽象方法的方法体</p>
</li>
<li><p>使用</p>
<blockquote>
<p>无参，无返回值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试Lambda&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>&gt;有且只有一个参数，无返回值
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; -&gt; (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>&gt;数据类型可以省略，由编译器推断出来
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; -&gt; (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若只有一个参数，参数的小括号可以省略</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; -&gt; s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个以上的参数，多条执行语句，有返回值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; c = (o1,o2) -&gt; &#123;</span><br><span class="line">	System.out.println(o1);</span><br><span class="line">	System.out.println(o2);</span><br><span class="line">	<span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当Lambda体只有一条执行语句，return 与 {} 都可以省略</p>
</blockquote>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(o1,o2) -&gt; o1.compareTo(o2);</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<ul>
<li>Lambda的参数类型可以省略，由编译器推断，但是不一定准确(左边）</li>
<li>形参有且仅有一个时，()可以省略(左边）</li>
<li>只有一条执行语句，return 和 {} 可以省略(右边）</li>
</ul>
<hr>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>可以在函数式接口上加上@FunctionalInterface注解，这样做可以检查它是不是函数接口</li>
<li>Lambda表达式就是一个函数式接口的实例</li>
<li>以前的匿名实现类现在都可以使用Lambda表达式来写</li>
</ul>
<hr>
<h4 id="Java-内置的四大函数式接口"><a href="#Java-内置的四大函数式接口" class="headerlink" title="Java 内置的四大函数式接口"></a>Java 内置的四大函数式接口</h4><ul>
<li>Consumer<T>：消费性接口，对参数类型为T的对象进行操作，不返回结果。包含方法void accept(T t)</li>
<li>Supplier<T>：供给型接口，返回类型为T的对象，不接收参数。包含方法T get()</li>
<li>Function&lt;T,K&gt;：函数型接口，可以接收参数，可以有返回值。对参数类型为T的对象进行操作，返回结果为K类型的对象。包含方法K apply(T t)</li>
<li>Predicate<T>：断定型接口，判断T类型的参数是否满足某约束，并返回boolean值，包含方法boolean test(T t)</li>
</ul>
<hr>
<h3 id="函数式接口举例子"><a href="#函数式接口举例子" class="headerlink" title="函数式接口举例子"></a>函数式接口举例子</h3><p>定义一个过滤字符串的方法，该方法传入字符串List和Predicate接口，利用Predicate接口的test()方法判断是否满足某种规则，满足则返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStrings</span><span class="params">(List&lt;String&gt; strs, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strs.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.test(s))&#123;</span><br><span class="line">                list.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>具体的判断规则，在调用的时候传递进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = filterStrings(strings, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
<li>要求：实现接口的抽象方法的参数列表和返回值，必须和方法引用的参数列表的和返回值类型保持一致</li>
<li>格式：使用操作符：：将类(对象) 与 方法名分隔开来</li>
<li>主要使用形式：<ul>
<li>对象：：实例方法</li>
<li>类：：静态方法</li>
<li>类：：实例方法</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>注解.md</title>
    <url>/2020/08/10/Java/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>注解：说明程序的，给计算机看的。</p>
<p>注释：用文字描述程序的，给程序员看的。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>编写文档：通过代码里标识的注解生成javadoc文档</li>
<li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li>
<li>编译检查：能够实现基本的编译检查【@Override】</li>
</ul>
<h3 id="基本的内置注解"><a href="#基本的内置注解" class="headerlink" title="基本的内置注解"></a>基本的内置注解</h3><p>@Override：检测被该注解标注的方法是否是继承父类(父接口)</p>
<p>@Deprecated：该注解标注的内容已过时，别人调用编译器会提示</p>
<p>@SupressWarnings：压制警告，一般使用参数all。@SupressWarnings(“all”)</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote>
<p>格式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> xxx&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质：本质上就是一个接口，该接口默认继承Annotation接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>属性：接口中的抽象方法</p>
</blockquote>
<ul>
<li>属性的返回值类型只能是：</li>
</ul>
<p>​        1.基本类型</p>
<p>​        2.String</p>
<p>​        3.Enum</p>
<p>​        4.注解</p>
<p>​        5.以上类型的数组</p>
<ul>
<li>定义了属性，在使用的时候要赋值</li>
</ul>
<p>​        1.如果使用default关键字给默认值，则使用注解时，可以不进行属性的赋值</p>
<p>​        2.如果只有一个属性，并且属性的名称是value，则value可以省略，直接定义即可</p>
<p>​        3.数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</p>
<blockquote>
<p>元注解</p>
</blockquote>
<p>@Target：描述注解能够作用的位置(类，方法，变量等)</p>
<p>ElementType取值：</p>
<p>​    TYPE：可以作用于类上</p>
<p>​    METHOD：可以作用于方法上</p>
<p>​    FIELD：可以作用于成员变量上</p>
<p>@Retention：描述注解被保留的阶段</p>
<p>RetentionPoliy取值：</p>
<p>​    SOURCE：不会被保留在class字节码文件中</p>
<p>​    RUNTIME：当前被描述的注解会保留到class字节码文件中，并被JVM读取到。自定义注解一般使用该值</p>
<p>​    CLASS：会保留到class字节码文件中，但是不会被JVM读到</p>
<p>@Documented：描述注解是否被抽取到javadoc文档中</p>
<p>@Inherited：描述注解是否被继承</p>
<h3 id="获取注解中定义的属性值"><a href="#获取注解中定义的属性值" class="headerlink" title="获取注解中定义的属性值"></a>获取注解中定义的属性值</h3><p>1.获取注解定义的位置的对象(Class，Method，Field)</p>
<p>2.获取该对象上指定的注解(getAnnotation(class))</p>
<p>3.获取注解中抽象方法获取配置的属性值</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>注解,JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA中JSON数据类型转换.md</title>
    <url>/2020/08/10/SpringBoot/JPA%E4%B8%ADJSON%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>当我们在数据表中存储的是json字符串的时候，映射到实体类的时候，Java中只有String类型能和json字符串对应。</p>
<p>那么，如果我们想把json字符串反序列化成对象,有什么办法嘛？</p>
<blockquote>
<p>利用Getter、Setter方法</p>
</blockquote>
<p>在序列化、反序列化的时候，都要调用实体类的利用Getter、Setter方法，我们可以利用这个特点，在Getter方法中进行反序列化，在Setter方法中进行序列化。当然，序列化的方法可以使用Jackson或者FastJson。</p>
<p>缺点：</p>
<ul>
<li>如果某个类中有需要序列化、反序列化的属性，那就得修改这个类的Getter、Setter方法，无法做到通用。</li>
<li>有一种观点认为不应该在实体类中写业务逻辑</li>
</ul>
<blockquote>
<p>利用JPA的Converter</p>
</blockquote>
<p>我们利用JPA的converter，并在实体类中指定要使用的converter，达到序列化和反序列化的效果。</p>
<p>可以将实体的属性反序列化为Map&lt;String,Object&gt;和List<Object>这种数据结构，也可以反序列化为一个具体的实体类。我们以HashMap来举一个栗子。</p>
<ul>
<li>编写converter需要实现AttributeConverter&lt;T,K&gt;接口，T是Java实体中的属性类型，K是数据表中字段的数据类型</li>
<li>需要加上@Converter注解</li>
<li>Jackson序列化主要调用writeValueAsString方法，反序列化主要调用readValue方法</li>
<li>使用SpringBoot内置的Jackson进行序列化，可以通过依赖注入的方式注入ObjectMapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/13 19:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单体JSON对象映射工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Converter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapAndJson</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToDatabaseColumn</span><span class="params">(Map&lt;String, Object&gt; attribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(attribute))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(attribute);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">convertToEntityAttribute</span><span class="params">(String dbData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(dbData))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.EMPTY_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(dbData, HashMap.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类中使用@convert注解标明要使用的converter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Convert(converter = MapAndJson.class)</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Object&gt; specs;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>使用Map和List这种结构，无法调用业务类的方法。例如List<Spec>可以调用Spec这个类的业务方法。而使用List<Object>无法调用类的业务方法。</li>
<li>如果有多个实体类需要序列化、反序列化，需要编写多个Converter</li>
</ul>
<p>我们追求一种通用的写法，可不可以利用泛型呢？</p>
<p>上面的Converter方法中可以使用泛型来达到一种通用的效果，但是Java中泛型是有缺点的。主要体现在反序列化的第二个参数，如果直接使用T.class是不行的。所以我们需要一种机制可以将Class传入到Converter中，但是JPA的Converter无法做到这一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> objectMapper.readValue(dbData, HashMap.class);</span><br></pre></td></tr></table></figure>

<p>我们尝试自己编写一个工具类来实现序列化和反序列化的功能。这样就可以通过传参的方式传入Class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/06/13 21:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 序列化与反序列化工具类,支持泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndJson</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectMapper</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        GenericAndJson.objectMapper = objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o   需要转换成json字符串的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json字符串,如果是空,返回&quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">objectToJson</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> GenericAndJson.objectMapper.writeValueAsString(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s    json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type typeReference对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的目标对象,如果是空,数组返回[],对象返回&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToObject</span><span class="params">(String s, TypeReference&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> type.getType().getTypeName().contains(<span class="string">&quot;java.util.List&quot;</span>)</span><br><span class="line">                    ? (T) Collections.EMPTY_LIST : (T) Collections.EMPTY_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> GenericAndJson.objectMapper.readValue(s, type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerErrorException(<span class="number">99999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json字符串转换成List,将List&lt;T&gt;中的T当成泛型,但这种方式还是把T转换成了LinkedHashMap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s   json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* public static &lt;T&gt; List&lt;T&gt; jsonToList(String s) &#123;</span></span><br><span class="line"><span class="comment">        if (StringUtils.isBlank(s)) &#123;</span></span><br><span class="line"><span class="comment">            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            List&lt;T&gt; list = GenericAndJson.objectMapper.readValue(s, new TypeReference&lt;List&lt;T&gt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">            return list;</span></span><br><span class="line"><span class="comment">        &#125; catch (JsonProcessingException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">            throw new ServerErrorException(99999);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里因为注入了ObjectMapper对象，所以需要加上@Component注解。同时，这里还巧妙的利用了setter方法注入static的对象。</p>
<p>同时，在实体类中需要使用Getter、Setter方法来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="keyword">private</span> String specs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数据库中获取的字符串对象反序列化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 反序列化后的对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spec&gt; <span class="title">getSpecs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(<span class="keyword">this</span>.specs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> GenericAndJson.jsonToObject(<span class="keyword">this</span>.specs, <span class="keyword">new</span> TypeReference&lt;List&lt;Spec&gt;&gt;() &#123;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 序列化对象保存到数据库</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> specs 对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> json字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">setSpecs</span><span class="params">(List&lt;Spec&gt; specs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (specs == <span class="keyword">null</span> || specs.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> GenericAndJson.objectToJson(specs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>上面的工具类是比较通用的工具类，但是还不够好。</p>
<p>缺点：</p>
<ul>
<li>需要使用TypeReference来传入参数</li>
</ul>
<p>注释掉的方法是对不需要传入TypeReference所做的尝试。</p>
<p>一种思路是把List<T>当成一个泛型T</p>
<p>一种思路是把List<T>中的T当成一个泛型T。这种方法看似可行，但是DEBUG发现，传入的实体类并没有生效，而是使用了LinkedHashMap来实现的，这就达不到可以调用实体类的业务方法的期望。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>序列化，工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot日志.md</title>
    <url>/2020/08/10/SpringBoot/SpringBoot%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="SpringBoot使用的日志框架"><a href="#SpringBoot使用的日志框架" class="headerlink" title="SpringBoot使用的日志框架"></a>SpringBoot使用的日志框架</h3><ul>
<li>SpringBoot使用的是slf4j + logback日志实现</li>
<li>导入其他的包将其他组件的日志实现转换成slf4j</li>
</ul>
<h3 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="comment">// 日志的级别由低到高</span></span><br><span class="line">logger.trace(<span class="string">&quot;trace level&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug level&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;info level&quot;</span>);</span><br><span class="line">logger.warn(<span class="string">&quot;warn level&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error level&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>SpringBoot默认的日志级别是INFO，只会输出级别大于info的日志信息。可以在配置文件中设置日志级别。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">//</span> <span class="string">调整全局的日志级别</span></span><br><span class="line"><span class="meta">logging.level.root</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">调整某个包的日志级别</span></span><br><span class="line"><span class="meta">logging.level.com.sise.jpa</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<h3 id="指定日志配置文件位置"><a href="#指定日志配置文件位置" class="headerlink" title="指定日志配置文件位置"></a>指定日志配置文件位置</h3><p>在配置文件中可以指定日志输出的位置：</p>
<table>
<thead>
<tr>
<th>logging.file.name</th>
<th>logging.file.path</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[none]</td>
<td>[none]</td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>[none]</td>
<td>输出日志到指定文件名中，不指定路径在当前项目下生成指定文件名的文件</td>
</tr>
<tr>
<td>[none]</td>
<td>指定目录</td>
<td>输出到指定目录的spring.log文件中</td>
</tr>
<tr>
<td>指定文件名</td>
<td>指定文件夹</td>
<td>输出日志到指定文件名中</td>
</tr>
</tbody></table>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">//</span> <span class="string">日志输出存放在当前项目目录下，文件名称为springboot.log</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">日志输出存放到指定目录下的指定文件名</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">C:\\Users\\zjm16\\Desktop\\springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">日志输出存放在当前项目下的指定目录下</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">spring/log/springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">日志输出存放在指定的文件夹，文件名称为默认的spring.log</span></span><br><span class="line"><span class="meta">logging.file.path</span>=<span class="string">spring/log</span></span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>logging.file.name 可以指定路径和log文件的名字</p>
<p>logging.file.path 只可以只当log的路径, 不能指定log的名字, 使用缺省值spring.log</p>
<p>二者只可以存在一个</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot日志</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置.md</title>
    <url>/2020/08/10/SpringBoot/SpringBoot%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>现有一个实体类Person,现在我们需要把实体类的属性从配置文件中导入：</p>
<p>@ConfigurationProperties是从配置文件中导入属性的关键注解。prefix指定导入的是配置文件的person开头的属性。</p>
<p>@Getter、@Setter是必须的</p>
<p>@Component也是必须的。必须是IOC容器中的类，才能从配置文件中导入属性。在使用的时候，也必须是通过@Autowaired注入的，如果通过new创建的对象，不会注入配置文件中的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean isBoy;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>yml配置文件的写法：</p>
<ul>
<li>注意每个值前面的空格。</li>
<li>属性左边只要对齐就可以，对缩进的字符个数没有限制。</li>
<li>键值对和对象的写法是一样的。因为对象也是键值对</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">is-boy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birthday:</span> <span class="number">2020</span><span class="string">/02/01</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="number">17</span>&#125;</span><br><span class="line">  <span class="attr">lists:</span> [<span class="string">aaa</span>,<span class="string">bbb</span>,<span class="string">ccc</span>]</span><br><span class="line">  <span class="attr">dog:</span> &#123;<span class="attr">name:</span> <span class="string">mydog</span>,<span class="attr">age:</span> <span class="number">6</span>&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>关于map，list，还有另外一种写法：</p>
<p>注意Person类中是驼峰命名的方式，在yml中可以是-的写法。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">is-boy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birthday:</span> <span class="number">2020</span><span class="string">/02/01</span></span><br><span class="line">  <span class="attr">maps:</span></span><br><span class="line">    <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">k2:</span> <span class="number">17</span></span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bbb</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ccc</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mydog</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>properties文件的写法：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.name</span>=<span class="string">zhangsan</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">person.is-boy</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">person.birthday</span>=<span class="string">2020/03/03</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">aaa,bbb,ccc</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">mydog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">7</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>虽然yml中是is-boy的写法，但是输出的结果还是Person类中的isBoy。同时注意到，日期格式与配置文件中的不同。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">&quot;isBoy&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-31T16:00:00.000+0000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;maps&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;k1&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;k2&quot;</span>: <span class="number">17</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lists&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ccc&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;dog&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mydog&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关于配置文件优先级问题"><a href="#关于配置文件优先级问题" class="headerlink" title="关于配置文件优先级问题"></a>关于配置文件优先级问题</h3><p>当同时存在yml文件和properties文件时，properties文件的优先级大于yml文件。</p>
<hr>
<h3 id="关于中文乱码问题"><a href="#关于中文乱码问题" class="headerlink" title="关于中文乱码问题"></a>关于中文乱码问题</h3><p>配置文件的默认编码是ASCII，而在idea中，设置了文件的编码是UTF8，就会导致乱码。</p>
<p>需要在Setting -&gt; File Encodings中设置在运行时将UTF8编码转换成ASCII编码：</p>
<p><img src="D:\ming\images\image-20200620205229515.png" alt="image-20200620205229515"></p>
<hr>
<h3 id="使用-Value注入配置文件中的值"><a href="#使用-Value注入配置文件中的值" class="headerlink" title="使用@Value注入配置文件中的值"></a>使用@Value注入配置文件中的值</h3><ul>
<li>@Value注解不可以注入复杂类型(map,list,对象等)的数据。</li>
<li>@Value可以使用spel表达式进行计算。比如#{11 * 2}</li>
<li>@Value不支持数据验证</li>
<li>@Value不支持<strong>松散语法</strong>，比如配置文件的is-boy，使用@Value注解不能写成isBoy。但是配置文件中的isBoy，使用@Value却可以写成is-boy。  黑人问号？？？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;11 * 2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.is-boy&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isBoy;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.birthday&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>只有使用@ConfigurationProperties才能使用数据验证。@Value的数据校验是无效的。</p>
<p>数据验证需要@Validated注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Max(value = 3)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean isBoy;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Value注解时，使用数据验证。controller访问会出现奇怪的结果。  而通过单元测试可以发现通过@Value的注入方式，数据校验是无效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="string">&quot;isBoy&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-31T16:00:00.000+0000&quot;</span>,</span><br><span class="line">  <span class="string">&quot;maps&quot;</span>: <span class="keyword">null</span>,</span><br><span class="line">  <span class="string">&quot;lists&quot;</span>: <span class="keyword">null</span>,</span><br><span class="line">  <span class="string">&quot;dog&quot;</span>: <span class="keyword">null</span>,</span><br><span class="line">  <span class="string">&quot;frozen&quot;</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">&quot;proxiedInterfaces&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;proxyTargetClass&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">  <span class="string">&quot;exposeProxy&quot;</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">&quot;advisors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;order&quot;</span>: <span class="number">2147483647</span>,</span><br><span class="line">      <span class="string">&quot;advice&quot;</span>: &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;pointcut&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;classFilter&quot;</span>: &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;methodMatcher&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;runtime&quot;</span>: <span class="keyword">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;perInstance&quot;</span>: <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;targetSource&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="string">&quot;isBoy&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">      <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-31T16:00:00.000+0000&quot;</span>,</span><br><span class="line">      <span class="string">&quot;maps&quot;</span>: <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">&quot;lists&quot;</span>: <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">&quot;dog&quot;</span>: <span class="keyword">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;static&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">&quot;targetClass&quot;</span>: <span class="string">&quot;com.sise.jpa.model.Person&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;targetClass&quot;</span>: <span class="string">&quot;com.sise.jpa.model.Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;preFiltered&quot;</span>: <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ConfigurationProperties与-Value注解的区别"><a href="#ConfigurationProperties与-Value注解的区别" class="headerlink" title="@ConfigurationProperties与@Value注解的区别"></a>@ConfigurationProperties与@Value注解的区别</h3><table>
<thead>
<tr>
<th></th>
<th>@Configuration</th>
<th>@Valye</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定注入</td>
</tr>
<tr>
<td>松散语法</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型注入</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>不管是yml配置文件还是properties配置文件，都能获取到配置文件中的值。</p>
<ul>
<li>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。</li>
<li>如果说，我们专门编写了一个Bean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。</li>
</ul>
<hr>
<h3 id="PropertyScore与-ImportSource"><a href="#PropertyScore与-ImportSource" class="headerlink" title="@PropertyScore与@ImportSource"></a>@PropertyScore与@ImportSource</h3><p>@PropertyScore用来加载指定的配置文件。</p>
<ul>
<li>只支持.properties文件，不支持.yml文件</li>
<li>如果application.yml或者application.properties中存在与自定义配置文件相冲突的属性，yml或properties的文件优先级高于自定义的配置文件，导致@PropertyScore失效。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean isBoy;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ImportSource用来导入Spring的配置文件，使配置文件中的内容生效。该注解标注在一个配置类上。</p>
<p>先自己创建一个spring的配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sise.jpa.helloService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在SpringBoot的入口类中使用@ImportSource注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ImportResource(locations = &#123;&quot;classpath:spring.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="配置文件属性占位符"><a href="#配置文件属性占位符" class="headerlink" title="配置文件属性占位符"></a>配置文件属性占位符</h3><ul>
<li>使用随机数</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">$&#123;random.value&#125;,$&#123;random.int(10)&#125;,$&#123;random.uuid&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>占位符获取之前配置的值，如果没有值可以用：指定默认值</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.name:Tom&#125;_dog</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><blockquote>
<p>多Profile文件</p>
</blockquote>
<p>默认配置文件使用application.properties</p>
<p>我们可以为开发环境和生产环境指定配置文件，文件名可以指定为application-{profile}.properties/yml</p>
<blockquote>
<p>yml多文档块</p>
</blockquote>
<p>每个—分隔的是一个文档块，相当于重新创建一个配置文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>激活指定的配置文件</p>
</blockquote>
<ul>
<li><p>在主配置文件中指定：值为profile</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profile.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用yml多文档块</p>
</li>
<li><p>使用命令行</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-jar xxx.jar --spring.profiles.active=dev</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用虚拟机参数</p>
<p>虚拟机参数都使用-D开头。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Dspring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h3><p>SpringBoot启动会扫描以下位置的properties/yml文件：</p>
<ul>
<li>项目路径下/config/</li>
<li>项目路径下/</li>
<li>classpath/config/</li>
<li>classpath/</li>
</ul>
<p>以上是按照优先级从高到低的顺序，所有位置的配置文件<strong>都会被加载</strong>，高优先级的配置文件内容会覆盖低优先级的配置内容，形成<strong>互补配置</strong>。</p>
<p>我们也可以通过在启动springBoot项目的时候指定spring.config.location来覆盖默认的配置。</p>
<p>通过指定spring.config.additional-locational来增强默认的配置，与默认配置形成互补。</p>
<p><strong>如果指定了外部的配置文件，则外部配置文件加载顺序优先级比上面四种情况高。</strong></p>
<p><strong>如果在application.properties/yml文件中指定了spring.config.location是无效的。</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-jar jpa-0.0.1-SNAPSHOT.jar --spring.config.additional-location=C:\User</span></span><br><span class="line"><span class="attr">s\zjm16\Desktop\application.yml</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><ol>
<li>SpringBoot启动的时候加载主配置类，主配置类开启了自动配置功能@EnableAutoConfiguration</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>@EnableAutoConfiguration作用：</li>
</ol>
<ul>
<li><p>自动扫描与启动类同级的包以及子包</p>
</li>
<li><p>利用AutoConfigurationImportSelector导入一些第三方组件的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>selectImport中去加载类路径下的资源：(autoconfiguration包i下WEB-INF/spring.factories文件)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader)</span><br><span class="line"><span class="comment">// 加载的资源的路径</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">&quot;META-INF/spring-autoconfigure-metadata.properties&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>spring-autoconfigure-metadata.properties文件中有很多xxxAutoConfiguration的配置类。这些配置类根据条件将需要的组件加入到IOC容器中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration</span>=<span class="string"></span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</span>=<span class="string"></span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span>=<span class="string"></span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>我们以HttpEncodingAutoConfiguration为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">// 声明这是一个配置类，与@Bean注解一起使用可以向IOC容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HttpProperties.class)</span>  <span class="comment">// 开启配置文件与实体类的映射</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span> <span class="comment">// 条件注解，判断当前是不是web应用，是web应用才将bean添加到IOC容器中。可以看出虽然SpringBoot加载了很多配置类，但只有满足条件的配置类才会被加入到IOC容器当中</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(CharacterEncodingFilter.class)</span> <span class="comment">// 判断当前CharacterEncodingFilter是否已经存在</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span> <span class="comment">// 判断配置文件中是否配置了spring.http.encoding.enabled属性，如果没有配置，设置默认值为true</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以看到bean中属性来自HttpProperties类，而HttpProperties类的属性与配置文件中的配置形成映射</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());			   		  filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpProperties：</p>
<p>使用@ConfigurationProperties与配置文件的属性进行关联。配置文件中可配置的属性在HttpProperties类的成员属性能反映出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> logRequestDetails;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding encoding = <span class="keyword">new</span> Encoding();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精髓：</p>
<p>1）SpringBoot启动会加载大量的自动配置类</p>
<p>2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</p>
<p>3）我们再来看这个自动配置类中到底配置了哪些组件（只要有我们需要的组件，我们就不再需要配置了）</p>
<p>4）给容器中自动配置类添加组件的时候，会从ppoperties类中获取某些属性，我们就可以再这些配置文件中指定这些属性的值。</p>
<p>5）xxxxAutoConfiguration自动配置类给容器中添加组件。xxxProperties封装配置文件中相关的属性。</p>
<hr>
<h3 id="如何查看哪些配置类生效，哪些不生效"><a href="#如何查看哪些配置类生效，哪些不生效" class="headerlink" title="如何查看哪些配置类生效，哪些不生效"></a>如何查看哪些配置类生效，哪些不生效</h3><p>在配置文件中加入debug=true。这样在启动springBoot项目时，控制台会输出配置类的信息。</p>
<hr>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot热部署.md</title>
    <url>/2020/08/10/SpringBoot/springBoot%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>导入devtools jar</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的是，一定要确保devtools导入成功。有时候在pom.xml文件中是没有报错的，但是在右侧的maven工具栏看是有红色下划线的，最好检查一下jar包是不是正确的导入了。</p>
<p>还有一点是一定要设置optional才生效</p>
<p>devtools监听的实际上是target目录下的class文件，只有class文件发生了改变，devtools才会重启服务器。那么，我们可以通过2种方法来更新target目录下的class文件。</p>
<ul>
<li>手动build project</li>
<li>通过idea设置自动更新</li>
</ul>
<blockquote>
<p> idea设置自动热部署</p>
</blockquote>
<p><img src="D:\ming\images\clipboard.png" alt="img"></p>
<p>这样，当改动java文件时，idea会自动更新target目录下的class文件，从而触发devtools重启服务器，完成了热部署。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot热部署</tag>
      </tags>
  </entry>
  <entry>
    <title>ResponseBody.md</title>
    <url>/2020/08/10/SpringBoot/response%E4%B8%8EResponseBody%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>假如说后端想返回一个string类型字符串”你好,SpringBoot”给前端。那么，有以下两种方案:</p>
<blockquote>
<p>通过HttpServletResponse对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;你好 ,SpringBoot！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们通过postman来看一下前端接收到的结果和Header中的值。</p>
<img src="D:\ming\images\clipboard-1590410602713.png" alt="img" style="zoom:67%;" />

<img src="D:\ming\images\clipboard-1590410602714.png" alt="img" style="zoom: 67%;" />

<p>当我们用HttpServletResponse返回数据的时候，应该手动设置content-type，编码等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/plains&quot;</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;你好 ,SpringBoot！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>当然也可以通过一行代码完成设置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/plains;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样设置后，返回的结果编码和content-type都正常了。</p>
<img src="D:\ming\images\clipboard-1590410602715.png" alt="img" style="zoom:67%;" />

<p>通过@ResponseBody注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好，SpringBoot&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果来看，@responseBody会自动帮我们设置content-type和编码：</p>
<img src="D:\ming\images\clipboard-1590410602716.png" alt="img" style="zoom:67%;" />

<p>以上返回的是字符串，那如果返回的是一个Object呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;王小喵&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下返回结果会是什么? 可以看到，@ResponseBody注解自动添加了content-type，还将对象自动转换成了json格式</p>
<img src="D:\ming\images\clipboard-1590410602716.png" alt="img" style="zoom:67%;" />

<img src="D:\ming\images\clipboard-1590410602716.png" alt="img" style="zoom:67%;" />

<blockquote>
<p>总结：</p>
</blockquote>
<p>使用@ResponseBody来代替HttpServletResponse。HttpServletResponse需要自己设置编码等很多属性，而@ResponseBody会自动帮我们回写content-type、编码等值</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>修改路由前缀.md</title>
    <url>/2020/08/10/SpringBoot/%E4%BF%AE%E6%94%B9%E8%B7%AF%E7%94%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>假如我们想利用包名来生成我们url的前缀，比如包名为com.sise.ming.api.v1.BannerController。我们希望指定一个api-package=com.sise.ming.api后，springBoot自动将我们的路由映射为/v1/。</p>
<p>实现这个功能需要修改SpringBoot的源码。需要继承RequestMappingHandlerMapping，且实现getMappingForMethod方法，将其返回的RequestMappingInfo修改为我们自己的RequestMappingInfo。</p>
<p>apiPackage是在配置文件中通过@Value注入的，且这个配置文件应该是SpringBoot默认的application.properties或者application.yml文件，因为我们没有使用@PropertySource来指定配置文件。</p>
<p>此外还需注意的是，@Value注入属性，需要getter，setter方法，这里使用Lombok。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoPrefixUrlMapping</span> <span class="keyword">extends</span> <span class="title">RequestMappingHandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;api-package&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String apiPackage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">        RequestMappingInfo requestMappingInfo = <span class="keyword">super</span>.getMappingForMethod(method, handlerType);</span><br><span class="line">        <span class="keyword">if</span> (requestMappingInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String prefix = <span class="keyword">this</span>.getPrefixUrl(handlerType);</span><br><span class="line">            <span class="keyword">return</span> RequestMappingInfo.paths(prefix).build().combine(requestMappingInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> requestMappingInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get requestMapping package name and replace prefix</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handlerType the handlerType of requestMapping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> thr prefix of package name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getPrefixUrl</span><span class="params">(Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">        String packageName = handlerType.getPackage().getName();</span><br><span class="line">        <span class="comment">// replace package prefix to empty string</span></span><br><span class="line">        String dotPath = packageName.replaceAll(<span class="keyword">this</span>.apiPackage, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dotPath = dotPath.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dotPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么SpringBoot怎么知道我们生成这个类呢？我们需要将它加入到IOC容器中。这里采用的是配置类，定义一个配置类实现WebMvcRegistrations接口，并将配置类加入到IOC容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoPrefixUrlConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcRegistrations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">getRequestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoPrefixUrlMapping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">api-package</span> = <span class="string">com.sise.ming.api</span></span><br></pre></td></tr></table></figure>

<p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/banner&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerController</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>修改路由前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>加载第三方组件.md</title>
    <url>/2020/08/10/SpringBoot/%E5%8A%A0%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>我们平常开发写的@Compone将类加入到IOC容器中，主要针对的是业务类。如果想把第三方的jar包中的类加入到IOC容器中，应该怎么操作呢？</p>
<p>在@SpringBootApplication注解中有一个@EnableAutoConfiguration。这是导入第三方jar包的关键</p>
<p><img src="D:\ming\images\image-20200530234855275.png" alt="image-20200530234855275"></p>
<p>在@EnableAutoConfiguration中，@import了一个select类。</p>
<p><img src="D:\ming\images\image-20200530235049756.png" alt="image-20200530235049756"></p>
<p>在这个select类中加载了一个.factories的文件。这个文件配置了所有要导入IOC容器的类。如果第三方想把类加入到IOC容器中，那么jar包提供者应该提供一个.factories的文件，里面包含了所有要导入IOC容器的类。</p>
<p><img src="D:\ming\images\image-20200530235449350.png" alt="image-20200530235449350"></p>
<hr>
<p>如何自定义一个启动类来验证AutoConfiguration的机制？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ComponentScan</span></span><br><span class="line"><span class="meta">@Import(Config.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOLApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> SpringApplicationBuilder(LOLApplication.class)</span><br><span class="line">                        .web(WebApplicationType.NONE)</span><br><span class="line">                        .run(args);</span><br><span class="line">        Connect connect = (Connect) context.getBean(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        connect.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的启动类如果加上@ComponentScan，会扫描与启动类同级目录和子目录下的bean，将其加入到IOC容器中。刚好这里Config配置类在扫描路径中，所以加上@ComponentScan可以启动服务器。</p>
<p>如果使用@Import来导入配置类，则会缺少很多@SpringBootApplication默认的配置。启动服务器会报错。第7行代码就是解决单独导入配置类引起的错误。</p>
<p>源码中@Import的是一个Select的类，我们也来实现一下。实现创建一个类实现ImportSelector接口。</p>
<p>方法的返回值是一个字符串数组，数组的元素就是需要导入的配置类的类名。这里可以使用class.getName()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOLSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;Config.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着启动类可以import我们编写好的Selector。但是源码中使用的是@EnabledAutoConfiguration，我们也来还原一下。</p>
<p>首先编写一个注解，导入Selector配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(LOLSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabledAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在启动类就可以直接使用@EnabledAutoConfiguration了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnabledAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOLApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> SpringApplicationBuilder(LOLApplication.class)</span><br><span class="line">                        .web(WebApplicationType.NONE)</span><br><span class="line">                        .run(args);</span><br><span class="line">        Connect connect = (Connect) context.getBean(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        connect.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>加载第三方组件</tag>
      </tags>
  </entry>
  <entry>
    <title>自动配置.md</title>
    <url>/2020/08/10/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>我们运行启动类就可以运行项目，那么SpringBoot是怎么自动配置的呢？</p>
<p>我们从SpringBoot的入口类开始分析。入口类有@SpringBootApplication注解。点击进去：</p>
<p>@SpringBootConfiguration实际上也是一个@Configuration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot自动配置的核心注解是@EnableAutoConfiguration，它主要是用来加载第三方库的类，点击进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br></pre></td></tr></table></figure>

<p>@AutoConfigurationPackage：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的注解导入了一个类，这个类调用了getPackageName()方法。通过debug调试可以知道，这个packageName是SprinGBoot启动类同级目录的包名。换句话说，SpringBoot会自动扫描与启动类同级包以及子包的所有类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看@EnableAutoConfiguration还导入了另外一个类：@Import(AutoConfigurationImportSelector.class)</p>
<p>selectImports方法返回一个String数组，该数组包含了配置类的全限定名。通过获取配置类的全限定名，来将类导入IOC容器，从而实现自动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">   &#125;</span><br><span class="line">   AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">         .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">   AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">         annotationMetadata);</span><br><span class="line">   <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这些配置类的全限定名是从哪里来的呢？可以看到加载了一个配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationMetadataLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">&quot;META-INF/spring-autoconfigure-metadata.properties&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件的内容：可以看到配置文件中是各种jar包的配置类</p>
<p><img src="D:\ming\images\image-20200620201852666.png" alt="image-20200620201852666"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义异常体系.md</title>
    <url>/2020/08/10/SpringBoot/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>自定义异常体系在我们的日常开发中非常重要。一方面为了让用户体验更好，应该在发生异常的时候，在前端页面显示出错误信息。而另一方面，应该隐藏后端的异常，因为后端出现的异常对于前端开发者和用户来说毫无意义。所以，我们需要定义一种统一返回给前端的异常格式。</p>
<p>我们先明确两个概念：<strong>未知异常</strong>，<strong>已知异常</strong></p>
<p>在开发过程中，我们有时会手动抛出一个异常，举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (id == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="number">10001</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>像这种参数为空抛出异常，这是我们程序员可以预知的异常，就称为已知异常。但是我们程序员不可能捕获所有的异常，而那些未捕获而在运行期间抛出的异常，我们就称为未知异常。</p>
<hr>
<p>我们可以使用SpringBoot的全局异常处理。无论在程序中抛出什么异常，最终都会经过全局异常处理后才返回给前端。这样，我们就可以在全局异常处理中统一返回给前端的异常格式。</p>
<p>首先，我们先来定义统一返回信息类。这里的getter和setter方法非常重要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifyResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnifyResponse</span><span class="params">(Integer code, String message, String request,String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.method = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局异常处理需要@ControllerAdvice和@ExceptionHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExceptionCodeConfiguration exceptionCodeConfiguration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler unknown exception</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request of http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e       the exception that method throw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the unify response message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UnifyResponse <span class="title">handlerException</span><span class="params">(HttpServletRequest request, Exception e)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; requestInfo = <span class="keyword">this</span>.getRequestUrlAndMethod(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnifyResponse(<span class="number">9999</span>, <span class="string">&quot;服务器内部错误&quot;</span>, requestInfo.get(<span class="string">&quot;url&quot;</span>), requestInfo.get(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler already known exception</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request of http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e       the exception that method throw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the unify response message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;UnifyResponse&gt; <span class="title">handlerHttpException</span><span class="params">(HttpServletRequest request, HttpException e)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; requestInfo = <span class="keyword">this</span>.getRequestUrlAndMethod(request);</span><br><span class="line">        <span class="comment">// header</span></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        <span class="comment">// http status</span></span><br><span class="line">        HttpStatus httpStatus = HttpStatus.resolve(e.getHttpStatusCode());</span><br><span class="line">        <span class="comment">// message</span></span><br><span class="line">        Integer code = e.getCode();</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        String message = exceptionCodeConfiguration.getMessage(code);</span><br><span class="line">        UnifyResponse unifyResponse = <span class="keyword">new</span> UnifyResponse(code, message, requestInfo.get(<span class="string">&quot;url&quot;</span>), requestInfo.get(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(unifyResponse, headers, httpStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get http request information</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request of http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map of request information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getRequestUrlAndMethod</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;url&quot;</span>, request.getRequestURI());</span><br><span class="line">        map.put(<span class="string">&quot;method&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍一下这里的两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UnifyResponse <span class="title">handlerException</span><span class="params">(HttpServletRequest request, Exception e)</span></span></span><br></pre></td></tr></table></figure>

<p>这是处理”未知异常”的处理方法。方法的参数是Exception。因为未知异常我们是无法预知错误码的，这里我们定义为9999。同样，返回给前端的消息固定为”服务器内部错误“。因为返回的是一个对象，需要@ResponseBody注解。@HttpStatus返回HTTP的状态码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(HttpException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;UnifyResponse&gt; <span class="title">handlerHttpException</span><span class="params">(HttpServletRequest request, HttpException e)</span> </span></span><br></pre></td></tr></table></figure>

<p>这是处理”已知异常“的处理方法。方法的参数是我们自定义的HttpException。由于message和httpStatus是动态决定的，所以返回的ResponseEntity，且不需要使用@ResponseBody。message和httpStatus的信息，我们要从自定义异常中获取。而没有使用@ResponseBody，我们需要在header中手动设置content-Type的值。</p>
<p>接下来介绍下自定义异常类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Integer code;</span><br><span class="line">    <span class="keyword">protected</span> Integer httpStatusCode = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getHttpStatusCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpStatusCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundException</span> <span class="keyword">extends</span> <span class="title">HttpException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.httpStatusCode = <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义配置异常类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(value = &quot;ming&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value=&quot;classpath:config/exception-code.properties&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionCodeConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,String&gt; codes = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codes.get(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title">getCodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCodes</span><span class="params">(Map&lt;Integer, String&gt; codes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.codes = codes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>@PropertySource关联了配置文件，而@ConfigurationProperties设置了配置文件中key的前缀，而成员变量codes对应者配置文件中的key值。</p>
<p>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">ming.codes[10000]</span> = <span class="string">通用错误</span></span><br><span class="line"><span class="meta">ming.codes[10001]</span> = <span class="string">通用参数错误</span></span><br></pre></td></tr></table></figure>

<p>这里的前缀是不能少的，不然注入会失败。而且这里的字符串不需要加”“，否则返回前端的信息中也会带有引号。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>应对变化的两种方案.md</title>
    <url>/2020/08/10/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%BA%94%E5%AF%B9%E5%8F%98%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>变化是使得代码不稳定的本质问题。为了应对变化，通常有两种解决方案：</p>
<p>1.策略模式</p>
<p>2.属性配置、配置文件</p>
<p>所谓的策略模式就是实现一个接口，有多个实现类。根据不同的情况来切换不同的实现类。</p>
<p>所谓的配置文件，就是将代码中经常变化的部分抽出来放在配置文件，通过修改配置文件来应对变化。</p>
<hr>
<p>策略模式应对变化的几种方案：</p>
<p>1.通过byname注入，通过切换bean name</p>
<p>2.@Qualiier 指定bean</p>
<p>3.有选择地只注入一个bean，注释掉某个bean上的@Compoent注解</p>
<p>4.使用@Primary注解</p>
<p>5.@Conditional注解</p>
]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title>面向抽象编程.md</title>
    <url>/2020/08/10/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在编程过程中啊，很多时候我们是用面向对象的思想编程。这是我们在编程过程中很自然就会去应用的思想。比如我们来模拟一下英雄联盟这个游戏的应用场景。</p>
<p>现在呢，我们有一个需求：当用户输入一个英雄的名称后，释放英雄的一个技能。</p>
<p>面对这个需求，首先我们很容易想到把英雄这个类抽象出来，创建一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Q</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;Diana Q&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">W</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Diana W&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Diana E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">R</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Diana R&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好了对象，我们就应该去使用它。大多数情况下，我们是去调用它的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = Main.acceptPleyerInput();</span><br><span class="line">       String name = Main.acceptPleyerInput();</span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Diana&quot;</span>:</span><br><span class="line">                Diana diana = <span class="keyword">new</span> Diana();</span><br><span class="line">                diana.R();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Yasoo&quot;</span>:</span><br><span class="line">                Yasoo yasoo = <span class="keyword">new</span> Yasoo();</span><br><span class="line">                yasoo.R();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Ez&quot;</span>:</span><br><span class="line">                Ez ez = <span class="keyword">new</span> Ez();</span><br><span class="line">                ez.R();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">acceptPleyerInput</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;please enter a hero name&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">return</span> scanner.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的第6行，当我们需要使用到Diana这个对象的时候，我们就会去创建它。但是仔细一想，这样直接new对象真的好么？实现需求肯定是能实现的，但这不是我们追求的目标，我们的目标是不仅实现需求，还追求代码的可维护性。试想，如果有一天Diana这个字符串对应的不再是Diana这个对象了，那么我们是不是需要去修改第6行的代码，去创建别的对象？在代码量少，业务简单的情况下，你可能觉得还好，改了就改了呗。但是一旦这个类被多个类所调用呢？是不是就得在每一个使用了Diana对象的类中进行修改？这样是不是很难维护呢？</p>
<p>所以，我们提出一个概念：<strong>不要面向具体的对象编程，要面向抽象编程</strong>。那么问题来了，有什么办法可以让我们更好的去面向抽象编程呢？</p>
<ol>
<li>interface、abstract</li>
<li>工厂模式</li>
<li>IOC / DI</li>
</ol>
<p>我们先来看第一种：使用interface</p>
<p>先定义一个Hexo接口，所有的英雄类实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Q</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">W</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用了接口之后，我们还是需要new出每个对象，而且也没有优化掉switch..case..，那么，我们为什么还要抽象出接口呢？这里给出结论：<strong>单纯地使用interface能统一方法的调用，但无法统一对象的实例化</strong>。相比较第一版的代码，原本在switch..case..中的方法调用优化了，但是switch..case..没有优化掉。仔细分析，这里的switch..case..正是执行了对象的实例化，正好印证了结论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String name = Main.acceptPleyerInput();</span><br><span class="line">       Hero hero = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Diana&quot;</span>:</span><br><span class="line">               hero = <span class="keyword">new</span> Diana();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Yasoo&quot;</span>:</span><br><span class="line">               hero = <span class="keyword">new</span> Yasoo();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Ez&quot;</span>:</span><br><span class="line">               hero = <span class="keyword">new</span> Ez();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">       &#125;</span><br><span class="line">       hero.R();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>那么，只是简化了方法的调用，意义大吗？</p>
<p>当然了，如果有很多个英雄呢？那岂不是要调用很多次R()吗？所以，统一方法的调用还是很有意义的。</p>
<p>从上面的分析，interface可以解决的是方法统一调用的问题，其实，抽象的难点在于new对象的优化。只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP(开闭原则)。而对象的实例化是不可能消除的，只能将它实例化的过程转移到其他的代码片段中。接下来，我们就利用简单工厂模式来转移对象的实例化代码。</p>
<p>首先，我们创建一个工厂，该工厂用来产生Hero的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hero <span class="title">getHero</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Hero hero;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Diana&quot;</span>:</span><br><span class="line">                hero = <span class="keyword">new</span> Diana();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Yasoo&quot;</span>:</span><br><span class="line">                hero = <span class="keyword">new</span> Yasoo();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Ez&quot;</span>:</span><br><span class="line">                hero = <span class="keyword">new</span> Ez();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了工厂之后，我们不再需要在main方法中使用switch..case..了。这段代码利用interface+工厂模式，已经将对象的实例化分离到工厂中，对main方法来说，它就是稳定的一段代码了吗？不一定，稳定是相对的。这段代码虽然分离了对象的实例化代码，但是它是巧妙地利用了BeanFactory的静态方法。假如BeanFactory不是静态的了，那么调用getHero()就需要变化。从另外一个角度来说，我们实现了与具体对象(通过new出来的对象)的低耦合，但是我们耦合了工厂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String name = Main.acceptPleyerInput();</span><br><span class="line">       Hero hero = BeanFactory.getHero(name);</span><br><span class="line">       hero.R();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在使用了interface+简单工厂模式后，main方法已经是相对稳定的了。但是代码中总是会存在不稳定，我们要做的是隔离这些不稳定的代码，使其他代码相对稳定。假如这个BeanFactory能生产出任何的对象，那我们岂不是就不用修改main方法里的BeanFactory了吗，因为无论什么样的对象，工厂都能生产出来。其实，这就类似于Spring中ApplicationContext。</p>
<p>在这里停下来想一想，到底是什么导致了代码的不稳定呢？主要是两个方面：</p>
<p>1.用户的输入信息变化了，这和本例是一致</p>
<p>2.用户的需求变化了</p>
<p>假如说用户输入的不再是英雄的名字(字符串)，而是能直接输入一个对象的话，那我们就消除了new对象，从而消除了switch..case…其实这在java中是可以利用反射实现的，只不过要求用户输入的必须是带上包名的完整的类的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hero <span class="title">getHero</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 完整的类名称</span></span><br><span class="line">        name = <span class="string">&quot;v1.&quot;</span> + name;</span><br><span class="line">        <span class="comment">// 通过反射创建对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(name);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        <span class="keyword">return</span> (Hero) obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用了反射消除了switch..case这种根据用户输入字符串new对象的方式。但是要注意的是，我们需要对用户输入的字符串进行处理，处理成完整的类的名称。当用户输入字符串后，就相当于我们拿到了对应的对象。这里就类似于Spring中利用配置文件来反射对象。</p>
<p>上面的代码，我们利用了静态的BeanFactory，实际上已经实现了OCP原则。但唯一遗憾的是，如果BeanFactory变动了(比如原来的getHero方法改变了)，那我们还是需要修改main方法的。那有什么办法再把BeanFactory分离出去，更好地实现OCP原则吗？方法是有的，那就是Spring的IOC。在之前的代码中，我们都是<strong>主动地</strong>去要，主动地调用BeanFactory的方法。一旦改变，就会违反OCP。而使用Spring的IOC，我们是<strong>被动地</strong>接收，不再主动地去要。这样就分离了BeanFactory，也就使得OCP更加稳定，这就是所谓的控制反转。反转的是资源(不仅仅只是包括对象)的获取途径，从主动获取反转为被动接收。</p>
<p>新的问题又出现了？怎么被动接收呢？通过方法传参?</p>
<p>这就涉及到了另外一个概念———依赖注入(DI)，通常我们是在类的层面注入。就比如这里的main方法，虽然是在main方法中使用，但是通常是在main方法这个类中注入BeanFactory，这样main方法也可以去调用。</p>
<p>常用的两种依赖注入的方法：</p>
<p>1.属性注入</p>
<p>2.构造器注入</p>
]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title>文件复制.md</title>
    <url>/2020/08/10/%E7%BD%91%E7%BB%9C/%E5%9B%9B%E7%A7%8D%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="四种复制文件的方法"><a href="#四种复制文件的方法" class="headerlink" title="四种复制文件的方法"></a>四种复制文件的方法</h3><ul>
<li>字节复制</li>
<li>缓冲流复制</li>
<li>使用Buffer的FileChanel</li>
<li>直接使用FileChannel</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者 ming</span></span><br><span class="line"><span class="comment"> * @目标 当你的才华还撑不起你的野心时，就应该静下心来学习；</span></span><br><span class="line"><span class="comment"> * 当你的能力还驾驭不了你的目标时，就应该沉下心来历练；</span></span><br><span class="line"><span class="comment"> * 梦想不是浮躁，而是沉淀和积累。</span></span><br><span class="line"><span class="comment"> * @创建时间 2020/8/9 14:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> filecopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileCopyRunner runner1 = (source, target) -&gt; &#123;</span><br><span class="line">            InputStream fin = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream fout = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">                <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((size = fin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    fout.write(size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        File sourceFile1 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc&quot;</span>);</span><br><span class="line">        File targetFile1 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\runner1.doc&quot;</span>);</span><br><span class="line">        runner1.copyFile(sourceFile1, targetFile1);</span><br><span class="line">        System.out.println(<span class="string">&quot;runner1总耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        FileCopyRunner runner2 = (source, target) -&gt; &#123;</span><br><span class="line">            InputStream fin = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream fout = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(source));</span><br><span class="line">                fout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(target));</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> ((fin.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    fout.write(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        File sourceFile2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc&quot;</span>);</span><br><span class="line">        File targetFile2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\runner2.doc&quot;</span>);</span><br><span class="line">        runner1.copyFile(sourceFile2, targetFile2);</span><br><span class="line">        System.out.println(<span class="string">&quot;runner2总耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        FileCopyRunner runner3 = (source, target) -&gt; &#123;</span><br><span class="line">            FileChannel fin = <span class="keyword">null</span>;</span><br><span class="line">            FileChannel fout = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (fin.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 切换为写模式</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        fout.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 切换为读模式</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        File sourceFile3 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc&quot;</span>);</span><br><span class="line">        File targetFile3 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\runner3.doc&quot;</span>);</span><br><span class="line">        runner1.copyFile(sourceFile3, targetFile3);</span><br><span class="line">        System.out.println(<span class="string">&quot;runner3总耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        FileCopyRunner runner4 = (source, target) -&gt; &#123;</span><br><span class="line">            FileChannel fin = <span class="keyword">null</span>;</span><br><span class="line">            FileChannel fout = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fin = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">                fout = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line">                <span class="keyword">long</span> totalSize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (totalSize != fin.size()) &#123;</span><br><span class="line">                    totalSize += fin.transferTo(<span class="number">0</span>, fin.size(), fout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(fin);</span><br><span class="line">                close(fout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        File sourceFile4 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc&quot;</span>);</span><br><span class="line">        File targetFile4 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\IDEA Pro\\sockets\\src\\filecopy\\runner4.doc&quot;</span>);</span><br><span class="line">        runner1.copyFile(sourceFile4, targetFile4);</span><br><span class="line">        System.out.println(<span class="string">&quot;runner4总耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>文件复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Autowaired.md</title>
    <url>/2020/08/10/SpringBoot/Bean/Autowired/</url>
    <content><![CDATA[<p>面向抽象的编程，通常，我们会在类中定义接口，而注入的是接口的实现类。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/banner&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  Skill diana;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        diana.R();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Skill是接口。如果它有两个实现类Diana和Itera，那么到底哪个实现类会被注入呢？</p>
<p>注入的时候可能会发生的几种情况：</p>
<p>1.找不到任何一个bean ，报错</p>
<p>2.只找到一个bean，直接注入</p>
<p>3.找到多个bean，并不一定会报错，按照字段名字推断选择哪个bean</p>
<p>其实，总结起来就是两种方式：</p>
<p>1.通过类型注入</p>
<p>2.通过name注入 </p>
<p>通过类型注入的优先级 &gt; 通过name注入。@Autowaired默认是通过类型注入。</p>
<p>当注入Skill的实现类时，发现了有多个实现类，此时通过类型注入不能决定应该注入哪个实现类。</p>
<p>既然通过类型决定不了，就会通过字段名去推断要注入哪个类。而这种通过类型和name的注入是被动地注入，我们也可以使用@Qualify(“diana”)来指明主动地注入某一个实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;itrea&quot;)</span></span><br><span class="line">   <span class="keyword">private</span>  Skill diana;</span><br></pre></td></tr></table></figure>

<p>即使这里的字段名是diana，而我们使用了@Qualify主动注入了itera。最终注入的实现类还是itrea，调用的方法还是itrea的方法。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Conditional.md</title>
    <url>/2020/08/10/SpringBoot/Bean/Conditional/</url>
    <content><![CDATA[<p>条件注解可以解决策略模式多种实现类的问题。</p>
<p>使用自定义条件注解需要自己编写一个类实现conidtion接口，并在配置类中使用@conditional注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Conditional(DatabaseCondition.class)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Connect <span class="title">mysql</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MySql(<span class="keyword">this</span>.host,<span class="keyword">this</span>.port);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用spring自带的条件注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnProperty(value = &quot;database&quot;,havingValue = &quot;mysql&quot;,matchIfMissing = true)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connect <span class="title">mysql</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MySql(<span class="keyword">this</span>.host,<span class="keyword">this</span>.port);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>value的值是配置文件中的key。matchIfMissing相当于默认值。当在配置文件中找不到database的配置项时，默认将MySql这个类加入到IOC容器中。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Configuration.md</title>
    <url>/2020/08/10/SpringBoot/Bean/Configuration/</url>
    <content><![CDATA[<p>@Configuration也是一个将bean加入到IOC容器的注解。那么它和其他的模式注解有什么区别吗？</p>
<p>其他的模式注解只能将一个类加入到IOC容器，也能通过配置文件修改类的属性。但是它的缺点是不能应对一个接口有多个实现类的变化。假如需要注入的是另外的一个实现类，就很难实现了。</p>
<p>而@Configuration与@Bean的配合使用，不仅能通过配置文件修改类的属性，还能在将类加入到IOC容器前做一些逻辑处理。这种方式不仅可以应该属性带来的变化，还能通过条件注解来应对注入不同实现类的变化。</p>
<p>举个栗子：</p>
<p>比如现在有一个Connect接口，其有两个实现类MySql和Oracle。两个实现类都有各自的host和port属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySql</span> <span class="keyword">implements</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySql</span><span class="params">(String host, Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Oracle</span> <span class="keyword">implements</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Oracle</span><span class="params">(String host, Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在要将Mysql注入到IOC容器中，使用传统的模式注解和@Configuration都是可以完成的，也可以通过配置文件注入属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mysql.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mysql.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connect <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MySql(<span class="keyword">this</span>.host,<span class="keyword">this</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如现在需要注入的是Oracle的实现类，那么传统的模式注解就无法完成了。而@Configuration可以通过条件注解注入不同的实现类。</p>
<p>总结：@Configuration将bean加入IOC的方式更加灵活，它可以做逻辑处理，也可以一起注入多个Bean。它通过条件注解和配置文件注入属性，能够应对两种情况所带来的变化。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>延时加载.md</title>
    <url>/2020/08/10/SpringBoot/Bean/%E5%BB%B6%E6%97%B6%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>如何将一个类加入到Spring的IOC容器中呢？Spring为我们提供了5个注解：</p>
</blockquote>
<p>1.@Component</p>
<p>2.@Controller</p>
<p>3.@Service</p>
<p>4.@Repository</p>
<p>5.@Configuration</p>
<p>其中，@Component是最基本的注解，其他的4个注解都是基于@Component.</p>
<p>在现在的Spring版本中，@Controller、@Service、@Repository的作用与@Component一致，以后Spring的更新可能会增强这几个注解。</p>
<p>@Configuration与其他几个注解不同的是它可以将多个类加入到IOC容器，而其他注解一次只能加入一个类到IOC容器中。</p>
<p>细节：如果一个类没有加入到IOC容器中，而另外一个类注入了这个类，在IDEA中会报错。当然，可以设置IDEA的报错级别。最好的办法是设置@Autowired(required = false)，这样这个类不是必须的，服务器可以正常启动。要注意的是，如果有地方调用了这个类的方法，会引起NullPointException.</p>
<blockquote>
<p>Spring中的对象实例化的时机？</p>
</blockquote>
<p>我们猜测，对象的实例化时机有以下两种情况：</p>
<p>1.当要使用到对象的时候进行实例化。比如Controller，是在访问了url的时候，IOC容器才实例化Controller</p>
<p>2.当IOC容器启动的时候实例化。比如服务器启动，所有的对象都会被实例化。</p>
<p>通过在类的构造方法中添加输出语句，在服务器启动的时候就输出了语句，可以知道第二种情况是Spring种默认的实例化Bean的方式。</p>
<blockquote>
<p>延迟加载</p>
</blockquote>
<p>那有什么办法可以延迟实例化Bean吗？这时候就得请出来大哥——@Lazy</p>
<p>我们举个栗子。在下面的类中添加@Lazy注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diana</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Diana</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Diana start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">R</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Diana R&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在别的类中注入Diana这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/banner&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BannerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Diana diana;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;王小喵2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时，Diana就可以被延迟加载了吗？</p>
<p>答案是否定的。在控制台的输出结果中，还是出现了Diana Start。也就是在IOC容器启动的时候，Diana就被实例化了。</p>
<p>咦，那是哪里出了问题呢？<strong>问题在于BannerController中注入了Diana</strong>。如果一个类想要延时加载，必须保证其他类没有使用到它。不然使用了该类的其他类也需要延时加载。说起来有点绕，意思就是说BannerController注入了Diana类，而Diana类想要延时加载，那么BannerController类也需要加上@Lazy注解进行延时加载。</p>
<p>加上注解后验证，Diana和BannerController都被延迟加载了。那么，它们在什么时候会被实例化呢？没错，在使用到它们的时候就会被实例化。我们在浏览器中访问BannerController对应的url，控制台输出Diana Start，它们被实例化了。推测✔</p>
<p>注意：<strong>除非有特别好的理由，否则不推荐使用延时加载</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>延时加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JOIN方法.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/JOIN/</url>
    <content><![CDATA[<h3 id="JOIN方法的使用"><a href="#JOIN方法的使用" class="headerlink" title="JOIN方法的使用"></a>JOIN方法的使用</h3><blockquote>
<p>应用场景</p>
</blockquote>
<p>阻塞当前线程，等待调用JOIN方法的线程执行结束后才继续执行。</p>
<p>因为新的线程加入了我们，所以我们要等他执行完再出发。</p>
<blockquote>
<p>混淆点</p>
</blockquote>
<ul>
<li><p>JOIN方法是Thread类的方法，而notify()、notifyall()、wait()等方法是Object类的方法</p>
</li>
<li><p>主线程等待其他线程执行完的时候，主线程的状态是WAITING</p>
</li>
</ul>
<blockquote>
<p>方法的定义</p>
</blockquote>
<p>不带参数的join方法表示必须等调用JOIN方法的线程执行结束后，才继续执行当前线程。</p>
<p>方法内部调用的是以毫秒为单位的JOIN方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       join(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>以毫秒为单位的JOIN方法。</p>
<p>内部实现调用了Object的wait方法。</p>
<p>参数表示如果等待millis毫秒后，你还没执行完成，我就继续往下执行了。</p>
<p>join可以让本线程等待别的线程执行完毕， Thread.join()调用相当于Thread.join(0) ，代码内的逻辑是，先判断如果输入的时间小于0就抛异常，然后就分为两种情况：</p>
<p>第一种是传入0的情况，这也是默认的情况，那么就代表永久等待，直到线程执行完毕，但是我们去看代码，看到了：</p>
<p>while (isAlive()) {</p>
<p>​      wait(0);</p>
<p>​    }</p>
<p>但是哪里有唤醒的行为呢？我们前面讲过，wait(0)代表一直休眠，直到被notify()，那么为什么我们看不到notify()的相关代码，却依然能在线程运行结束后，自动被唤醒呢？</p>
<p>秘密就在Thread类在run方法运行结束后，自动执行notifyAll()，让我们看看一看JVM层代码：</p>
<p>通过对Jvm natvie的源码分析,我们发现thread执行完成后，cpp的源码中会在thread执行完毕后,会调用exit方法,该方法中原来隐含有调用notify_all(thread)的动作:</p>
<p>   void JavaThread::exit(booldestroy_vm,ExitTypeexit_type)；//做清理、收尾工作，</p>
<p>  上面的方法中会调用 ensure_join(this);</p>
<p>  下面是ensure_join方法的源码:</p>
<p>  static void ensure_join(JavaThread*thread){</p>
<p>​     Handle threadObj(thread,thread-&gt;threadObj());</p>
<p>​     ObjectLocker lock(threadObj,thread);thread-&gt;clear_pending_exception();</p>
<p>​     java_lang_Thread::set_thread_status(threadObj(),java_lang_Thread::TERMINATED);</p>
<p>​     java_lang_Thread::set_thread(threadObj(),NULL);</p>
<p>​     lock.notify_all(thread); //这里执行了notify_all,进行了wait的唤醒</p>
<p>​     thread-&gt;clear_pending_exception();</p>
<p>  }</p>
<p>  通过以上分析后，我们就可以有了join的替代写法:</p>
<p>​    synchronized(thA) { </p>
<p>​       thA.wait(); </p>
<p>​    }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 等待的时间为0，只有线程还是运行状态，则永远等待</span></span><br><span class="line">    	<span class="comment">// 这里使用了wait方法，那么在哪里notify/notify呢？</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两个参数的JOIN方法，实现对纳秒级别的控制，很少使用。</p>
<p>当纳秒数大于500000，或者纳秒不为0，毫秒为0时，使毫秒数+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意点</p>
</blockquote>
<p>1.如果同时调用多个join，join会有一定的顺序。</p>
<p>2.join是一个native方法</p>
<blockquote>
<p>join方法中使用了wait方法，那么在哪里notify/notify呢？</p>
</blockquote>
<p>在每个线程的run方法结束后，会执行notify/notifyall方法</p>
<h4 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h4><p>创建两个线程，每个线程休眠2s后，输出当前线程状态。</p>
<p>在main线程中调用join方法，等待两个线程执行完毕后继续执行main线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;run over! &quot;</span> + Thread.currentThread().getState());</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;run over! &quot;</span> + Thread.currentThread().getState());</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;are waiting  &quot;</span> + thread1.getName() + <span class="string">&quot; and &quot;</span> + thread2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里参数设置为1000，有特别意义</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;join:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            thread1.join(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;join:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            thread2.join(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;join:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;final: &quot;</span> + thread1.getName() + thread1.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;final: &quot;</span> + thread2.getName() + thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>34s的时候调用thread1.join方法，在thread1线程的run方法是sleep2s，参数设置为等待1s后继续往下执行。</p>
<p>即当35s的时候调用thread2.join方法，在thread2线程的run方法是sleep2s，但是在34s的时候thread1,thread2都start了，</p>
<p>所以在36s的时候，thread1，thread2都已经执行完成了。</p>
<p>那么，就会有一个问题，main方法接下来的输出语句和thread1,thread2中run方法的输出语句，哪个先执行？</p>
<p><strong>这是不确定的，多次运行会发现结果不同，而结果的不同会体现在线程的状态不同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程先执行完后输出语句</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]are waiting  Thread-<span class="number">0</span> and Thread-<span class="number">1</span></span><br><span class="line">join:Wed Jun <span class="number">24</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">34</span> CST <span class="number">2020</span></span><br><span class="line">join:Wed Jun <span class="number">24</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">35</span> CST <span class="number">2020</span></span><br><span class="line">Thread-1run over! RUNNABLE</span><br><span class="line">Thread-0run over! RUNNABLE</span><br><span class="line">join:Wed Jun <span class="number">24</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">36</span> CST <span class="number">2020</span></span><br><span class="line"><span class="keyword">final</span>: Thread-0TERMINATED</span><br><span class="line"><span class="keyword">final</span>: Thread-1TERMINATED</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先输出了语句，线程再执行完。好像会受输出时间的打印语句影响？？？</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]are waiting  Thread-<span class="number">0</span> and Thread-<span class="number">1</span></span><br><span class="line"><span class="keyword">final</span>: Thread-0RUNNABLE</span><br><span class="line"><span class="keyword">final</span>: Thread-1BLOCKED  <span class="comment">// 这里的BLOCKED是IO的阻塞，因为线程的BLOCKED状态只有在ysnchronized的时候才会出现</span></span><br><span class="line">Thread-0run over! RUNNABLE</span><br><span class="line">Thread-1run over! RUNNABLE</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run over!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//调用主线程的interrupt方法, 开启中断标记, 会影响主线中的join方法抛出异常,但是并不会阻碍t1线程的运行</span></span><br><span class="line">            mainThread.interrupt();</span><br><span class="line">            System.out.println(mainThread.getName() + <span class="string">&quot; interrupt!&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run over!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait &quot;</span> + t1.getName() + <span class="string">&quot; and &quot;</span> + t2.getName() + <span class="string">&quot; run over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();  <span class="comment">// 等待t1线程执行完毕，才继续往下执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;final:&quot;</span> + t1.getName() + <span class="string">&quot; and &quot;</span> + t2.getName() + <span class="string">&quot; run over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1&#x27;s state:&quot;</span> + t1.getState()); <span class="comment">// TIME_WAITING</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t2&#x27;s state:&quot;</span> + t2.getState()); <span class="comment">// TERMINTED</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main&#x27;s state:&quot;</span> + mainThread.getState()); <span class="comment">// RUNNABLE，</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>main方法运行后，thread2先运行，thread2中中断了main线程，影响了main线程的join方法，抛出异常，但不会影响thread1的执行。</p>
<p>从异常信息可以看到，中断main线程影响的是main线程中的join方法，thread1仍然正常执行，从thread1的线程状态是TIMED_WAITING可以看出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main wait Thread-<span class="number">0</span> and Thread-<span class="number">1</span> run over!</span><br><span class="line">main interrupt!</span><br><span class="line">Thread-<span class="number">1</span> run over!</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1252</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1326</span>)</span><br><span class="line">	at thread03.JoinDemo02.main(JoinDemo02.java:<span class="number">28</span>)</span><br><span class="line"><span class="keyword">final</span>:Thread-<span class="number">0</span> and Thread-<span class="number">1</span> run over!</span><br><span class="line">t1<span class="string">&#x27;s state:TIMED_WAITING</span></span><br><span class="line"><span class="string">t2&#x27;</span>s state:TERMINATED</span><br><span class="line">main<span class="string">&#x27;s state:RUNNABLE</span></span><br><span class="line"><span class="string">Thread-0 run over!</span></span><br></pre></td></tr></table></figure>

<p>接着，我们修改一下线程2的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//修改为t1.interrupt();观察效果, 会影响t1线程的sleep方法抛出异常,让t1线程结束</span></span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(t1.getName() + <span class="string">&quot; interrupt!&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run over!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>在thread2的方法中中断thread1的执行，这时中断的是thread1的sleep方法，thread1会抛出异常，继续往下执行，不再sleep了。</p>
<p>从异常信息可以看出是thread1的sleep方法被打断了，而且thread1的线程状态是TERMINATED。而main线程的状态是RUNNABLE，对主线程无影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main wait Thread-<span class="number">0</span> and Thread-<span class="number">1</span> run over!</span><br><span class="line">Thread-<span class="number">0</span> interrupt!</span><br><span class="line">Thread-<span class="number">1</span> run over!</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at thread03.JoinDemo02.lambda$main$<span class="number">0</span>(JoinDemo02.java:<span class="number">18</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Thread-<span class="number">0</span> run over!</span><br><span class="line"><span class="keyword">final</span>:Thread-<span class="number">0</span> and Thread-<span class="number">1</span> run over!</span><br><span class="line">t1<span class="string">&#x27;s state:TERMINATED</span></span><br><span class="line"><span class="string">t2&#x27;</span>s state:TERMINATED</span><br><span class="line">main<span class="string">&#x27;s state:RUNNABLE</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>interrupt方法可以中断sleep()、join()等方法</li>
<li>某个线程如果被interrupt()打断，会抛出InterruptedException，并继续往下执行。可以在抛出异常后，再次调用子线程的interrupt方法，将中断信号传递给子线程。子线程处理中断信号后，就不会继续往下执行了</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>yield方法.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/Yield/</url>
    <content><![CDATA[<h3 id="yield方法的使用"><a href="#yield方法的使用" class="headerlink" title="yield方法的使用"></a>yield方法的使用</h3><ul>
<li>Thread类中的静态native方法</li>
<li>让出剩余的时间片，本身进入就绪状态,不释放锁</li>
<li>cpu调度还可能调度到本线程</li>
<li>sleep是在一段时间内进入阻塞状态，cpu不会调度它。而yield是让出执行权，本身还处于<strong>就绪状态</strong>，cpu还可能立即调度它</li>
</ul>
<h3 id="yield方法的定义"><a href="#yield方法的定义" class="headerlink" title="yield方法的定义"></a>yield方法的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldDemo02</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; yield&quot;</span>);</span><br><span class="line">            <span class="comment">// 打开关闭此注释查看输出效果，对比差异</span></span><br><span class="line">            <span class="keyword">this</span>.yield();</span><br><span class="line">		   System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            YieldDemo02 demo = <span class="keyword">new</span> YieldDemo02();</span><br><span class="line">            demo.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>yield是有建议权的，一旦cpu采取了它的建议，就会让出时间片。</p>
<p>但是执行结果却是“间接”的，无论线程的数量有多少，执行结果都是间接有序的，这是为什么呢？</p>
<p>因为有synchronized关键字，synchronized保证原子性。而另一方面，也说明了yield()方法只是让出剩余的时间片，但是<strong>不释放锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> yield</span><br><span class="line">Thread-<span class="number">0</span> run over</span><br><span class="line">Thread-<span class="number">4</span> yield</span><br><span class="line">Thread-<span class="number">4</span> run over</span><br></pre></td></tr></table></figure>

<h3 id="await与yield的对比"><a href="#await与yield的对比" class="headerlink" title="await与yield的对比"></a>await与yield的对比</h3><ul>
<li>wait也是让出执行权，它与yield的区别是，wait会释放锁</li>
<li>wait需要配合使用synchronized关键字和notifyAll()使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldDemo02</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; yield&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用wait方法来做对比，查看释放锁与不释放锁的区别</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            YieldDemo02 demo = <span class="keyword">new</span> YieldDemo02();</span><br><span class="line">            demo.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配合wait使用看效果</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>输出结果是先输出yield，再输出run over。且先输出yield的后输出run over。</p>
<p>可以看出，虽然在synchronized代码块内，但是wait方法是释放锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> yield</span><br><span class="line">Thread-<span class="number">1</span> yield</span><br><span class="line">Thread-<span class="number">1</span> run over</span><br><span class="line">Thread-<span class="number">0</span> run over</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>yield方法最好不要使用，JDK也不推荐使用，但是保留这个方法的目的是在一些包中会有使用到，我们自己尽量不要去使用</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的方式.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="方式一：继承Thread类创建线程"><a href="#方式一：继承Thread类创建线程" class="headerlink" title="方式一：继承Thread类创建线程"></a>方式一：继承Thread类创建线程</h3><p>在举栗子之前，我们先定义一个Account实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer accountId; <span class="comment">// 账户id</span></span><br><span class="line">    <span class="keyword">private</span> String accountName; <span class="comment">// 账户名称</span></span><br><span class="line">    <span class="keyword">private</span> Boolean vaild; <span class="comment">// 账户状态是否可用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(Integer accountId, String accountName, Boolean vaild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountId = accountId;</span><br><span class="line">        <span class="keyword">this</span>.accountName = accountName;</span><br><span class="line">        <span class="keyword">this</span>.vaild = vaild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;accountId=&quot;</span> + accountId +</span><br><span class="line">                <span class="string">&quot;, accountName=&#x27;&quot;</span> + accountName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, vaild=&quot;</span> + vaild +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAccountId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountId</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountId = accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountName = accountName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getVaild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vaild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVaild</span><span class="params">(Boolean vaild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vaild = vaild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用继承Thread类的方法创建线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByExtend</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByExtend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByExtend</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行run方法时，thread的状态:&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行run方法时，account information:&quot;</span> + <span class="keyword">this</span>.account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(<span class="number">1</span>, <span class="string">&quot;account1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        CreateThreadByExtend thread1 = <span class="keyword">new</span> CreateThreadByExtend();</span><br><span class="line">        thread1.setAccount(acc);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread对象已经创建，但是还没有start时，线程的状态:&quot;</span> + thread1.getName() + <span class="string">&quot;:&quot;</span> + thread1.getState());</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程已经执行完毕</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thread已经运行完毕后，线程的状态:&quot;</span> + thread1.getName() + <span class="string">&quot;:&quot;</span> + thread1.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;thread执行完毕后，account information:&quot;</span> + acc);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> CreateThreadByExtend(acc);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread对象已经创建，但是还没有start时，线程的状态:Thread-<span class="number">0</span>:NEW</span><br><span class="line">正在执行run方法时，thread的状态:Thread-<span class="number">0</span>:RUNNABLE</span><br><span class="line">正在执行run方法时，account information:Account&#123;accountId=<span class="number">1</span>, accountName=<span class="string">&#x27;account1&#x27;</span>, vaild=<span class="keyword">true</span>&#125;</span><br><span class="line">thread已经运行完毕后，线程的状态:Thread-<span class="number">0</span>:TERMINATED</span><br><span class="line">thread执行完毕后，account information:Account&#123;accountId=<span class="number">1</span>, accountName=<span class="string">&#x27;account1&#x27;</span>, vaild=<span class="keyword">true</span>&#125;</span><br><span class="line">*************************</span><br><span class="line">正在执行run方法时，thread的状态:Thread-<span class="number">1</span>:RUNNABLE</span><br><span class="line">正在执行run方法时，account information:Account&#123;accountId=<span class="number">1</span>, accountName=<span class="string">&#x27;account1&#x27;</span>, vaild=<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下几个问题：</p>
<p>1.变量可以通过什么方式传递给线程？</p>
<p>​        可以通过setter方法，或者带参构造函数。</p>
<p>2.线程的状态？</p>
<p>​        在new Thread，但未start之前，线程的状态是NEW。在start线程后，线程的状态是RUNNABLE。在线程运行完成后，线程的状态是TERMINATED。</p>
<p>3.使用继承Thread的方式创建线程有什么优点、缺点？</p>
<pre><code>* 优点：可以使用Thread类已经有的方法，可以使用this去调用
* 缺点：Java的单继承机制使得只能继承Thread一个类
</code></pre>
<hr>
<h3 id="方式二：使用Runnable创建线程"><a href="#方式二：使用Runnable创建线程" class="headerlink" title="方式二：使用Runnable创建线程"></a>方式二：使用Runnable创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByImplement</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByImplement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByImplement</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行run方法时，thread的状态:&quot;</span> + Thread.currentThread() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行run方法时，account information:&quot;</span> + <span class="keyword">this</span>.account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(<span class="number">1</span>, <span class="string">&quot;account1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        CreateThreadByImplement runnable = <span class="keyword">new</span> CreateThreadByImplement();</span><br><span class="line">        runnable.setAccount(acc);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thread对象已经创建，但是还没有start时，线程的状态:&quot;</span> + thread1.getName() + <span class="string">&quot;:&quot;</span> + thread1.getState());</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程已经执行完毕</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thread已经运行完毕后，线程的状态:&quot;</span> + thread1.getName() + <span class="string">&quot;:&quot;</span> + thread1.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;thread执行完毕后，account information:&quot;</span> + acc);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThreadByImplement(acc));</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现Runnable接口的类需要借助Thread类来启动线程，因为Runnable接口中没有start()方法。</p>
</li>
<li><p>不能使用this关键字了，需要使用Thread的静态方法来获取线程信息等。</p>
</li>
<li><p>使用Runnable接口实现可以继承其他类且可以继承多个接口，缺点是在run方法中不可以用this直接使用Thread的方法，需要使用Thread.currentThread先获取到线程对象</p>
</li>
</ul>
<hr>
<h3 id="方式三：使用Callable创建线程"><a href="#方式三：使用Callable创建线程" class="headerlink" title="方式三：使用Callable创建线程"></a>方式三：使用Callable创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateThreadByCallable</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行run方法时，account information:&quot;</span> + <span class="keyword">this</span>.account);</span><br><span class="line">        <span class="keyword">this</span>.account.setVaild(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(<span class="number">1</span>, <span class="string">&quot;account1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        CreateThreadByCallable callable = <span class="keyword">new</span> CreateThreadByCallable(acc);</span><br><span class="line">        callable.setAccount(acc);</span><br><span class="line">        FutureTask&lt;Account&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Account&gt;(callable);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程已经执行完毕</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;在call方法中修改Account信息后，account information:&quot;</span> + acc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Callable接收一个泛型参数，这个参数影响call方法的返回值以及FutureTask的类型值。</p>
<p>使用Callable接口创建线程，</p>
<ul>
<li>优点：线程可以有返回值</li>
<li>缺点：需要使用FutureTask封装一层，再传递给Thread</li>
</ul>
<h3 id="对比：执行run方法的本质"><a href="#对比：执行run方法的本质" class="headerlink" title="对比：执行run方法的本质"></a>对比：执行run方法的本质</h3><p>我们来看一下继承Thread类的run方法是怎么实现的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread类的run方法实际上是调用Runnable接口的run方法。但如果是继承Thread类来实现线程，那就重写了Thread类的run方法，启动线程实际上执行的是重写后的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">extend</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 自己编写的run方法，覆盖了Thread类原有的run方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证1：到底执行谁的run方法？"><a href="#验证1：到底执行谁的run方法？" class="headerlink" title="验证1：到底执行谁的run方法？"></a>验证1：到底执行谁的run方法？</h4><p>我们采用传入一个Runnable对象的方式创建一个线程。既实现Runnable接口的run方法，又重写Thread类的run方法，那么线程启动到底执行哪个run方法呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类的方式创建Runnable对象，如果使用Lambda表达式，不能在Lambda表达式中重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothThreadAndRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是Runnable接口的run方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是重写Thread类的run方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是重写Thread类的run方法</span><br></pre></td></tr></table></figure>

<p>从执行结果可知，我们重写的run方法覆盖了Thread类的run方法。也就是覆盖了Thread类的以下代码，使得Thread不再调用Runnable对象的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是重写Thread类的run方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们重写的run方法(⬆)覆盖了Thread类的run方法(⬇)</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试1：一句话总结线程的创建方式"><a href="#面试1：一句话总结线程的创建方式" class="headerlink" title="面试1：一句话总结线程的创建方式"></a>面试1：一句话总结线程的创建方式</h3><p>准确地讲，创建线程只有一种方式，那就是<strong>构造</strong>Thread类。而实现线程的执行单元有两种方式：</p>
<ul>
<li>实现Runnable接口的run方法，并把Runnable实例传递给Thread类</li>
<li>继承Thread类，重写Thread类的run方法</li>
</ul>
<h3 id="面试2：继承Thread类和实现Runnable接口的方法有什么优缺点？"><a href="#面试2：继承Thread类和实现Runnable接口的方法有什么优缺点？" class="headerlink" title="面试2：继承Thread类和实现Runnable接口的方法有什么优缺点？"></a>面试2：继承Thread类和实现Runnable接口的方法有什么优缺点？</h3><blockquote>
<p>继承Thread类</p>
</blockquote>
<p>优点：</p>
<ul>
<li>可以直接使用this关键字调用Thread类当中的方法</li>
</ul>
<p>缺点：</p>
<ul>
<li>Java中不支持多继承，缺少灵活性、扩展性</li>
<li>新建线程的损耗多，一个Thrad类就只能使用一次</li>
</ul>
<blockquote>
<p>实现Runnable接口</p>
</blockquote>
<p>优点：</p>
<ul>
<li>灵活性、扩展性好</li>
<li>新建线程的损耗小，实现了Runnable的对象可以被多个Thread反复使用</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能使用this关键字，需要使用Thread的静态方法</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>子线程异常处理.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="栗子1：主线程无法捕获子线程抛出的异常"><a href="#栗子1：主线程无法捕获子线程抛出的异常" class="headerlink" title="栗子1：主线程无法捕获子线程抛出的异常"></a>栗子1：主线程无法捕获子线程抛出的异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-3&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-4&quot;</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程捕获了子线程抛出的异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是来自子线程的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>因为try..catch..只能捕获当前线程内抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;thread-1&quot;</span> Exception in thread <span class="string">&quot;thread-4&quot;</span> Exception in thread <span class="string">&quot;thread-2&quot;</span> Exception in thread <span class="string">&quot;thread-3&quot;</span> java.lang.RuntimeException: 我是来自子线程的异常</span><br><span class="line">	at threadexception.MyThread.run(UnCaughtException.java:<span class="number">34</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.RuntimeException: 我是来自子线程的异常</span><br><span class="line">	at threadexception.MyThread.run(UnCaughtException.java:<span class="number">34</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.RuntimeException: 我是来自子线程的异常</span><br><span class="line">	at threadexception.MyThread.run(UnCaughtException.java:<span class="number">34</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.RuntimeException: 我是来自子线程的异常</span><br><span class="line">	at threadexception.MyThread.run(UnCaughtException.java:<span class="number">34</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<h3 id="栗子2：使用Thread类的UncaughtExceptionHandler接口实现全局捕获异常"><a href="#栗子2：使用Thread类的UncaughtExceptionHandler接口实现全局捕获异常" class="headerlink" title="栗子2：使用Thread类的UncaughtExceptionHandler接口实现全局捕获异常"></a>栗子2：使用Thread类的UncaughtExceptionHandler接口实现全局捕获异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义异常处理器，由于是函数式接口，可以使用Lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;发生了异常;&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置默认的异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UnCaughtExceptionHandler());</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;thread-4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是来自子线程的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread-<span class="number">1</span>发生了异常;我是来自子线程的异常</span><br><span class="line">thread-<span class="number">3</span>发生了异常;我是来自子线程的异常</span><br><span class="line">thread-<span class="number">2</span>发生了异常;我是来自子线程的异常</span><br><span class="line">thread-<span class="number">4</span>发生了异常;我是来自子线程的异常</span><br></pre></td></tr></table></figure>

<h3 id="如何处理子线程出现的异常？"><a href="#如何处理子线程出现的异常？" class="headerlink" title="如何处理子线程出现的异常？"></a>如何处理子线程出现的异常？</h3><ul>
<li>在子线程内部try..catch..处理</li>
<li>设置Thread默认的异常处理器，全局处理异常</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础，异常</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>死锁就是两个（或更多）线程相互持有对方所需要的资源，又不主动释放资源，导致程序陷入无尽的阻塞，这就是死锁。</p>
<p><strong>多个线程造成死锁的情况</strong>：等待的资源，形成一个环</p>
<h3 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h3><ul>
<li>死锁的影响在不同的系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li>数据库中：检测并放弃事务</li>
<li>JVM中：无法自行处理，但是JVM能检测出死锁</li>
</ul>
</li>
</ul>
<h3 id="一个必然造成死锁的栗子"><a href="#一个必然造成死锁的栗子" class="headerlink" title="一个必然造成死锁的栗子"></a>一个必然造成死锁的栗子</h3><ul>
<li>当类的对象flag=1时（T1），先锁定O1,睡眠500毫秒，然后锁定O2；</li>
<li>而T1在睡眠的时候另一个flag=0的对象（T2）线程启动，先锁定O2,睡眠500毫秒，等待T1释放O1；</li>
<li>T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定；</li>
<li>T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定；</li>
<li>T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁。</li>
</ul>
<p>同时注意一点，死锁的程序退出状态码是130.</p>
<blockquote>
<p>Process finished with exit code <strong>130</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/22 22:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 演示必然造成死锁的栗子，线程1先获取lock1锁，线程2先获取lock2锁</span></span><br><span class="line"><span class="comment"> * 短暂休眠保证两个线程都获取了锁之后，之后争夺类锁会造成死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustHappenDeedLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 控制不同的进程执行不同的代码块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 必须加static关键字，如果是对象锁，则不会造成死锁，因为使用不同的对象创建线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程争夺类锁</span></span><br><span class="line">        MustHappenDeedLock mustHappenDeedLock1 = <span class="keyword">new</span> MustHappenDeedLock();</span><br><span class="line">        MustHappenDeedLock mustHappenDeedLock2 = <span class="keyword">new</span> MustHappenDeedLock();</span><br><span class="line">        mustHappenDeedLock1.flag = <span class="number">0</span>;</span><br><span class="line">        mustHappenDeedLock2.flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(mustHappenDeedLock1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mustHappenDeedLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得了两把锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得了两把锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h3><ul>
<li>互坼条件：在同一时刻，只能有一个线程拥有资源</li>
<li>请求与保持条件：自己不释放资源，又去申请别的资源</li>
<li>不剥夺条件：没有外界的干扰</li>
<li>循环等待条件：多个线程没有形成环路</li>
</ul>
<p><strong>死锁的形成，这4个条件缺一不可</strong></p>
<h3 id="如何定位死锁"><a href="#如何定位死锁" class="headerlink" title="如何定位死锁"></a>如何定位死锁</h3><ul>
<li>jstack（jvm命令，可以先用jps lvm查看JVM进程）</li>
<li>ThreadMXBean（代码）</li>
</ul>
<h3 id="修复死锁的策略"><a href="#修复死锁的策略" class="headerlink" title="修复死锁的策略"></a>修复死锁的策略</h3><blockquote>
<p>线上发生死锁应该怎么办</p>
</blockquote>
<ul>
<li>保存案发现场，然后立刻重启服务器</li>
<li>暂时保证线上服务的安全，然后再利用刚才保存的信息，排查死锁，修改代码，重新发布</li>
</ul>
<blockquote>
<p>1.避免策略</p>
</blockquote>
<ul>
<li>避免相反的获取锁的顺序<pre><code>    * 通过hashcode来决定获取锁的顺序，冲突时需要“加时赛”
      * 实际工程中可以利用数据库的主键
</code></pre>
</li>
<li>哲学家就餐问题</li>
</ul>
<blockquote>
<p>2.检测与恢复策略</p>
</blockquote>
<p>​        一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁</p>
<p><img src="D:\ming\images\image-20200723212820862.png" alt="image-20200723212820862"></p>
<blockquote>
<p>3.鸵鸟策略</p>
</blockquote>
<p>​    如果发生死锁的概率非常低，我们就直接忽略它，直到死锁发生的时候，再人工修复。</p>
<h3 id="栗子1：哲学家就餐问题（换序避免死锁）"><a href="#栗子1：哲学家就餐问题（换序避免死锁）" class="headerlink" title="栗子1：哲学家就餐问题（换序避免死锁）"></a>栗子1：哲学家就餐问题（换序避免死锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/21 20:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 哲学家就餐问题演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建哲学家</span></span><br><span class="line">        Philosopher[] philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 创建筷子</span></span><br><span class="line">        Object[] chopsticks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chopsticks.length; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftChopstick = chopsticks[i];</span><br><span class="line">            Object rightChopstick = chopsticks[(i + <span class="number">1</span>) % chopsticks.length];</span><br><span class="line">            <span class="comment">// 最后一位哲学家，先拿右边的筷子,避免死锁</span></span><br><span class="line">            <span class="keyword">if</span> (i == philosophers.length - <span class="number">1</span>) &#123;</span><br><span class="line">                philosophers[i] = <span class="keyword">new</span> Philosopher(rightChopstick, leftChopstick);</span><br><span class="line">            &#125;</span><br><span class="line">            philosophers[i] = <span class="keyword">new</span> Philosopher(leftChopstick, rightChopstick);</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i], <span class="string">&quot;哲学家&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个线程代表一个哲学家</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象代表筷子</span></span><br><span class="line">        <span class="keyword">private</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Object left, Object right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                doAction(<span class="string">&quot;thinking&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取左边的筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                    doAction(<span class="string">&quot;获取左边的筷子&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                        doAction(<span class="string">&quot;获取右边的筷子- eating&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doAction(<span class="string">&quot;放下右边的筷子&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                doAction(<span class="string">&quot;放下左边的筷子&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + action);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadLocalRandom.current().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另：哲学界就餐问题解决的4种方案：</p>
<ul>
<li>服务员检查（避免策略）</li>
<li>改变一个哲学界拿叉子的顺序，换序（避免策略）</li>
<li>餐票，只有拿到餐票的才能就餐，就餐完返回餐票（避免策略）</li>
<li>领导调节（检测与恢复策略）</li>
</ul>
<h3 id="栗子2：银行转账（hashCode换序避免死锁）"><a href="#栗子2：银行转账（hashCode换序避免死锁）" class="headerlink" title="栗子2：银行转账（hashCode换序避免死锁）"></a>栗子2：银行转账（hashCode换序避免死锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/22 22:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 银行转账的栗子，演示死锁的发生，以及通过换序避免死锁的产生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeedLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Account account1 = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Account account2 = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TransferMoneyDeedLock transferMoneyDeedLock1 = <span class="keyword">new</span> TransferMoneyDeedLock();</span><br><span class="line">        TransferMoneyDeedLock transferMoneyDeedLock2 = <span class="keyword">new</span> TransferMoneyDeedLock();</span><br><span class="line">        transferMoneyDeedLock1.flag = <span class="number">0</span>;</span><br><span class="line">        transferMoneyDeedLock2.flag = <span class="number">1</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(transferMoneyDeedLock1, <span class="string">&quot;account1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(transferMoneyDeedLock2, <span class="string">&quot;account2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;account1 balance:&quot;</span> + account1.balance);</span><br><span class="line">        System.out.println(<span class="string">&quot;account2 balance:&quot;</span> + account2.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(account1, account2, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(account2, account1, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象的hashcode来决定获取锁的顺序</span></span><br><span class="line">        <span class="keyword">int</span> fromHashCode = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHashCode = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHashCode &gt; toHashCode) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    transferHelper(from, to, amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHashCode &lt; toHashCode) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    transferHelper(from, to, amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hash冲突的情况，额外加一把锁，公平竞争执行的机会</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 先对from加锁还是to加锁已经不重要了,有了外层的lock,from和to不会同时被获取</span></span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                        transferHelper(from, to, amount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferHelper</span><span class="params">(Account from, Account to, Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from.balance - amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            from.balance -= amount;</span><br><span class="line">            to.balance += amount;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;转账&quot;</span> + amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h3><ul>
<li>设置超时时间</li>
<li>多使用并发类而不是自己设计锁</li>
<li>尽量降低锁的使用粒度：用不同的锁而不是一个锁</li>
<li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li>
<li>给线程起个有意义的名字：debug和排查时事半功倍</li>
<li>避免锁的嵌套</li>
<li>分配资源前先看能不能收回来：银行家算法</li>
<li>尽量不要几个功能用同一把锁：专锁专用</li>
</ul>
<h3 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h3><p>虽然线程并没有阻塞，也始终在运行，但是程序却得不到进展，因为线程始终重复做同样的事</p>
<h3 id="栗子2：牛郎织女没饭吃（加入随机因素解决活锁）"><a href="#栗子2：牛郎织女没饭吃（加入随机因素解决活锁）" class="headerlink" title="栗子2：牛郎织女没饭吃（加入随机因素解决活锁）"></a>栗子2：牛郎织女没饭吃（加入随机因素解决活锁）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/21 21:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 演示活锁，牛郎和织女互相谦让勺子，最后谁都吃不上饭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Diner boy = <span class="keyword">new</span> Diner(<span class="string">&quot;牛郎&quot;</span>);</span><br><span class="line">        Diner girl = <span class="keyword">new</span> Diner(<span class="string">&quot;织女&quot;</span>);</span><br><span class="line">        <span class="comment">// 牛郎先拥有勺子</span></span><br><span class="line">        Spoon spoon = <span class="keyword">new</span> Spoon(boy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; boy.eatWith(spoon, girl)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; girl.eatWith(spoon, boy)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Diner owner;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Diner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(owner.name + <span class="string">&quot;正在使用勺子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isHunger;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            isHunger = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Spoon spoon, Diner partner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.isHunger) &#123;</span><br><span class="line">                <span class="comment">// 先判断勺子在不在自己手上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> != spoon.owner) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断女朋友饿不饿</span></span><br><span class="line">                 <span class="comment">// 加入随机因素解决活锁</span></span><br><span class="line">                <span class="keyword">int</span> random = ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (partner.isHunger &amp;&amp; random &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;:亲爱的，你先吃吧&quot;</span>);</span><br><span class="line">                    spoon.owner = partner;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 勺子在自己手上</span></span><br><span class="line">                spoon.use();</span><br><span class="line">                <span class="keyword">this</span>.isHunger = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;吃完了&quot;</span>);</span><br><span class="line">                spoon.owner = partner;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是饥饿"><a href="#什么是饥饿" class="headerlink" title="什么是饥饿"></a>什么是饥饿</h3><p>当线程需要某些资源（例如CPU），但是却始终得不到</p>
<ul>
<li>线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁</li>
<li>饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="栗子1：使用wait-notify方法来实现"><a href="#栗子1：使用wait-notify方法来实现" class="headerlink" title="栗子1：使用wait/notify方法来实现"></a>栗子1：使用wait/notify方法来实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">new</span> Container();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(container)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(container)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                container.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                container.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类似于阻塞队列的容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxSize = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Container</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列已满，阻塞等待，使用while而不是使用if</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.queue.size() == maxSize) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加到容器,容器内还有&quot;</span> + <span class="keyword">this</span>.queue.size() + <span class="string">&quot;个数据&quot;</span>);</span><br><span class="line">        <span class="comment">// 通知消费者取数据</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列为空，阻塞等待，使用while而不是使用if</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;取出数据，容器内还有&quot;</span> + <span class="keyword">this</span>.queue.size() + <span class="string">&quot;个数据&quot;</span>);</span><br><span class="line">        <span class="comment">// 通知生产者生产数据</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>从JVM的内存模型上看，线程安全的问题是由于多个线程争夺共享内存的同一共享资源而产生的。</p>
<ul>
<li><p>多个线程争夺共享内存的同一共享资源就一定会产生线程安全问题吗？</p>
<p>不一定，如果多条线程不修改共享资源，那么不会产生线程安全问题。</p>
</li>
</ul>
<p><img src="D:\ming\images\image-20200621212819018.png" alt="image-20200621212819018"></p>
<h3 id="线程安全产生的两个原因"><a href="#线程安全产生的两个原因" class="headerlink" title="线程安全产生的两个原因"></a>线程安全产生的两个原因</h3><ul>
<li><p>可见性</p>
<p>多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。</p>
</li>
<li><p>原子性</p>
<p>和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败</p>
</li>
</ul>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>User类是一个实体类，提供了set方法修改密码。</p>
<p>UserServlet中提供了setPass的方法修改密码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPass</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.set(user.getName(), user.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个线程访问UserServlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServlet userServlet = <span class="keyword">new</span> UserServlet();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; userServlet.setPass(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;777777&quot;</span>))).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; userServlet.setPass(<span class="keyword">new</span> User(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;888888&quot;</span>))).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的共享资源是什么？</p>
</blockquote>
<ul>
<li><p>误区1： 被抢占的资源是User</p>
<p>实际上，User对象是在每个线程的独立工作内存中创建的。它并不是共享资源。</p>
</li>
</ul>
<p>这里的共享资源是UserServlet对象。两个线程共享着主内存区域创建的UserServlet对象。当每个线程调用setPass方法的时候，争夺UserServlet对象的使用权来修改自己独有内存区域的User对象的name和password。</p>
<blockquote>
<p> 这里是线程安全的吗？</p>
</blockquote>
<p>线程安全！虽然两个线程共享着同一个UserServlet对象，但是线程只是调用UserServlet里的setPass方法来修改线程自己内存区域的对象，而不是对共享资源的修改，所以不存在线程安全的问题。</p>
<p>而且UserServlet不存在全局变量或静态变量被修改。</p>
<blockquote>
<p>new出来的对象不是存放在堆中吗？而堆是共享内存，为什么不存在线程安全问题？</p>
</blockquote>
<p>JVM的内存模型中，方法区和堆是共享内存区，而虚拟机栈、本地方法栈、程序技术器是每个线程独有的。</p>
<p>虽然new出来的对象保存在堆中，但是对象的引用保存在线程独有的虚拟机栈中。并不会被别的线程修改，所以不存在线程安全的问题。</p>
<blockquote>
<p>运行结果</p>
</blockquote>
<p>不管运行多少次，结果都一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]:李四:<span class="number">777777</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]:王五:<span class="number">888888</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p>多条线程抢占共享区的对象使用权，调用对象的方法，并不会引起线程安全的问题。</p>
<h3 id="例子1修改"><a href="#例子1修改" class="headerlink" title="例子1修改"></a>例子1修改</h3><p>这个例子与上面的不同的地方在于UserServlet中有一个默认User对象。提供给外部一个根据name和password修改默认User对象的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;11111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPass</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        user.set(name, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       UserServlet userServlet = <span class="keyword">new</span> UserServlet();</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; userServlet.setPass(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;777777&quot;</span>)).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; userServlet.setPass(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;888888&quot;</span>)).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的共享资源是什么？</p>
</blockquote>
<p>​        这里的共享资源是UserServlet对象。更具体地说，两个线程共享着UserServlet对象中的User对象。</p>
<blockquote>
<p>这里存在线程安全吗？</p>
</blockquote>
<p>​    存在！两个线程共享一个User对象。当线程对User对象进行修改时，就会出现线程安全的问题。</p>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]:王五:<span class="number">777777</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]:王五:<span class="number">888888</span></span><br></pre></td></tr></table></figure>

<p>​        结果分析：</p>
<p>​        当线程1修改User对象的name后，线程1Sleep 5s，线程二开始修改User对象，此时，线程2会将线程1之前修改name=李四 覆盖为 name=王五，接着线程2Sleep 5s，线程1醒来，修改password=777777。线程2醒来，修改password=888888</p>
<blockquote>
<p>为什么password不会被线程2覆盖为888888</p>
</blockquote>
<p>因为线程1Sleep 5s后才会将password保存到主内存区的User对象上。而不是在修改name的时候就把password一起保存到主内存区。</p>
<blockquote>
<p>如果去掉SetPass方法中的Thread,Sleep()方法，执行结果是怎样的？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]:李四:<span class="number">777777</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]:王五:<span class="number">888888</span></span><br></pre></td></tr></table></figure>

<p>如果去掉Thread,sleep方法，执行结果是正确的。事实上，正是因为线程1的Sleep方法，为了不浪费cpu，使得线程2有机会抢占执行。如果没有线程1的Sleep方法，线程2只能等线程1执行完成后才有机会执行。（不一定，看时间片分配？？？）</p>
<blockquote>
<p>​    总结</p>
</blockquote>
<p>多条线程抢占共享区域的对象，修改对象的成员变量，会引起线程安全的问题。</p>
<blockquote>
<p>执行结果错误的本质原因</p>
</blockquote>
<p>​        线程的执行不是原子性的。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的启动与终止.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<h3 id="start方法源码"><a href="#start方法源码" class="headerlink" title="start方法源码"></a>start方法源码</h3><ul>
<li>对线程状态进行检查，0代表NEW状态</li>
<li>将线程加入线程组</li>
<li>调用native方法start0()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// native方法</span></span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题1：一个线程两次调用start方法会出现什么情况？为什么？"><a href="#面试题1：一个线程两次调用start方法会出现什么情况？为什么？" class="headerlink" title="面试题1：一个线程两次调用start方法会出现什么情况？为什么？"></a>面试题1：一个线程两次调用start方法会出现什么情况？为什么？</h3><p>​    会抛出IllegalThreadStateException。因为调用start方法时会对线程状态进行检查，不是NEW状态就会抛出IllegalThreadStateException。</p>
<h3 id="面试题2：为什么选择调用start方法，而不直接调用run方法？"><a href="#面试题2：为什么选择调用start方法，而不直接调用run方法？" class="headerlink" title="面试题2：为什么选择调用start方法，而不直接调用run方法？"></a>面试题2：为什么选择调用start方法，而不直接调用run方法？</h3><p>​    调用start方法才是真正的启动线程，会有线程的生命周期。而直接调用run方法，只是调用了一个普通方法。</p>
<h3 id="如何正确停止线程：使用interrupt来通知，而不是强制"><a href="#如何正确停止线程：使用interrupt来通知，而不是强制" class="headerlink" title="如何正确停止线程：使用interrupt来通知，而不是强制"></a>如何正确停止线程：使用interrupt来通知，而不是强制</h3><p>​    只是使用interrupt来通知线程，通过设置线程中断标志来实现，线程根据这个标志来自行处理。</p>
<h3 id="interupted的三种情况"><a href="#interupted的三种情况" class="headerlink" title="interupted的三种情况"></a>interupted的三种情况</h3><ul>
<li>线程正常执行完成，调用interrpted方法</li>
<li>线程可能被阻塞</li>
<li>线程在每次迭代后都阻塞</li>
</ul>
<h4 id="栗子1：线程正常执行，需要线程自行根据中断标志来处理interrupt方法的通知"><a href="#栗子1：线程正常执行，需要线程自行根据中断标志来处理interrupt方法的通知" class="headerlink" title="栗子1：线程正常执行，需要线程自行根据中断标志来处理interrupt方法的通知"></a>栗子1：线程正常执行，需要线程自行根据中断标志来处理interrupt方法的通知</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 必须自行处理中断，只是调用interrupt方法是无效的</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + i + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 运行1s后再中断程序</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待thread1执行完才输出thread1的线程状态</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thread1 status:&quot;</span> + thread1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Thread-0139724 is running</span><br><span class="line">Thread-0139725 is running</span><br><span class="line">Thread-<span class="number">0</span> interrupted</span><br><span class="line">thread1 status:TERMINATED</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：线程处在阻塞状态时，interrupt方法结束线程，抛出异常"><a href="#栗子2：线程处在阻塞状态时，interrupt方法结束线程，抛出异常" class="headerlink" title="栗子2：线程处在阻塞状态时，interrupt方法结束线程，抛出异常"></a>栗子2：线程处在阻塞状态时，interrupt方法结束线程，抛出异常</h4><p>将以上栗子1中的Thread方法改成以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + i + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行方法：</p>
<p>thread处在sleep状态时，被中断抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-0999997 is running</span><br><span class="line">Thread-0999998 is running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcore.InterruptedDemo01.lambda$main$<span class="number">0</span>(InterruptedDemo01.java:<span class="number">24</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">thread1 status:TERMINATED</span><br></pre></td></tr></table></figure>

<h4 id="栗子3：线程在迭代中处于阻塞状态，interrupt方法结束线程，抛出异常"><a href="#栗子3：线程在迭代中处于阻塞状态，interrupt方法结束线程，抛出异常" class="headerlink" title="栗子3：线程在迭代中处于阻塞状态，interrupt方法结束线程，抛出异常"></a>栗子3：线程在迭代中处于阻塞状态，interrupt方法结束线程，抛出异常</h4><p>将栗子1中的Thread方法修改为以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + i + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程被中断后，抛出异常，catch捕获异常后，线程继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">00</span> is running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:<span class="number">48</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Thread-<span class="number">01</span> is running</span><br><span class="line">Thread-<span class="number">02</span> is running</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="栗子4：捕获异常的位置会影响执行结果"><a href="#栗子4：捕获异常的位置会影响执行结果" class="headerlink" title="栗子4：捕获异常的位置会影响执行结果"></a>栗子4：捕获异常的位置会影响执行结果</h4><p>在栗子3的基础上，将捕获异常的代码块范围增大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程接收到中断通知后，会抛出异常。处理异常后，不再执行循环了，而是执行完线程接下来的任务就结束了。<strong>异常的捕获范围影响了线程的执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">00</span> is running</span><br><span class="line">Thread-<span class="number">01</span> is running</span><br><span class="line">Thread-<span class="number">02</span> is running</span><br><span class="line">Thread-<span class="number">03</span> is running</span><br><span class="line">Thread-<span class="number">04</span> is running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:<span class="number">49</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">抛出异常后我还会继续执行</span><br><span class="line">thread1 status:TERMINATED</span><br></pre></td></tr></table></figure>

<h4 id="栗子5：在迭代中try-catcha异常会导致interrupt方法失效"><a href="#栗子5：在迭代中try-catcha异常会导致interrupt方法失效" class="headerlink" title="栗子5：在迭代中try..catcha异常会导致interrupt方法失效"></a>栗子5：在迭代中try..catcha异常会导致interrupt方法失效</h4><p>在栗子3中，我们在迭代中使用了try..catch..捕获了异常，线程继续往下执行。</p>
<p>那么，是不是加上isInterrupted方法的判断，捕获异常后，线程就不往下执行了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span> &amp;&amp; !Thread.currentThread().isInterrupted(); i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + i + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// sleep会清除中断标志，导致isInterrupted()方法无法判断</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程在捕获了异常后，还是继续往下执行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Thread-<span class="number">04</span> is running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:<span class="number">48</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Thread-<span class="number">05</span> is running</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="interrupt-与interrupted-区别"><a href="#interrupt-与interrupted-区别" class="headerlink" title="interrupt()与interrupted()区别"></a>interrupt()与interrupted()区别</h3><p><strong>interrupted方法，不管是谁调用，都只对当前线程有效</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.条件为!true=false,退出循环</span></span><br><span class="line">            <span class="comment">// isInterrupted()返回中断标志true</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.这里输出的是什么true还是false</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.开启</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.中断标记设置为true</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main is run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>t1.interrupt()设置了中断标志=true，isInterrupted()返回中断标志true，不会清除中断标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="keyword">true</span></span><br><span class="line">main is run over</span><br></pre></td></tr></table></figure>

<p>如果改成interrupted()方法呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.这里输出的是什么true还是false</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>t1.interrupt()设置了中断标志=true，Thread.interrupted()返回中断标志=true,并且清除了中断标志=false</p>
<p>下面的输出语句输出中断标志=false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="keyword">false</span></span><br><span class="line">main is run over</span><br></pre></td></tr></table></figure>

<h3 id="interrupt方法源码"><a href="#interrupt方法源码" class="headerlink" title="interrupt方法源码"></a>interrupt方法源码</h3><p>intertupt方法只是设置线程中断标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// interrupt方法只对当前线程有效，谁调用了interrupt方法，就中断谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不清楚中断标志</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除当前线程的中断标志</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native方法，参数代表是否清除中断标志</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="中断线程的两种姿势"><a href="#中断线程的两种姿势" class="headerlink" title="中断线程的两种姿势"></a>中断线程的两种姿势</h3><ul>
<li>不在线程方法内部try..catch，把异常抛出去，由调用方处理中断异常</li>
<li>在线程方法内部try..catch，并在catch后，再次中断线程，恢复中断，这样方法调用方能处理中断</li>
</ul>
<h3 id="响应线程中断的N种方法"><a href="#响应线程中断的N种方法" class="headerlink" title="响应线程中断的N种方法"></a>响应线程中断的N种方法</h3><ul>
<li>Object ：wait</li>
<li>Thread：sleep，join</li>
<li>BlockQueue：take/put</li>
<li>Lock：lockInterruptibly</li>
<li>CountDownLatch：await</li>
<li>CyclicBarrier：await</li>
<li>Exchanger：exchange</li>
<li>java.nio.channels.InterruptibleChannel相关方法</li>
<li>java.nio.channels.Selector的相关方法</li>
</ul>
<h3 id="错误的停止线程的方法"><a href="#错误的停止线程的方法" class="headerlink" title="错误的停止线程的方法"></a>错误的停止线程的方法</h3><ul>
<li>stop/suspend/resume</li>
<li>用volatile设置的boolean标记位，在阻塞的时候，线程不会响应标记位的更新</li>
</ul>
<h4 id="栗子1：生产者与消费者模式证明在阻塞的时候，使用volatile设置的标记位来停止线程是错误的"><a href="#栗子1：生产者与消费者模式证明在阻塞的时候，使用volatile设置的标记位来停止线程是错误的" class="headerlink" title="栗子1：生产者与消费者模式证明在阻塞的时候，使用volatile设置的标记位来停止线程是错误的"></a>栗子1：生产者与消费者模式证明在阻塞的时候，使用volatile设置的标记位来停止线程是错误的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object num = queue.take();</span><br><span class="line">                System.out.println(num + <span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要数据了&quot;</span>);</span><br><span class="line">        producer.cancel = <span class="keyword">true</span>; <span class="comment">// 线程被阻塞，而不会停止</span></span><br><span class="line">        <span class="comment">//    thread.interrupt(); // 正确的停止方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当消费者不需要数据的时候，生产者阻塞在put这一行代码，导致while的判断条件种cancel无法检测</span></span><br><span class="line">            <span class="keyword">while</span> (num &lt; <span class="number">10000</span> &amp;&amp; !cancel) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;被生产出来放入队列了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="操作系统、进程、线程的关系"><a href="#操作系统、进程、线程的关系" class="headerlink" title="操作系统、进程、线程的关系"></a>操作系统、进程、线程的关系</h3><p><img src="D:\ming\images\image-20200621230048073.png" alt="image-20200621230048073"></p>
<ul>
<li>操作系统将资源分配给进程，进程将资源分配给线程。但是CPU资源比较特殊，CPU资源是直接分配给线程的。</li>
<li>一个进程中至少会有一个线程，进程不能脱离进程而存在。</li>
<li>main函数启动的时候，会产生JVM进程，JVM进程会产生多条线程。main函数线程称为主线程。还有产生GC回收的守护线程。</li>
</ul>
<h3 id="JVM内存模型与线程的关系"><a href="#JVM内存模型与线程的关系" class="headerlink" title="JVM内存模型与线程的关系"></a>JVM内存模型与线程的关系</h3><p>虽然对象是存在Java堆中的，但是对象的引用存放在虚拟机栈中。</p>
<p><img src="D:\ming\images\image-20200621233341074.png" alt="image-20200621233341074"></p>
<h3 id="使用JDK工具观察线程"><a href="#使用JDK工具观察线程" class="headerlink" title="使用JDK工具观察线程"></a>使用JDK工具观察线程</h3><p>注意，如果没有将对应的命令加入到环境变量中，需要到JDK所在路径的bin目录下执行。</p>
<p>在观察的时候，可以让main线程Sleep(Integer.MAX_VALUE)，目的是为了让JVM进程不停止，这样才能观察到线程。</p>
<p>jps -lvm 可以看到系统中运行的进程。在使用jcmd的时候，需要带上进程的id。</p>
<ul>
<li>jcmd</li>
<li>jstack</li>
<li>可视化工具 jvisualvm 有动态图查看线程的运行状态</li>
<li>可视化工具 jconsole 可以查看Thread等类的属性等信息，可以单独对某个线程查看，可以检测死锁</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="D:\ming\images\image-20200715224217839.png" alt="image-20200715224217839"></p>
<h3 id="线程的性能问题"><a href="#线程的性能问题" class="headerlink" title="线程的性能问题"></a>线程的性能问题</h3><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p>
<blockquote>
<p>缓存开销:CPU重新缓存</p>
</blockquote>
<blockquote>
<p>何时会导致密集的上下文切换:频繁地竞争锁，或者由于IO读写等原因导致频繁阻塞</p>
</blockquote>
<blockquote>
<p>​    协作：内存同步</p>
</blockquote>
<p>​        为了数据的正确性，同步手段往往会使用禁止编译器优化、使CPU内的缓存失效</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CyclicBarrier.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E7%B2%BE%E9%80%9A%E7%AF%87/CyclicBarrier/</url>
    <content><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>CyclicBarrier就像起跑线，规定了有多少个跑道(等待的线程数)，必须等所有的选手到位(最后一个线程执行完)之后，才可以开始跑。</p>
<ul>
<li>CyclicBarrier初始值的设置需要与使用的数量相同，否则将会一直等待下去</li>
<li>CyclicBarrier可以设置最大等待时间，超出最大等待时间抛出TimeoutException并且先运行，运行之后会破坏Barrier，抛出BrokenBarrierException。当其他线程运行时，都会抛出BrokenBarrierException</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E7%B2%BE%E9%80%9A%E7%AF%87/Semaphore/</url>
    <content><![CDATA[<h3 id="使用信号量的注意点"><a href="#使用信号量的注意点" class="headerlink" title="使用信号量的注意点"></a>使用信号量的注意点</h3><ul>
<li>获取和释放的数量保持一致</li>
<li>注意在初始化Semaphore的时候设置公平性，一般设置为true会更合理</li>
<li>并不是必须由获取许可证的线程释放那个许可证，</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/JMM/</url>
    <content><![CDATA[<h3 id="三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型"></a>三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型</h3><h5 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h5><ul>
<li>共享区域<ul>
<li>堆区（所有线程共享）<ul>
<li>存储的全部是对象实例（通过new等指令创建的，并会被垃圾回收；数组也是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。因为在Java中，数组是对象），是内存中最大的一块。</li>
<li>堆的优势是可以在运行时动态地分配内存空间，不必事先告诉编译器。</li>
</ul>
</li>
<li>方法区（所有线程共享）<ul>
<li>它用于存储虚拟机已经加载的static静态变量、类信息、常量。</li>
<li>还存放永久引用，比如static People p = new People();的p引用。</li>
<li>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。存放final修饰的。</li>
</ul>
</li>
</ul>
</li>
<li>线程独有<ul>
<li>栈区（每个线程私有）<ul>
<li>每个线程包含一个栈区，栈中保存基础数据类型（byte，short，int，long，float，double，boolean，char）的对象、自定义对象的引用(不是对象本身)和returnAddress（指向了一条字节码指令的地址）。</li>
<li>每个方法从被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。每个栈中的数据(基本类型的局部变量、参数、对象引用)都是私有的，其他栈不能访问。</li>
<li>在编译期间就确定了大小，运行期间不会改变大小。</li>
</ul>
</li>
<li>本地方法栈（每个线程私有）<ul>
<li>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</li>
</ul>
</li>
<li>程序计数器（每个线程私有）<ul>
<li>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h5><ul>
<li>Java对象自身的存储模型。</li>
<li>每个对象的实例保存在堆中，对象的引用保存在栈中。</li>
<li>每个对象包括对象头和实例数据</li>
</ul>
<h3 id="JMM是什么"><a href="#JMM是什么" class="headerlink" title="JMM是什么"></a>JMM是什么</h3><blockquote>
<p> 为什么需要JMM? </p>
</blockquote>
<p>​    JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别，无法保证并发安全的效果一致</p>
<ul>
<li>是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。</li>
<li>如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/ThreadLocal/</url>
    <content><![CDATA[<h3 id="1-两大使用场景"><a href="#1-两大使用场景" class="headerlink" title="1. 两大使用场景"></a>1. 两大使用场景</h3><ul>
<li>每个线程需要一个自己独享的对象（通常是工具类，例如SimpleDateFormat和Random）<ul>
<li>使用时重写ThreadLocal的initValue方法</li>
<li>需要保存到ThreadLocal里的对象的生成由我们控制</li>
</ul>
</li>
<li>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦<ul>
<li>使用时手动调用ThreadLocal的set方法</li>
<li>需要保存到ThreadLocal里的对象的生成时机不由我们随意控制</li>
</ul>
</li>
</ul>
<h3 id="2-ThreadLocal的作用"><a href="#2-ThreadLocal的作用" class="headerlink" title="2.ThreadLocal的作用"></a>2.ThreadLocal的作用</h3><ul>
<li>让某个需要用到的对象在线程间隔离</li>
<li>在任何方法中都能获取到需要的对象</li>
</ul>
<h3 id="3-使用ThreadLocal的好处"><a href="#3-使用ThreadLocal的好处" class="headerlink" title="3.使用ThreadLocal的好处"></a>3.使用ThreadLocal的好处</h3><ul>
<li>达到线程安全</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效地利用内存，节省开销</li>
<li>避免繁琐的传参</li>
</ul>
<h4 id="栗子1-每个线程都需要一个独享的ThreadLocal对象"><a href="#栗子1-每个线程都需要一个独享的ThreadLocal对象" class="headerlink" title="栗子1.每个线程都需要一个独享的ThreadLocal对象"></a>栗子1.每个线程都需要一个独享的ThreadLocal对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/25 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 每个线程都需要一个SimpleDateFormat对象，使用ThreadLocal来达到线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalNormalUseage01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                String date = date(finalI);</span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">date</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-ThreadLocal的原理"><a href="#4-ThreadLocal的原理" class="headerlink" title="4.ThreadLocal的原理"></a>4.ThreadLocal的原理</h3><ul>
<li>initialValue()<ul>
<li>该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get()方法的时候，才会触发</li>
<li>当线程第一个使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法</li>
<li>每个线程最多调用一次initialValue方法，但如果已经调用了remove后，再调用get，则可以再次调用此方法</li>
<li>如果不重写本方法，这个方法会返回null</li>
</ul>
</li>
</ul>
<p> 使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每 一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本 </p>
<h4 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;Integer&gt; th = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                th.set(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 set th=&quot;</span> + th.get()); <span class="comment">// 100</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 get th=&quot;</span> + th.get()); <span class="comment">// 100</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Integer ele = th.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 get th=&quot;</span> + ele); <span class="comment">// null</span></span><br><span class="line">            th.set(<span class="number">200</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 get th=&quot;</span> + th.get()); <span class="comment">// 200</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程t1先执行，设置th=100,sleep 2s，线程t2执行，先获取th的值=null，而不是线程t1设置的100。</p>
<p>线程t2设置th=200，线程t1sleep2s后获取th的值=100，而不是线程2设置的200。</p>
<p>每个线程的th变量是独立的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1 set th=<span class="number">100</span></span><br><span class="line">t2 get th=<span class="keyword">null</span></span><br><span class="line">t2 get th=<span class="number">200</span></span><br><span class="line">t1 get th=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal与InheritableThreadLocal"><a href="#ThreadLocal与InheritableThreadLocal" class="headerlink" title="ThreadLocal与InheritableThreadLocal"></a>ThreadLocal与InheritableThreadLocal</h3><ul>
<li> Thread类中的threadLocals、inheritableThreadLocals成员变量为ThreadLocal.ThreadLocalMap对象 </li>
<li> Map的key值是ThreadLocal对象本身，value是Object类型 </li>
<li> ThreadLocal无法解决继承问题，而InheritableThreadLocal可以 </li>
<li> InheritableThreadLocal继承自ThreadLocal </li>
<li> InheritableThreadLocal可以帮助我们做链路追踪</li>
</ul>
<h4 id="栗子1：ThreadLocal只能获取当前线程设置的值"><a href="#栗子1：ThreadLocal只能获取当前线程设置的值" class="headerlink" title="栗子1：ThreadLocal只能获取当前线程设置的值"></a>栗子1：ThreadLocal只能获取当前线程设置的值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo0</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        tl.set(<span class="string">&quot;Kevin是一个自由讲师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 子线程无法获取父线程ThreadLocal的值,因为他们是两个独立的用户线程，都使用各自的副本</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程可以获取到</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main get tl is : Kevin是一个自由讲师</span><br><span class="line">Thread-<span class="number">0</span> get tl is : <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h4 id="栗子2：InhertiableThreadLocal可以在父子线程中复制传递值"><a href="#栗子2：InhertiableThreadLocal可以在父子线程中复制传递值" class="headerlink" title="栗子2：InhertiableThreadLocal可以在父子线程中复制传递值"></a>栗子2：InhertiableThreadLocal可以在父子线程中复制传递值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个线程之间读取副本, 父子线程之间复制传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        tl.set(<span class="string">&quot;Kevin是一个自由讲师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// t0线程先启动，可以获取main线程中设置的值，读取了main线程中的副本</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">            <span class="comment">// t0线程修改值，并不影响其他线程</span></span><br><span class="line">            tl.set(<span class="string">&quot;After Set The Value Change to &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">            tl.set(<span class="string">&quot;After Set The Value Change to &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get tl is : &quot;</span> + tl.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> get tl is : Kevin是一个自由讲师</span><br><span class="line">Thread-<span class="number">0</span> get tl is : After Set The Value Change to Thread-<span class="number">0</span></span><br><span class="line">main get tl is : Kevin是一个自由讲师</span><br><span class="line">Thread-<span class="number">1</span> get tl is : Kevin是一个自由讲师</span><br><span class="line">Thread-<span class="number">1</span> get tl is : After Set The Value Change to Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="6-内存泄露"><a href="#6-内存泄露" class="headerlink" title="6.内存泄露"></a>6.内存泄露</h3><p>内存泄露：某个对象不再有用，但是占用的内存不能被GC回收。</p>
<p>弱引用：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收。ThredLocalMap的key就是一个弱引用</p>
<ul>
<li>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用</li>
<li>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了</li>
<li>但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收</li>
<li>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM</li>
<li>JDK在set，remove，rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收</li>
</ul>
<p>如何避免内存泄露：使用完ThreadLocal之后，应该调用remove方法，就会删除对应的Entry对象，可以避免内存泄露</p>
<h3 id="7-空指针异常"><a href="#7-空指针异常" class="headerlink" title="7.空指针异常"></a>7.空指针异常</h3><p>如果ThreadLocal没有设置初始值，就调用get方法，会返回null。这本身没有问题，但如果遇到拆箱的操作，就会引发NPE。原因在于拆箱调用的是对象的.valueOf方法。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsafe.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/unSafe/</url>
    <content><![CDATA[<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><ul>
<li>AtomicXX类大量采用Unsafe类完成底层操作</li>
<li>位于JDK的rt.jar包中，由BootstrapClassLoader加载的核心类</li>
<li>Unsafe类中的方法几乎都为native方法</li>
<li>单例模式</li>
</ul>
<h4 id="栗子1：直接通过内存地址为对象的属性赋值"><a href="#栗子1：直接通过内存地址为对象的属性赋值" class="headerlink" title="栗子1：直接通过内存地址为对象的属性赋值"></a>栗子1：直接通过内存地址为对象的属性赋值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeDemo0</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeDemo0 demo0 = <span class="keyword">new</span> UnsafeDemo0();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Unsafe类实例,单例模式</span></span><br><span class="line">        Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取age属性的内存偏移地址，需要通过反射</span></span><br><span class="line">            <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(UnsafeDemo0.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">            <span class="comment">//设置age的值为11</span></span><br><span class="line">            unsafe.putInt(demo0, ageOffset, <span class="number">11</span>);</span><br><span class="line">            <span class="comment">//输出结果</span></span><br><span class="line">            System.out.println(demo0.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>执行结果抛出异常，只有BootstrapClassLoader加载的类才能调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Unsafe</span><br><span class="line">	at sun.misc.Unsafe.getUnsafe(Unsafe.java:<span class="number">90</span>)</span><br><span class="line">	at thread06.UnsafeDemo0.main(UnsafeDemo0.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：-通过反射模式可以突破Unsafe类的安全限制"><a href="#栗子2：-通过反射模式可以突破Unsafe类的安全限制" class="headerlink" title="栗子2： 通过反射模式可以突破Unsafe类的安全限制"></a>栗子2： 通过反射模式可以突破Unsafe类的安全限制</h4>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/volatile/</url>
    <content><![CDATA[<h3 id="volatile保证可见性，不保证原子性"><a href="#volatile保证可见性，不保证原子性" class="headerlink" title="volatile保证可见性，不保证原子性"></a>volatile保证可见性，不保证原子性</h3><ul>
<li>volatile强制线程到共享内存中读取数据，而不从线程工作内存中读取，从而使变量在多个线程中可见</li>
<li>volatile无法保证原子性，volatile属于轻量级的同步，性能比synchronized强很多(不加锁)，但是只 保证线程见的可见性，并不能替代synchronized的同步功能，netty框架中大量使用了volatile </li>
</ul>
<h4 id="栗子1：volatile不能保证原子性"><a href="#栗子1：volatile不能保证原子性" class="headerlink" title="栗子1：volatile不能保证原子性"></a>栗子1：volatile不能保证原子性</h4><p>sum属性加了volatile关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo14</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Integer sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始sum=&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;计算后sum=&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果volatile具有原子性,那么10个线程并发调用，最终结果应该为100000</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> ThreadDemo14());</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;sum最终=&quot;</span> + sum);</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">100000</span>) &#123;</span><br><span class="line">                    System.out.println(sum + <span class="string">&quot;=ok&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(sum + <span class="string">&quot;=no&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>多次运行可能结果都不一样。因为volatile不能保证原子性，可能线程A把sum改变了，还没来得及设置回主内存，又被其他线程给读取了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>计算后sum=<span class="number">4486</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>计算后sum=<span class="number">6411</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>初始sum=<span class="number">7627</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>计算后sum=<span class="number">9046</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>初始sum=<span class="number">14162</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>初始sum=<span class="number">17079</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>计算后sum=<span class="number">19511</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>初始sum=<span class="number">21795</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>计算后sum=<span class="number">24844</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>计算后sum=<span class="number">26518</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>初始sum=<span class="number">28104</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>初始sum=<span class="number">29595</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>计算后sum=<span class="number">33121</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>计算后sum=<span class="number">33111</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>计算后sum=<span class="number">41465</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>计算后sum=<span class="number">42512</span></span><br><span class="line">sum最终=<span class="number">42512</span></span><br><span class="line"><span class="number">42512</span>=no</span><br></pre></td></tr></table></figure>

<h3 id="volatile与static区别"><a href="#volatile与static区别" class="headerlink" title="volatile与static区别"></a>volatile与static区别</h3><ul>
<li>static保证唯一性，不保证一致性，多个实例共享一个静态变量</li>
<li>volatile保证一致性，不保证唯一性，多个实例有多个volatile变量</li>
</ul>
<h3 id="Atomic类的原子性"><a href="#Atomic类的原子性" class="headerlink" title="Atomic类的原子性"></a>Atomic类的原子性</h3><p>==<strong>Actomic类采用了CAS这种非锁机制</strong>==</p>
<h4 id="栗子1：使用AtomicInteger等原子类可以保证共享变量的原子性"><a href="#栗子1：使用AtomicInteger等原子类可以保证共享变量的原子性" class="headerlink" title="栗子1：使用AtomicInteger等原子类可以保证共享变量的原子性"></a>栗子1：使用AtomicInteger等原子类可以保证共享变量的原子性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo14</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger sum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始sum=&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum.addAndGet(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;计算后sum=&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果volatile具有原子性,那么10个线程并发调用，最终结果应该为100000</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> ThreadDemo14());</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;sum最终=&quot;</span> + sum);</span><br><span class="line">                <span class="keyword">if</span> (sum.get() == <span class="number">100000</span>) &#123;</span><br><span class="line">                    System.out.println(sum + <span class="string">&quot;=ok&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(sum + <span class="string">&quot;=no&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>不管运行多少次，结果都是正确的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>初始sum=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>初始sum=<span class="number">14727</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>初始sum=<span class="number">19921</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>计算后sum=<span class="number">26493</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>初始sum=<span class="number">32980</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>计算后sum=<span class="number">35974</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>计算后sum=<span class="number">41300</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>初始sum=<span class="number">54770</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>计算后sum=<span class="number">56532</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>计算后sum=<span class="number">59183</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>初始sum=<span class="number">60117</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>初始sum=<span class="number">61625</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>计算后sum=<span class="number">68908</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>初始sum=<span class="number">79628</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>计算后sum=<span class="number">82182</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>计算后sum=<span class="number">92269</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>计算后sum=<span class="number">95401</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>计算后sum=<span class="number">100000</span></span><br><span class="line">sum最终=<span class="number">100000</span></span><br><span class="line"><span class="number">100000</span>=ok</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：-Atomic类不能保证成员方法的原子性"><a href="#栗子2：-Atomic类不能保证成员方法的原子性" class="headerlink" title="栗子2： Atomic类不能保证成员方法的原子性"></a>栗子2： Atomic类不能保证成员方法的原子性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo15</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果add方法是原子性的,那么每次的结果都是10的整数倍</span></span><br><span class="line">    <span class="comment">// synchronized加锁可以保证原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum.addAndGet(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sum.addAndGet(<span class="number">9</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//10个线程调用，每个线程得到10的倍数， 最终结果应该为100，才是正确的</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> ThreadDemo15());</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">82</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">73</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>

<p>使用synchronized可以保证方法的原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum.addAndGet(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    sum.addAndGet(<span class="number">9</span>);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="CAS（Compare-and-swap）"><a href="#CAS（Compare-and-swap）" class="headerlink" title="CAS（Compare and swap）"></a>CAS（Compare and swap）</h3><ul>
<li> JDK提供的非阻塞原子操作，通过硬件保证了比较、更新操作的原子性 </li>
<li>JDK的Unsafe类提供了一系列的compareAndSwap*方法来支持CAS操作</li>
</ul>
<h4 id="解决ABA问题："><a href="#解决ABA问题：" class="headerlink" title="解决ABA问题："></a>解决ABA问题：</h4><ul>
<li>给变量分配时间戳、版本来解决ABA问题</li>
<li>JDK中使用java.util.concurrent.atomic.AtomicStampedReference类给每个变量的状态都分配一个时间 戳，避免ABA问题产生。</li>
</ul>
<h4 id="栗子1：ABA问题"><a href="#栗子1：ABA问题" class="headerlink" title="栗子1：ABA问题"></a>栗子1：ABA问题</h4><p><img src="D:\ming\images\image-20200626214300170.png" alt="image-20200626214300170"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasDemo0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomic = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">boolean</span> sucess = atomic.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomic.getStamp(), atomic.getStamp() + <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; set 100&gt;101 : &quot;</span> + sucess);</span><br><span class="line">                sucess = atomic.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomic.getStamp(), atomic.getStamp() + <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; set 101&gt;100 : &quot;</span> + sucess);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> stamp = atomic.getStamp();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 修改之前 : &quot;</span> + stamp);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">int</span> stamp1 = atomic.getStamp();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 等待两秒之后,版本被t0线程修改为 : &quot;</span> + stamp1);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下两次修改都不会成功,因为版本不符,虽然期待值是相同的,因此解决了ABA问题</span></span><br><span class="line">                <span class="keyword">boolean</span> success = atomic.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; set 100&gt;101 使用错误的时间戳: &quot;</span> + success);</span><br><span class="line">                success = atomic.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; set 101&gt;100 使用错误的时间戳: &quot;</span> + success);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下修改是成功的,因为使用了正确的版本号,正确的期待值</span></span><br><span class="line">                success = atomic.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp1, stamp1 + <span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; set 100&gt;101 使用正确的时间戳: &quot;</span> + success);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t0.join();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">1</span> 修改之前 : <span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> set <span class="number">100</span>&gt;<span class="number">101</span> : <span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span> set <span class="number">101</span>&gt;<span class="number">100</span> : <span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">1</span> 等待两秒之后,版本被t0线程修改为 : <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> set <span class="number">100</span>&gt;<span class="number">101</span> 使用错误的时间戳: <span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span> set <span class="number">101</span>&gt;<span class="number">100</span> 使用错误的时间戳: <span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span> set <span class="number">100</span>&gt;<span class="number">101</span> 使用正确的时间戳: <span class="keyword">true</span></span><br><span class="line">main is over</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-饿汉式-gt-静态常量-可用"><a href="#1-饿汉式-gt-静态常量-可用" class="headerlink" title="1.饿汉式-&gt;静态常量[可用]"></a>1.饿汉式-&gt;静态常量[可用]</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载的时候初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-饿汉式-gt-静态代码块-可用"><a href="#2-饿汉式-gt-静态代码块-可用" class="headerlink" title="2.饿汉式-&gt;静态代码块[可用]"></a>2.饿汉式-&gt;静态代码块[可用]</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态代码块中初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式-gt-线程不安全"><a href="#3-懒汉式-gt-线程不安全" class="headerlink" title="3.懒汉式-&gt;线程不安全"></a>3.懒汉式-&gt;线程不安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 懒汉式,在实例不为空时,直接返回实例对象,为空时,创建一个实例返回</span></span><br><span class="line">    <span class="comment">// 如果多个线程同时进入if语句，会导致线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-懒汉式-gt-线程安全"><a href="#4-懒汉式-gt-线程安全" class="headerlink" title="4.懒汉式-&gt;线程安全"></a>4.懒汉式-&gt;线程安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁保证线程安全，效率低下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-懒汉式-gt-线程不安全"><a href="#5-懒汉式-gt-线程不安全" class="headerlink" title="5.懒汉式-&gt;线程不安全"></a>5.懒汉式-&gt;线程不安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目的是为了降低锁的粒度，提高性能，但没达到线程安全</span></span><br><span class="line">    <span class="comment">// 如果第一个线程创建了对象，释放锁，第二个线程进来，又创建了一个新的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-双重检查-推荐使用"><a href="#6-双重检查-推荐使用" class="headerlink" title="6.双重检查[推荐使用]"></a>6.双重检查[推荐使用]</h3><p>优点：线程安全，效率较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile保证可见性和禁止重排序，对象的创建过程不是原子性的，会有重排序的可能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton6 instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-静态内部类-推荐用"><a href="#7-静态内部类-推荐用" class="headerlink" title="7.静态内部类[推荐用]"></a>7.静态内部类[推荐用]</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton7</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">Singleton7Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton7 instance = <span class="keyword">new</span> Singleton7();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回静态内部类创建的实例，由JVM保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton7Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton8</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只是为了示范调用INSTANCE的方法，实际上一行代码就完成了INSTANCE的单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatever</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="各种写法的适用场合"><a href="#各种写法的适用场合" class="headerlink" title="各种写法的适用场合"></a>各种写法的适用场合</h3><ul>
<li>最好的方法是利用枚举，因为还可以防止反序列化重新创建新的对象</li>
<li>非线程安全的方法不能使用</li>
<li>如果程序一开始要加载的资源太多，那么就应该使用懒加载</li>
<li>饿汉式如果是对象的创建需要配置文件就不适用</li>
<li>懒加载虽然好，但是静态内部类这种方式会增加编程的复杂性</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原子性.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    <content><![CDATA[<h3 id="Java中的原子性操作有哪些"><a href="#Java中的原子性操作有哪些" class="headerlink" title="Java中的原子性操作有哪些"></a>Java中的原子性操作有哪些</h3><ul>
<li>除了long和double之外的基本类型的赋值操作</li>
<li>所有引用类型的赋值操作，不管是32位机器还是64位机器</li>
<li>Atomic包中所有类的原子操作</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>可见性.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    <content><![CDATA[<h3 id="为什么会有可见性问题"><a href="#为什么会有可见性问题" class="headerlink" title="为什么会有可见性问题"></a>为什么会有可见性问题</h3><ul>
<li>高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层</li>
<li>线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。如果所有个核心都只用一个缓存，那么也就不存在内存可见性问题了。</li>
<li>每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。</li>
</ul>
<h3 id="什么是主内存和本地内存"><a href="#什么是主内存和本地内存" class="headerlink" title="什么是主内存和本地内存"></a>什么是主内存和本地内存</h3><p>Java 作为高级语言，屏蔽了CPU cache等底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。</p>
<h3 id="主内存和本地内存的关系"><a href="#主内存和本地内存的关系" class="headerlink" title="主内存和本地内存的关系"></a>主内存和本地内存的关系</h3><ul>
<li>所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝</li>
<li>线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中</li>
<li>主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成</li>
<li>所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。</li>
</ul>
<h3 id="什么是happen-before原则"><a href="#什么是happen-before原则" class="headerlink" title="什么是happen-before原则"></a>什么是happen-before原则</h3><ul>
<li>解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before。</li>
<li>如果两个操作不具备happens-before，那么JVM是可以根据需要自由排序的，但是如果具备happens-before（比如新建线程时，run方法里面的语句一定发生在thread.start()之前），那么JVM也不能改变它们之间的顺序。</li>
</ul>
<h3 id="Happens-Before规则有哪些？"><a href="#Happens-Before规则有哪些？" class="headerlink" title="Happens-Before规则有哪些？"></a>Happens-Before规则有哪些？</h3><p><img src="D:\ming\images\image-20200723225040510.png" alt="image-20200723225040510"></p>
<h3 id="volatile是什么"><a href="#volatile是什么" class="headerlink" title="volatile是什么"></a>volatile是什么</h3><ul>
<li>volatile是一种同步机制，比synchronized或者lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为</li>
<li>如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改</li>
<li>开销小，相应的能力也小，虽然是volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用</li>
</ul>
<h3 id="volatile的适用场合"><a href="#volatile的适用场合" class="headerlink" title="volatile的适用场合"></a>volatile的适用场合</h3><ul>
<li>boolean flag，如果一个共享变量自始至终只<strong>被各个线程赋值</strong>（不依赖于之前的状态），而没有其他的操作，那么就可以用volatile来代替synchronized或者代替其他原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全</li>
<li>作为刷新之前变量的触发器</li>
</ul>
<h3 id="volatile的两点作用"><a href="#volatile的两点作用" class="headerlink" title="volatile的两点作用"></a>volatile的两点作用</h3><ul>
<li>可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存</li>
<li>禁止指令重排序优化：解决单例双重锁乱序问题</li>
</ul>
<h3 id="volatile总结"><a href="#volatile总结" class="headerlink" title="volatile总结"></a>volatile总结</h3><ul>
<li>适用场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag。或者作为触发器，实现轻量级同步。</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互坼性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样编译器就不会对这个属性做指令重排序。</li>
<li>volatile可以使得long和double的赋值是原子的</li>
</ul>
<h3 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a>synchronized保证可见性</h3><ul>
<li>synchronized既保证了原子性，又保证了可见性</li>
<li>synchronized不仅让被保护的代码安全，还近朱者赤</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>锁的分类.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E9%94%81/</url>
    <content><![CDATA[<h3 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1.锁的分类"></a>1.锁的分类</h3><p><img src="D:\ming\images\2020011811250759.png" alt="img"></p>
<h3 id="2-悲观锁和乐观锁"><a href="#2-悲观锁和乐观锁" class="headerlink" title="2.悲观锁和乐观锁"></a>2.悲观锁和乐观锁</h3><ul>
<li>悲观锁（互斥同步锁）<ul>
<li>典型例子：Synchronized、lock</li>
</ul>
</li>
<li>乐观锁（非互斥同步锁）<ul>
<li>典型例子：原子类、并发容器</li>
<li>使用CAS算法实现</li>
</ul>
</li>
</ul>
<h3 id="3-悲观锁和乐观锁的开销对比"><a href="#3-悲观锁和乐观锁的开销对比" class="headerlink" title="3.悲观锁和乐观锁的开销对比"></a>3.悲观锁和乐观锁的开销对比</h3><ul>
<li>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越长，也不会对互斥锁的开销造成影响</li>
<li>乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4.使用场景"></a>4.使用场景</h3><ul>
<li>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗<ul>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
<li>乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提升</li>
</ul>
<h3 id="5-可重入锁"><a href="#5-可重入锁" class="headerlink" title="5.可重入锁"></a>5.可重入锁</h3><ul>
<li>典型例子：Synchronized、ReentranceLock</li>
<li>getHoldCount() 获取可重入的次数</li>
</ul>
<h3 id="6-读锁插队策略和升降级"><a href="#6-读锁插队策略和升降级" class="headerlink" title="6.读锁插队策略和升降级"></a>6.读锁插队策略和升降级</h3><ul>
<li>公平锁<ul>
<li>不允许插队</li>
</ul>
</li>
<li>非公平锁<ul>
<li>写锁可以随时插队</li>
<li>读锁仅在等待队列头节点不是想获取写锁线程的时候可以插队，否则可能会造成饥饿现象</li>
</ul>
</li>
</ul>
<p>升降级策略：只能降级，不能升级</p>
<h4 id="栗子1：读锁插队"><a href="#栗子1：读锁插队" class="headerlink" title="栗子1：读锁插队"></a>栗子1：读锁插队</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/07/26 19:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 演示当队列中第一个不是写锁的时候，读锁是可以插队的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentranceReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非公平锁才能有插队</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获取读锁&quot;</span>);</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了读锁&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获取写锁&quot;</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了写锁&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">40</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentranceReadWriteLockTest reentranceReadWriteLockTest = <span class="keyword">new</span> ReentranceReadWriteLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; reentranceReadWriteLockTest.write(), <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; reentranceReadWriteLockTest.read(), <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; reentranceReadWriteLockTest.read(), <span class="string">&quot;thread-3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; reentranceReadWriteLockTest.write(), <span class="string">&quot;thread-4&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                threads[i] = <span class="keyword">new</span> Thread(() -&gt; reentranceReadWriteLockTest.read(), <span class="string">&quot;子线程创建的Thread&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                threads[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-读写锁的适用场景"><a href="#7-读写锁的适用场景" class="headerlink" title="7.读写锁的适用场景"></a>7.读写锁的适用场景</h3><p>ReentranceReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率。</p>
<h3 id="8-自旋锁"><a href="#8-自旋锁" class="headerlink" title="8.自旋锁"></a>8.自旋锁</h3><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码快中的内容过于简单，状态转换消耗的时间很可能比用户代码执行的时间还要长</li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失</li>
<li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理资源</li>
<li>atomic包下的类基本都是自旋锁的实现</li>
<li>自旋锁实现原理是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作</li>
</ul>
<h3 id="9-自旋锁的适用场景"><a href="#9-自旋锁的适用场景" class="headerlink" title="9.自旋锁的适用场景"></a>9.自旋锁的适用场景</h3><ul>
<li>自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高</li>
<li>适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），那也是不适合的</li>
</ul>
<h3 id="10-锁优化"><a href="#10-锁优化" class="headerlink" title="10.锁优化"></a>10.锁优化</h3><ul>
<li>缩小同步代码块</li>
<li>尽量不要锁住方法</li>
<li>减少请求锁的次数</li>
<li>锁中尽量不要再包含锁</li>
<li>选择合适的锁类型或合适的工具类</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>并发队列.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="并发-无阻塞队列"><a href="#并发-无阻塞队列" class="headerlink" title="并发-无阻塞队列"></a>并发-无阻塞队列</h3><p>ConcurrentLinkedQueue并发无阻塞队列，BlockingQueue并发阻塞队列。</p>
<p>ConcurrentLinkedQueue实现Queue接口，BlockingQueue本身是一个接口，继承Queue接口。</p>
<blockquote>
<p>ConcurrentLinkedQueue</p>
</blockquote>
<ul>
<li><ul>
<li>无阻赛、无锁、高性能、无界队列(直至内存耗尽)、线程安全，性能优于BlockingQueue、不允许null值</li>
<li>使用CAS算法进行入队和出队操作</li>
</ul>
</li>
</ul>
<h4 id="栗子1：ConcurrentLinkedQueue基本操作"><a href="#栗子1：ConcurrentLinkedQueue基本操作" class="headerlink" title="栗子1：ConcurrentLinkedQueue基本操作"></a>栗子1：ConcurrentLinkedQueue基本操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThread29</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConcurrentLinkedQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// add方法实际调用了offer方法</span></span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// offer方法与add没有区别</span></span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line">        queue.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不允许添加null元素</span></span><br><span class="line"><span class="comment">//        queue.add(null);</span></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(<span class="string">&quot;[1]peek=&quot;</span> + queue.peek()); <span class="comment">//读取头元素,但是不移除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[2]size=&quot;</span> + queue.size()); <span class="comment">//peek方法不会导致size改变</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[3]poll=&quot;</span> + queue.poll()); <span class="comment">//读取头元素，并且移除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[4]size=&quot;</span> + queue.size()); <span class="comment">//poll方法导致size改变</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[5]poll=&quot;</span> + queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;[6]poll=&quot;</span> + queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;[7]poll=&quot;</span> + queue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;[8]size=&quot;</span> + queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;peek=&quot;</span> + queue.peek()); <span class="comment">//队列为空, 读取头元素，返回null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pool=&quot;</span> + queue.poll()); <span class="comment">//队列为空, 读取头元素并移除, 返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>]peek=<span class="number">1</span></span><br><span class="line">[<span class="number">2</span>]size=<span class="number">4</span></span><br><span class="line">[<span class="number">3</span>]poll=<span class="number">1</span></span><br><span class="line">[<span class="number">4</span>]size=<span class="number">3</span></span><br><span class="line">[<span class="number">5</span>]poll=<span class="number">2</span></span><br><span class="line">[<span class="number">6</span>]poll=<span class="number">3</span></span><br><span class="line">[<span class="number">7</span>]poll=<span class="number">4</span></span><br><span class="line">[<span class="number">8</span>]size=<span class="number">0</span></span><br><span class="line">peek=<span class="keyword">null</span></span><br><span class="line">pool=<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul>
<li><p>不允许添加null元素，三种添加方法都不允许添加null元素</p>
</li>
<li><p>添加方法</p>
<ul>
<li><p>add：如果队列满了，抛出异常</p>
<ul>
<li>```java<br>java.lang.IllegalStateException: Queue full<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* offer：如果队列满了，不阻塞，不抛出异常。可以设置最大阻塞时间。</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    // 可设置最大阻塞时间,5秒,如果队列还是满的,则不阻塞，不抛出异常</span><br><span class="line">    queue.offer(6, 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>put：如果队列满了，永远阻塞，不抛出异常</p>
</li>
</ul>
</li>
<li><p>获取方法</p>
<ul>
<li><p>peek：读取头元素不移除。如果队列为空,返回null,不阻塞, 不抛异常</p>
</li>
<li><p>poll：读取头元素，并移除。如果队列为空,返回null,不阻塞, 不抛异常。可以设置最大最大阻塞时间</p>
<ul>
<li>```java<br>// 可指定阻塞时间,2秒,如果队列依然为空,则返回null,不抛异常<br>queue.poll(2, TimeUnit.SECONDS)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * take：读取头元素，并移除。如果队列为空,则永远阻塞,不抛出异常</span><br><span class="line"></span><br><span class="line">* 转换方法</span><br><span class="line"></span><br><span class="line">  * drainTo：取出queue中指定个数的元素放入集合中,并移除。如果队列为空时，不阻塞，不抛出异常</span><br><span class="line"></span><br><span class="line">    * ```java</span><br><span class="line">      queue.drainTo(list, 2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="栗子1：drainTo转换为List"><a href="#栗子1：drainTo转换为List" class="headerlink" title="栗子1：drainTo转换为List"></a>栗子1：drainTo转换为List</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTake2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        queue.drainTo(list, <span class="number">2</span>); <span class="comment">// 取出queue中指定个数的元素放入list中,并移除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list&gt;&gt;&quot;</span> + list);</span><br><span class="line">        System.out.println(<span class="string">&quot;queue&gt;&gt;&quot;</span> + queue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">queue&gt;&gt;[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：空队列drainTo转换"><a href="#栗子2：空队列drainTo转换" class="headerlink" title="栗子2：空队列drainTo转换"></a>栗子2：空队列drainTo转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTake3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line">    queue.add(<span class="number">2</span>);</span><br><span class="line">    queue.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    queue.drainTo(list); <span class="comment">// 取出queue中的全部元素放入list中,并移除</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1&gt;&gt;&quot;</span> + list);</span><br><span class="line">    System.out.println(<span class="string">&quot;2&gt;&gt;&quot;</span> + queue);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    queue.drainTo(list1); <span class="comment">// 当队列为空时不抛出异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3&gt;&gt;&quot;</span> + list1);</span><br><span class="line">    System.out.println(<span class="string">&quot;4&gt;&gt;&quot;</span> + queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">2</span>&gt;&gt;[]</span><br><span class="line"><span class="number">3</span>&gt;&gt;[]</span><br><span class="line"><span class="number">4</span>&gt;&gt;[]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6%E7%AF%87/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="1-为什么要使用线程池"><a href="#1-为什么要使用线程池" class="headerlink" title="1.为什么要使用线程池"></a>1.为什么要使用线程池</h3><ul>
<li>反复创建线程开销大</li>
<li>过多的线程会占用太多内存</li>
</ul>
<h3 id="2-线程池的好处"><a href="#2-线程池的好处" class="headerlink" title="2.线程池的好处"></a>2.线程池的好处</h3><ul>
<li>加快响应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h3 id="3-线程池适用场景"><a href="#3-线程池适用场景" class="headerlink" title="3.线程池适用场景"></a>3.线程池适用场景</h3><ul>
<li>服务器接收到大量的请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>
<li>在开发中，如果需要创建5个以上的线程，就可以使用线程池来处理</li>
</ul>
<h3 id="4-线程池的参数"><a href="#4-线程池的参数" class="headerlink" title="4.线程池的参数"></a>4.线程池的参数</h3><ul>
<li>corePoolSize<ul>
<li>核心线程数，线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时再创建新线程去执行任务</li>
</ul>
</li>
<li>maxPoolSize<ul>
<li>最大线程数，线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限</li>
</ul>
</li>
<li>keepAliveTime<ul>
<li>如果线程池当前的线程数多于corePoolSize,那么如果多余的线程空闲时间超过keepAliveTime,它们就会被终止</li>
</ul>
</li>
<li>ThreadFactory<ul>
<li>新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建处理的线程都在同一个线程组，拥有统一的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等</li>
<li>通常我们用默认的ThreadFactory就可以了</li>
</ul>
</li>
<li>workQueue<ul>
<li>直接交换：SynchronousQueue</li>
<li>无界队列：LinkedBlockingQueue</li>
<li>有界队列：ArrayBlockingQueue</li>
</ul>
</li>
</ul>
<h3 id="5-添加线程规则"><a href="#5-添加线程规则" class="headerlink" title="5.添加线程规则"></a>5.添加线程规则</h3><ul>
<li>如果线程数小于corePoolSize,即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务</li>
<li>如果线程数等于（或大于）corePoolSize但少于maxPoolSize,则将任务放入队列</li>
<li>如果队列已满，并且线程数小于maxPoolSize,则创建一个新线程来运行任务</li>
<li>如果队列已满，并且线程数大于maxPoolSize,则拒绝该线程</li>
</ul>
<h3 id="6-增减线程的特点"><a href="#6-增减线程的特点" class="headerlink" title="6.增减线程的特点"></a>6.增减线程的特点</h3><ul>
<li>如果设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程数</li>
<li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它</li>
<li>通过设置maxPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li>
<li>如果使用的是无界队列（例如LinkedBolckingQueue），那么线程数就不会超过corePoolSize</li>
</ul>
<h3 id="7-自带线程池介绍"><a href="#7-自带线程池介绍" class="headerlink" title="7. 自带线程池介绍"></a>7. 自带线程池介绍</h3><ul>
<li>newFixedThreadPool<ul>
<li>由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，会容易造成占用大量的内存，可能会导致OOM</li>
</ul>
</li>
<li>newSingleThreadPool<ul>
<li>和FixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，可能会占用大量的内存</li>
</ul>
</li>
<li>newCacheThreadPool<ul>
<li>无界队列，可以自动回收多余的线程</li>
<li>maxPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
</li>
<li>newScheduledThreadPool<ul>
<li>支持定时以及周期性任务执行</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>newFixedThreadPool</th>
<th>newSingleThreadPool</th>
<th>newCacheThreadPool</th>
<th>newScheduledThreadPool</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>构造函数传参</td>
<td>1</td>
<td>0</td>
<td>构造方法传参</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>构造函数传参</td>
<td>1</td>
<td>Integer.MAX_VALUE</td>
<td>Integer.MAX_VALUE</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>0</td>
<td>0</td>
<td>60</td>
<td>0</td>
</tr>
<tr>
<td>workQueue</td>
<td>LinkedBlockingQueue</td>
<td>LinkedBlockingQueue</td>
<td>SynchrousQueue</td>
<td>DelayedWorkQueue</td>
</tr>
</tbody></table>
<h3 id="8-线程池里的线程数量设定为多少比较合适"><a href="#8-线程池里的线程数量设定为多少比较合适" class="headerlink" title="8.线程池里的线程数量设定为多少比较合适"></a>8.线程池里的线程数量设定为多少比较合适</h3><ul>
<li>CPU密集型（加密，计算hash等）：最佳线程数为CPU核心数1-2倍左右</li>
<li>耗时IO型（读写数据库、文件、网络独写等）：最佳线程数一般会大于cpu核心数很多倍<ul>
<li>线程数=CPU核心数*（1 + 平均等待时间/平均工作时间）</li>
</ul>
</li>
</ul>
<h3 id="9-停止线程池的方法"><a href="#9-停止线程池的方法" class="headerlink" title="9.停止线程池的方法"></a>9.停止线程池的方法</h3><ul>
<li>shutdown：等待线程执行完毕后才终止<ul>
<li>isShutdown：判断是否执行了shutDown方法</li>
<li>isTerminated：判断线程是否终止</li>
</ul>
</li>
<li>awaitTermination：判断在指定时间内线程是否终止</li>
<li>shutDownNoe：立即终止线程，执行中的线程会被中断，队列中的线程会以List返回</li>
</ul>
<h3 id="10-线程池状态"><a href="#10-线程池状态" class="headerlink" title="10.线程池状态"></a>10.线程池状态</h3><ul>
<li>RUNNING:接受新任务并处理排队任务</li>
<li>SHUTDOWN:不接受新任务，但处理排队任务</li>
<li>STOP:不接受新任务，也不处理排队任务，并中断正在进行的任务</li>
<li>TIDYING:所有任务都已终止，worderCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法</li>
<li>TERMINATED:terminate()运行完成</li>
</ul>
<h3 id="11-使用线程池需要注意的地方"><a href="#11-使用线程池需要注意的地方" class="headerlink" title="11.使用线程池需要注意的地方"></a>11.使用线程池需要注意的地方</h3><ul>
<li>避免任务堆积</li>
<li>避免线程数过度增加</li>
<li>排查线程泄露（线程数量是否超出预期）</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="线程之间通讯"><a href="#线程之间通讯" class="headerlink" title="线程之间通讯"></a>线程之间通讯</h3><p>每个线程都是独立运行的个体，线程通讯能让多个线程之间协同工作。</p>
<ul>
<li>Object类中的wait/notify方法可以实现线程间通讯</li>
<li>wait/notify必须与synchronized一起使用，因为使用这些方法之前必须获得monitor锁</li>
<li>wait释放锁，且只释放当前对象锁，若有多个对象，不会影响到其他对象的锁</li>
<li>notify不释放锁</li>
</ul>
<h3 id="wait方法被唤醒的四种情况"><a href="#wait方法被唤醒的四种情况" class="headerlink" title="wait方法被唤醒的四种情况"></a>wait方法被唤醒的四种情况</h3><ul>
<li>另一个线程调用这个wait方法加锁对象的notify方法且刚好被唤醒的是本线程</li>
<li>另一个线程调用这个wait方法加锁对象的notifyAll方法</li>
<li>过了wait(long timeout)规定的超时时间，如果传入0就是永久等待</li>
<li>线程自身调用了interrupt()</li>
</ul>
<h4 id="栗子1：while方式实现线程间通讯"><a href="#栗子1：while方式实现线程间通讯" class="headerlink" title="栗子1：while方式实现线程间通讯"></a>栗子1：while方式实现线程间通讯</h4><p>启动一个线程调用put方法往全局变量list中添加元素，当添加了5个元素后，通知另一个线程调用get方法获取list中元素并输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo17</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canGet = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;添加第&quot;</span> + i + <span class="string">&quot;个元素&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">//循环到第次则通知其他线程开始获取数据进行处理</span></span><br><span class="line">                canGet = <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;发出通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canGet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取元素:&quot;</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo17 demo = <span class="keyword">new</span> ThreadDemo17();</span><br><span class="line">        <span class="comment">// 先添加元素</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.put(), <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 后获取元素</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.get(), <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程t1添加第<span class="number">1</span>个元素</span><br><span class="line">线程t1添加第<span class="number">2</span>个元素</span><br><span class="line">线程t1添加第<span class="number">3</span>个元素</span><br><span class="line">线程t1添加第<span class="number">4</span>个元素</span><br><span class="line">线程t1添加第<span class="number">5</span>个元素</span><br><span class="line">线程t1发出通知</span><br><span class="line">线程t2获取元素:A</span><br><span class="line">线程t2获取元素:A</span><br><span class="line">线程t2获取元素:A</span><br><span class="line">线程t2获取元素:A</span><br><span class="line">线程t2获取元素:A</span><br><span class="line">线程t1添加第<span class="number">6</span>个元素</span><br><span class="line">线程t1添加第<span class="number">7</span>个元素</span><br><span class="line">线程t1添加第<span class="number">8</span>个元素</span><br><span class="line">线程t1添加第<span class="number">9</span>个元素</span><br><span class="line">线程t1添加第<span class="number">10</span>个元素</span><br></pre></td></tr></table></figure>

<p>疑问：</p>
<p>1.一个线程修改全局变量，另外一个线程获取变量，不是会产生脏读吗？为什么没有加synchronized保证同步执行？</p>
<p>​        因为有全局变量canGet的控制，只有通过线程1改变了canGet的值，线程2才能get，并不会引起脏读。</p>
<p>这里需要对canGet变量加上volatile关键字，保证可见性。在个数为5的时候，线程t1已经更新了canGet=true,但是还未更新到主内存中，则线程t2取到的值不是最新的值。</p>
<p>2.当线程1，线程2运行结束后，list的size是多少？</p>
<p>​        10，当线程1添加到5个元素后，通知线程2，线程2获取元素并输出，然后就break退出循环了。但是线程1还在继续添加元素，直到线程1的循环10都结束。所以，最后list的size肯定是10，只不过线程2只是输出了前5个元素，就退出循环，不再输出了。</p>
<h4 id="栗子2：wait-notify实现线程间通讯"><a href="#栗子2：wait-notify实现线程间通讯" class="headerlink" title="栗子2：wait/notify实现线程间通讯"></a>栗子2：wait/notify实现线程间通讯</h4><p>启动一个线程调用put方法往全局变量list中添加元素，当添加了5个元素后，通知另一个线程调用get方法获取list中元素并输出。先调用get方法，先保证get方法运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo18</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;添加第&quot;</span> + i + <span class="string">&quot;个元素&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//数据准备好了,发出唤醒通知,但是不释放锁</span></span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;发出通知...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;业务处理,发现有需要的数据没准备好,则发起等待&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;wait&quot;</span>);</span><br><span class="line">                lock.wait(); <span class="comment">//wait操作释放锁,否则其他线程只能等该方法执行完后才能进入put方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取元素:&quot;</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo18 demo = <span class="keyword">new</span> ThreadDemo18();</span><br><span class="line">        <span class="comment">// 先调用get方法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.get(), <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证get方法先被调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再调用put方法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.put(), <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>线程t1先启动，获取lock锁，进入get方法执行。执行到lock.wait时，释放锁，等待通知。</p>
<p>t1释放锁，线程t2获得锁，进入put方法执行，添加5个元素后，发出通知，但是notify不释放锁，会继续执行完t1后才释放锁。</p>
<p>当t1添加完10个元素，t1执行完成，释放锁。线程t2接着执行wait后的输出语句，输出list中的10个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程t1业务处理,发现有需要的数据没准备好,则发起等待</span><br><span class="line">线程t1wait</span><br><span class="line">线程t2添加第<span class="number">1</span>个元素</span><br><span class="line">线程t2添加第<span class="number">2</span>个元素</span><br><span class="line">线程t2添加第<span class="number">3</span>个元素</span><br><span class="line">线程t2添加第<span class="number">4</span>个元素</span><br><span class="line">线程t2添加第<span class="number">5</span>个元素</span><br><span class="line">发出通知...</span><br><span class="line">线程t2添加第<span class="number">6</span>个元素</span><br><span class="line">线程t2添加第<span class="number">7</span>个元素</span><br><span class="line">线程t2添加第<span class="number">8</span>个元素</span><br><span class="line">线程t2添加第<span class="number">9</span>个元素</span><br><span class="line">线程t2添加第<span class="number">10</span>个元素</span><br><span class="line">线程t1被唤醒</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br><span class="line">线程t1获取元素:A</span><br></pre></td></tr></table></figure>

<h3 id="notify唤醒"><a href="#notify唤醒" class="headerlink" title="notify唤醒"></a>notify唤醒</h3><ul>
<li>notify方法只应该被拥有该对象的monitor的线程调用</li>
<li>要等刚才执行notify的线程退出被synchronized保护的代码并释放monitor</li>
</ul>
<h3 id="notify与notifyAll的区别"><a href="#notify与notifyAll的区别" class="headerlink" title="notify与notifyAll的区别"></a>notify与notifyAll的区别</h3><p>notifyAll 使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。</p>
<p>notify 只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。</p>
<h4 id="栗子1：只调用一次notify"><a href="#栗子1：只调用一次notify" class="headerlink" title="栗子1：只调用一次notify"></a>栗子1：只调用一次notify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run1方法..&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        System.out.println(<span class="string">&quot;run1执行完毕,通知完毕..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入run2方法..&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;run2执行完毕..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入run3方法..&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;run3执行完毕..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadDemo19 demo = <span class="keyword">new</span> ThreadDemo19();</span><br><span class="line">        <span class="comment">// 先执行等待通知的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run2()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run3()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 再执行发送通知的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run1()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>run2,run3方法先运行，等待通知。sleep1s后，run1方法运行，使用notify发送通知，只会发送一个通知。</p>
<p>run2收到通知，执行完毕。run3没有收到通知，还在等待着notify/notifyAll才可以继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入run2方法..</span><br><span class="line">进入run3方法..</span><br><span class="line">进入run1方法..</span><br><span class="line">run1执行完毕,通知完毕..</span><br><span class="line">run2执行完毕..</span><br></pre></td></tr></table></figure>

<p>如果run2方法修改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run2方法..&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">        System.out.println(<span class="string">&quot;run2执行完毕..&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        System.out.println(<span class="string">&quot;run2发出通知..&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>在run2方法中再次发送了notify通知，此时只有run3一个方法在等待通知，自然就是run3接收到通知，执行完毕。可以看到，notify类似于链式操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入run2方法..</span><br><span class="line">进入run3方法..</span><br><span class="line">进入run1方法..</span><br><span class="line">run1执行完毕,通知完毕..</span><br><span class="line">run2执行完毕..</span><br><span class="line">run2发出通知..</span><br><span class="line">run3执行完毕..</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：使用notifyAll"><a href="#栗子2：使用notifyAll" class="headerlink" title="栗子2：使用notifyAll"></a>栗子2：使用notifyAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run1方法..&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        System.out.println(<span class="string">&quot;run1执行完毕,通知完毕..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入run2方法..&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;run2执行完毕..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入run3方法..&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;run3执行完毕..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadDemo19 demo = <span class="keyword">new</span> ThreadDemo19();</span><br><span class="line">        <span class="comment">// 先执行等待通知的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run2()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run3()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 再执行发送通知的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.run1()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>使用notifyAll通知，所有的等待通知的线程都会收到通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入run2方法..</span><br><span class="line">进入run3方法..</span><br><span class="line">进入run1方法..</span><br><span class="line">run1执行完毕,通知完毕..</span><br><span class="line">run3执行完毕..</span><br><span class="line">run2执行完毕..</span><br></pre></td></tr></table></figure>

<h3 id="守护进程与用户进程"><a href="#守护进程与用户进程" class="headerlink" title="守护进程与用户进程"></a>守护进程与用户进程</h3><ul>
<li>main函数所在线程是一个用户线程</li>
<li>只要有一个用户线程还没结束，jvm进程就不会结束</li>
<li>父线程结束后，子线程还可以继续存活，子线程的生命周期不受父线程影响</li>
</ul>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>当前线程使用完时间片后就会进入就绪状态，让出cpu执行权给其他线程，此时就是从当前线程的上下文切换到了其他线程。</p>
<p>当发生上下文切换的时候需要保存执行现场，待下次执行时进行恢复。</p>
<p>所以频繁的，大量的上下文切换会造成一定资源开销。</p>
<h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><ul>
<li>Thread类中的一个静态方法</li>
<li>暂时让出执行权，不参与CPU调度，但是不释放锁，包括synchronized和lock</li>
<li>sleep之后，本身进入<strong>阻塞状态</strong>，时间到了就进入<strong>就绪状态</strong>，一旦获取到CPU时间片，则继续执行</li>
<li>清除中断状态</li>
</ul>
<blockquote>
<p>一句话总结：Sleep方法可以让线程进入TIME_WAITING状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常且清除中断标志</p>
</blockquote>
<h3 id="栗子1：两个线程交替打印1-100，使用wait-notify"><a href="#栗子1：两个线程交替打印1-100，使用wait-notify" class="headerlink" title="栗子1：两个线程交替打印1-100，使用wait/notify"></a>栗子1：两个线程交替打印1-100，使用wait/notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个线程执行自己的for循环，用判断是否奇偶的方式来控制打印顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:偶数------:&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 输出了偶数之后等待唤醒</span></span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:奇数:&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 输出奇数后等待被唤醒</span></span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量i,控制好i初始值,直接打印，打印完唤醒其他线程打印，不需要判断是否奇偶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintThread printThread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(printThread).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(printThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接打印，打印完换醒其他线程，自己休眠，不需要再判断是否奇偶</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                lock.notify();</span><br><span class="line">                <span class="comment">// 一定要判断是小于100的才阻塞等待，否则当i&gt;100的时候，没有线程notify了，会导致线程一直被阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栗子2：两个线程交替打印1-100，使用volatile修饰的变量控制"><a href="#栗子2：两个线程交替打印1-100，使用volatile修饰的变量控制" class="headerlink" title="栗子2：两个线程交替打印1-100，使用volatile修饰的变量控制"></a>栗子2：两个线程交替打印1-100，使用volatile修饰的变量控制</h3><p>用volatile修饰的变量来交替执行线程，需要while(true)死循环检测变量是否改变.<br>当输出完结果后，线程不会正常结束，会被阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> is_odd = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_odd &amp;&amp; i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:偶数:&quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                is_odd = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ji</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!is_odd &amp;&amp; i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:奇数:&quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                is_odd = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OddExample2 obj = <span class="keyword">new</span> OddExample2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; obj.odd()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; obj.ji()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栗子3：两个线程交替打印1-100，使用synchronized"><a href="#栗子3：两个线程交替打印1-100，使用synchronized" class="headerlink" title="栗子3：两个线程交替打印1-100，使用synchronized"></a>栗子3：两个线程交替打印1-100，使用synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// 代码块执行完释放锁后，可能又会进入该线程，两个线程会频繁竞争锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">//位运算判断是否是偶数</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:偶数:&quot;</span> + i);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">//位运算判断是否是偶数</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:奇数:&quot;</span> + i);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题1：为什么wait方法需要在同步代码块内使用，而sleep方法不需要"><a href="#面试题1：为什么wait方法需要在同步代码块内使用，而sleep方法不需要" class="headerlink" title="面试题1：为什么wait方法需要在同步代码块内使用，而sleep方法不需要"></a>面试题1：为什么wait方法需要在同步代码块内使用，而sleep方法不需要</h3><p>sleep方法主要是在线程内使用的，不涉及多个线程的通信。</p>
<p>wait方法放在同步代码块主要了为了防止死锁的发生。因为有了synchronized关键字，能保证在同一时刻，只会有一个线程执行代码快中的代码，避免了先notify，后wait这种情况。</p>
<h3 id="面试题2：wait-notify方法为什么定义在Object类，而不是Thread类？"><a href="#面试题2：wait-notify方法为什么定义在Object类，而不是Thread类？" class="headerlink" title="面试题2：wait/notify方法为什么定义在Object类，而不是Thread类？"></a>面试题2：wait/notify方法为什么定义在Object类，而不是Thread类？</h3><p>wait/notify是需要在同步代码块内使用的，而同步代码快涉及到锁，锁是保存在对象的对象头的。任意对象都可以作为锁。另一方面，经常在同一个代码块中有多个锁配合使用，因此wait/notify定义在Object类是比较灵活的。</p>
<h3 id="面试题3：调用Thread-wait-方法会发生什么情况？"><a href="#面试题3：调用Thread-wait-方法会发生什么情况？" class="headerlink" title="面试题3：调用Thread.wait()方法会发生什么情况？"></a>面试题3：调用Thread.wait()方法会发生什么情况？</h3><p>Thread也是一个对象，也可以调用wait方法。但是Thread类在线程结束后，会自动调用notifyAll方法。如果使用Thread对象作为锁，调用了Thread.wait方法，会对设计好的业务有影响。</p>
<h3 id="面试题4：wait、sleep方法的相同点，不同点"><a href="#面试题4：wait、sleep方法的相同点，不同点" class="headerlink" title="面试题4：wait、sleep方法的相同点，不同点"></a>面试题4：wait、sleep方法的相同点，不同点</h3><ul>
<li>相同点<ul>
<li>阻塞</li>
<li>响应中断</li>
</ul>
</li>
<li>不同点<ul>
<li>所属类</li>
<li>释放锁：wait释放锁，sleep不释放锁</li>
<li>同步方法中：wait需要在同步方法中使用，sleep不需要</li>
<li>指定时间：sleep方法使用必须指定时间，而wait可以不指定时间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized.md</title>
    <url>/2020/08/10/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8ESynchronized/</url>
    <content><![CDATA[<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ul>
<li>当多个线程访问某一个类、对象或方法时，这个类、对象或方法都能表现出与单线程执行时一致的行为，那么这个类、对象或方法就是线程安全的</li>
<li>线程安全问题都是由全局变量（成员变量）以及静态变量引起的</li>
<li>若每个线程中对全局变量、静态变量只有读操作，没有写操作，一般来说，这个全局变量是线程安全的。若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就有可能影响线程安全</li>
</ul>
<h3 id="需要考虑线程安全的情况"><a href="#需要考虑线程安全的情况" class="headerlink" title="需要考虑线程安全的情况"></a>需要考虑线程安全的情况</h3><ul>
<li>访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等</li>
<li>check-then-act操作：一个线程读取了一个共享数据，并在此基础上决定其下一个的操作</li>
<li>不同的数据之间存在捆绑关系的时候</li>
<li>我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题</li>
</ul>
<h4 id="栗子1：多个线程a-导致的线程安全问题"><a href="#栗子1：多个线程a-导致的线程安全问题" class="headerlink" title="栗子1：多个线程a++导致的线程安全问题"></a>栗子1：多个线程a++导致的线程安全问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SumError instance = <span class="keyword">new</span> SumError();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录1-10000有哪一次是计算出错的，默认值为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">20001</span>];</span><br><span class="line">    <span class="comment">// 记录真正执行的次数</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger execNums = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 记录出错的次数</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger wrongNums = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑第一次就发生错误的情况</span></span><br><span class="line">        marked[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 防止线程1执行完了，线程2还未执行检测，</span></span><br><span class="line"><span class="comment">                 又执行线程1的情况，又被cpu切换sum++了一次，这样会影响线程2漏检测</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                cyclicBarrier2.reset();</span><br><span class="line">                cyclicBarrier1.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 防止线程1在执行设置为true时，线程2把sum++了一次，</span></span><br><span class="line"><span class="comment">                 导致线程1检测的位置不对</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                cyclicBarrier1.reset();</span><br><span class="line">                cyclicBarrier2.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 防止线程1还未检测，线程2把sum++了一次</span></span><br><span class="line">                cyclicBarrier2.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行次数增加</span></span><br><span class="line">            execNums.incrementAndGet();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             检测当前要累加的值是否已经被累加过了，如果是的话，就是计算出错了</span></span><br><span class="line"><span class="comment">             synchronized保证检测的步骤和检测完设置为true的步骤是原子性的</span></span><br><span class="line"><span class="comment">             有可能出现sum++了，第二个线程也sum++，原本我要判断的sum位置就错位了,所以需要CycleBarrier</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="keyword">if</span> (marked[sum] &amp;&amp; marked[sum - <span class="number">1</span>]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生了错误:&quot;</span> + sum);</span><br><span class="line">                    <span class="comment">// 发生错误的次数增加</span></span><br><span class="line">                    wrongNums.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 操作过后，设置true</span></span><br><span class="line">                marked[sum] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的结果是:&quot;</span> + instance.sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的次数是:&quot;</span> + instance.execNums);</span><br><span class="line">        System.out.println(<span class="string">&quot;出现错误的次数是:&quot;</span> + instance.wrongNums);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h3><ul>
<li>synchronized的作用是加锁，所有的synchronieed方法都会顺序执行（这里指占用cpu的顺序）</li>
<li>synchronized保证在<strong>同一时刻</strong>最多只有<strong>一个</strong>线程执行该段代码</li>
<li>synchronized能保证可见性和原子性，线程在执行结束前会把独立内存的值刷新回主内存，从而保证可见性</li>
</ul>
<h3 id="synchronized的执行方式"><a href="#synchronized的执行方式" class="headerlink" title="synchronized的执行方式"></a>synchronized的执行方式</h3><ul>
<li>首先尝试获得锁</li>
<li>如果获得锁，则执行synchronized的方法体内容</li>
<li>如果无法获得锁，则等待并且不断尝试去获得锁，一旦锁被释放，则多个线程会同时去尝试获得锁，造成锁竞争的问题</li>
</ul>
<h3 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h3><ul>
<li>效率低<ul>
<li>锁竞争问题，在高并发、线程数量高时会引起CPU占用居高不下，或者直接宕机</li>
<li>锁的释放情况少，只有正常结束或抛出异常的时候才释放锁</li>
<li>试图获得锁时不能设定超时时间</li>
<li>不能中断一个正在试图获得锁的线程</li>
</ul>
</li>
<li>不够灵活（读写锁更灵活）<ul>
<li>加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的</li>
</ul>
</li>
<li>无法知道是否成功获取到锁</li>
</ul>
<h3 id="synchronized的两个用法：对象锁和类锁"><a href="#synchronized的两个用法：对象锁和类锁" class="headerlink" title="synchronized的两个用法：对象锁和类锁"></a>synchronized的两个用法：对象锁和类锁</h3><ul>
<li><p>对象锁：一个对象一个锁，多个对象之间不会发生锁竞争</p>
<ul>
<li><p>方法锁，默认锁对象为this当前实例对象</p>
</li>
<li><p>同步代码块锁，自己指定任意对象(指定锁对象为this，相当于方法锁)</p>
</li>
<li><p>```java<br>public synchronized void method(){}<br>// 等价<br>public void method(){</p>
<pre><code>synchronized(this)&#123;&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 类锁：所有对象共享一把锁，存在锁竞争</span><br><span class="line"></span><br><span class="line">  * synchronized加在静态方法</span><br><span class="line">  * 同步代码块指定锁为Class对象</span><br><span class="line"></span><br><span class="line">#### 栗子1：synchronized保证线程安全</span><br><span class="line"></span><br><span class="line">创建3个线程共享一个ThreadDemo01对象，并对对象中的成员变量进行了写操作。肯定会引发线程安全问题。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ThreadDemo01 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;&gt;count=&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo01 threadDemo01 = new ThreadDemo01();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            new Thread(threadDemo01, &quot;t&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>输出结果：</p>
<p>存在线程安全问题！三条线程使用同一个threadDemo01创建线程。对threadDemo01对象中的count变量进行写的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t0&gt;count=<span class="number">3</span></span><br><span class="line">t1&gt;count=<span class="number">3</span></span><br><span class="line">t2&gt;count=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="使用synchronized方法加对象锁，解决线程安全问题："><a href="#使用synchronized方法加对象锁，解决线程安全问题：" class="headerlink" title="使用synchronized方法加对象锁，解决线程安全问题："></a>使用synchronized方法加对象锁，解决线程安全问题：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>每隔2s中输出一次结果，不存在线程安全问题！</p>
<p>当t0执行run方法时，对threadDemo01对象加对象锁，当t1执行run方法时，必须等待t0释放锁才能执行。</p>
<p>所以sleep2s后，t0执行完，t1就可以执行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t0&gt;count=<span class="number">1</span></span><br><span class="line">t2&gt;count=<span class="number">2</span></span><br><span class="line">t1&gt;count=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="使用同步代码块方法加对象锁，解决线程安全问题"><a href="#使用同步代码块方法加对象锁，解决线程安全问题" class="headerlink" title="使用同步代码块方法加对象锁，解决线程安全问题"></a>使用同步代码块方法加对象锁，解决线程安全问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用同步代码块指定锁为Class对象加类锁，解决线程安全问题"><a href="#使用同步代码块指定锁为Class对象加类锁，解决线程安全问题" class="headerlink" title="使用同步代码块指定锁为Class对象加类锁，解决线程安全问题"></a>使用同步代码块指定锁为Class对象加类锁，解决线程安全问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadDemo01.class) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用static变量加类锁，解决线程安全问题"><a href="#使用static变量加类锁，解决线程安全问题" class="headerlink" title="使用static变量加类锁，解决线程安全问题"></a>使用static变量加类锁，解决线程安全问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：对象锁和类锁"><a href="#栗子2：对象锁和类锁" class="headerlink" title="栗子2：对象锁和类锁"></a>栗子2：对象锁和类锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是static变量会怎样?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo03 thread1 = <span class="keyword">new</span> ThreadDemo03();</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo03 thread2 = <span class="keyword">new</span> ThreadDemo03();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; thread1.add());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; thread1.add());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>同一个对象同一把锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>&gt;count=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>&gt;count=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>把main方法修改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadDemo03 thread1 = <span class="keyword">new</span> ThreadDemo03();</span><br><span class="line">    <span class="keyword">final</span> ThreadDemo03 thread2 = <span class="keyword">new</span> ThreadDemo03();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; thread1.add());</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; thread2.add());</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>不同对象，不同的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>&gt;count=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>&gt;count=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果把count变量升级为静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是static变量会怎样?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; ThreadDemo03.add());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; ThreadDemo03.add());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>对象锁升级为类锁，存在锁竞争问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>&gt;count=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>&gt;count=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="对象锁的同步与异步"><a href="#对象锁的同步与异步" class="headerlink" title="对象锁的同步与异步"></a>对象锁的同步与异步</h3><p>同步：必须等待方法执行完毕，才能向下执行，共享资源访问的时候，为了保证线程安全，必须同步</p>
<p>异步：不用等待其他方法执行完毕，即可以立即执行，例如Ajax异步</p>
<ul>
<li>对象锁只针对synchronized修饰的方法生效、对象中的所有synchronized方法都会同步执行、而非 synchronized方法异步执行</li>
<li>避免误区：类中有两个synchronized方法，两个线程分别调用两个方法，相互之间也需要竞争锁， 因为两个方法从属于一个对象，而我们是在对象上加锁</li>
</ul>
<h4 id="栗子1：同步与异步执行"><a href="#栗子1：同步与异步执行" class="headerlink" title="栗子1：同步与异步执行"></a>栗子1：同步与异步执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;print1执行,时间:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;hello!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;print2执行,时间:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo02 thread = <span class="keyword">new</span> ThreadDemo02();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; thread.print1(), <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; thread.print2(), <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>两个线程共享一个ThreadDemo02对象，当t1执行synchronized void print1()时会加对象锁，而此时t2执行public void print2()能不能执行成功？是不是要等待t1释放锁才能执行？</p>
<p>从运行结果来看，在同一时间，t1执行了print1方法，t2执行了print2方法，说明t2不需要等待t1释放锁。这时因为对象中的所有synchronized方法都会同步执行、而非 synchronized方法异步执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print2执行,时间:Thu Jun <span class="number">25</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">43</span> CST <span class="number">2020</span></span><br><span class="line">print1执行,时间:Thu Jun <span class="number">25</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">43</span> CST <span class="number">2020</span></span><br><span class="line">thread1&gt;hello!</span><br><span class="line">thread1&gt;hello!</span><br></pre></td></tr></table></figure>

<p>如果给print2也加上synchronized关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;print2执行,时间:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>同一个对象的多个synchronized方法是同步执行的，多条线程如果调用的是synchronized方法，是要等待其他线程对该对象释放锁后才能执行的。</p>
<p>t1对print1加对象锁，t2要像访问同一对象的print2方法，就需要等待t1执行完毕释放锁才能继续执行，可以看到输出结果中sleep3s等待t1释放锁，才执行print2方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print1执行,时间:Thu Jun <span class="number">25</span> <span class="number">18</span>:<span class="number">34</span>:<span class="number">06</span> CST <span class="number">2020</span></span><br><span class="line">thread1&gt;hello!</span><br><span class="line">print1执行,时间:Thu Jun <span class="number">25</span> <span class="number">18</span>:<span class="number">34</span>:09 CST <span class="number">2020</span></span><br><span class="line">thread1&gt;hello!</span><br></pre></td></tr></table></figure>

<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>由于同步和异步方法的执行个性，如果不从全局上进行并发设计很可能会引起数据的不一致，也就是所谓的脏读。</p>
<ul>
<li>多个线程访问同一资源，在一个线程修改数据的过程中，有另外的线程来读取数据，就会引起脏读数据的产生。</li>
<li>为了避免脏读，我们一定要保证数据修改操作的原子性，并且对读操作也要进行同步控制</li>
</ul>
<h4 id="栗子1：脏读的产生"><a href="#栗子1：脏读的产生" class="headerlink" title="栗子1：脏读的产生"></a>栗子1：脏读的产生</h4><p>线程修改ThreadDemo04的name和address属性，但是address还未修改成功，就被读取，从而发生了脏读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">&quot;大兴&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        System.out.println(<span class="string">&quot;setValue最终结果：username = &quot;</span> + name + <span class="string">&quot; , address = &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getValue方法得到：username = &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; , address = &quot;</span> + <span class="keyword">this</span>.address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo04 dr = <span class="keyword">new</span> ThreadDemo04();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; dr.setVal(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;昌平&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1s,t1线程肯定还未执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        dr.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程还未将地址修改，main线程将旧的数据读取了出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getValue方法得到：username = 李四 , address = 大兴</span><br><span class="line">setValue最终结果：username = 李四 , address = 昌平</span><br></pre></td></tr></table></figure>

<p>要解决脏读问题，对读操作也要进行同步控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;getValue方法得到：username = &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; , address = &quot;</span> + <span class="keyword">this</span>.address);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setValue最终结果：username = 李四 , address = 昌平</span><br><span class="line">getValue方法得到：username = 李四 , address = 昌平</span><br></pre></td></tr></table></figure>

<h3 id="synchronized的性质"><a href="#synchronized的性质" class="headerlink" title="synchronized的性质"></a>synchronized的性质</h3><blockquote>
<p>不可中断性</p>
</blockquote>
<p>一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远地等下去。</p>
<blockquote>
<p>可重入性</p>
</blockquote>
<p>同一个线程得到了一个对象的锁之后，再次请求此对象时可以再次获得该对象的锁。（同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁）</p>
<p>1.优点：避免死锁，提升封装性</p>
<p>2.粒度：</p>
<ul>
<li>证明同一个方法是可重入的（递归调用本方法）</li>
<li>证明可重入不要求是同一个方法（同一个对象内的多个synchromized方法可以锁重入）</li>
<li>证明可重入不要求是同一个类中的（父子类可以锁重入）</li>
</ul>
<h4 id="栗子1：同一个对象内的多个synchronized方法"><a href="#栗子1：同一个对象内的多个synchronized方法" class="headerlink" title="栗子1：同一个对象内的多个synchronized方法"></a>栗子1：同一个对象内的多个synchronized方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;run1...&quot;</span>);</span><br><span class="line">        <span class="comment">//调用同类中的synchronized方法不会引起死锁</span></span><br><span class="line">        run2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;run2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo05 threadDemo05 = <span class="keyword">new</span> ThreadDemo05();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; threadDemo05.run1());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程首先调用了run1()方法，对threadDemo05对象加对象锁，在run1()方法中又调用了synchronized修饰的run2()方法，按理说，run1()方法还没有执行完毕，没有释放锁，执行run2()方法没有获得锁，是会发生死锁的。但是运行结果说明，同个对象的synchronized方法是可以锁重入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>&gt;run1...</span><br><span class="line">Thread-<span class="number">0</span>&gt;run2...</span><br></pre></td></tr></table></figure>

<h4 id="栗子2-：父子类的锁重入"><a href="#栗子2-：父子类的锁重入" class="headerlink" title="栗子2 ：父子类的锁重入"></a>栗子2 ：父子类的锁重入</h4><p>在child类中synchronized方法中调用了Parent类的synchronized方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">runParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i--;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&gt;&gt;&gt;&gt;i=&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">runChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(<span class="string">&quot;Child&gt;&gt;&gt;&gt;i=&quot;</span> + i);</span><br><span class="line">            <span class="comment">//调用父类中的synchronized方法不会引起死锁</span></span><br><span class="line">            <span class="keyword">this</span>.runParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Child sub = <span class="keyword">new</span> Child();</span><br><span class="line">            sub.runChild();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>Child类继承了Parent的i变量和runParent()。</p>
<p>当线程调用Child类的runChild()时，对sub对象加对象锁，而在runChild方法中又调用了runParent方法，按理说，runChild方法没有执行完毕，不会释放锁，runParent方法执行又需要获得锁，会发生死锁现象。从运行结果来看，父子类之间的多个synchronized方法是可以锁重入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Child&gt;&gt;&gt;&gt;i=<span class="number">9</span></span><br><span class="line">Parent&gt;&gt;&gt;&gt;i=<span class="number">8</span></span><br><span class="line">Child&gt;&gt;&gt;&gt;i=<span class="number">7</span></span><br><span class="line">Parent&gt;&gt;&gt;&gt;i=<span class="number">6</span></span><br><span class="line">Child&gt;&gt;&gt;&gt;i=<span class="number">5</span></span><br><span class="line">Parent&gt;&gt;&gt;&gt;i=<span class="number">4</span></span><br><span class="line">Child&gt;&gt;&gt;&gt;i=<span class="number">3</span></span><br><span class="line">Parent&gt;&gt;&gt;&gt;i=<span class="number">2</span></span><br><span class="line">Child&gt;&gt;&gt;&gt;i=<span class="number">1</span></span><br><span class="line">Parent&gt;&gt;&gt;&gt;i=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="抛出异常释放锁"><a href="#抛出异常释放锁" class="headerlink" title="抛出异常释放锁"></a>抛出异常释放锁</h3><p>一个线程在获得锁之后执行操作，发生错误抛出异常，则自动释放锁。</p>
<ul>
<li>可以利用抛出异常，主动释放锁</li>
<li>程序异常时防止资源被死锁，无法释放</li>
<li>异常释放锁可能导致数据不一致</li>
</ul>
<h4 id="栗子1：主动抛出异常，释放锁"><a href="#栗子1：主动抛出异常，释放锁" class="headerlink" title="栗子1：主动抛出异常，释放锁"></a>栗子1：主动抛出异常，释放锁</h4><p>在变量i加到10的时候主动释放锁，才能让get方法获取变量i的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-run&gt;i=&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止脏读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-get&gt;i=&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo07 threadDemo07 = <span class="keyword">new</span> ThreadDemo07();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; threadDemo07.add(), <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 保证t1线程先执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; threadDemo07.get(), <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>线程调用add方法，在add方法中对i进行累加，本会一直无限循环进行累加，但在add方法中主动抛出了异常，释放锁，而get方法就可以运行得到i的值。</p>
<p>这里需要注意的是，即使add方法没有释放锁，get方法也可以锁重入。但因为synchronized方法是同步执行的，所以get方法必须等add方法执行完才能执行。</p>
<p>==<strong>所以这里要区分死锁问题和同步执行问题</strong>==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1-run&gt;i=<span class="number">1</span></span><br><span class="line">t1-run&gt;i=<span class="number">2</span></span><br><span class="line">t1-run&gt;i=<span class="number">3</span></span><br><span class="line">t1-run&gt;i=<span class="number">4</span></span><br><span class="line">t1-run&gt;i=<span class="number">5</span></span><br><span class="line">t1-run&gt;i=<span class="number">6</span></span><br><span class="line">t1-run&gt;i=<span class="number">7</span></span><br><span class="line">t1-run&gt;i=<span class="number">8</span></span><br><span class="line">t1-run&gt;i=<span class="number">9</span></span><br><span class="line">t1-run&gt;i=<span class="number">10</span></span><br><span class="line">t2-get&gt;i=<span class="number">10</span></span><br><span class="line">Exception in thread <span class="string">&quot;t1&quot;</span> java.lang.RuntimeException</span><br><span class="line">	at thread04.ThreadDemo07.run(ThreadDemo07.java:<span class="number">29</span>)</span><br><span class="line">	at thread04.ThreadDemo07.lambda$main$<span class="number">0</span>(ThreadDemo07.java:<span class="number">41</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>可以达到更细粒度的控制</p>
<ul>
<li>当前对象锁</li>
<li>类锁</li>
<li>任意对象锁</li>
</ul>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;当前对象锁..&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadDemo08.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;类锁..&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;任意对象锁..&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前对象锁测试...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类锁测试...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任意对象锁测试...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo08 demo1 = <span class="keyword">new</span> ThreadDemo08();</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo08 demo2 = <span class="keyword">new</span> ThreadDemo08();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">                demo1.run1();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                demo1.run2();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                demo1.run3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">                demo1.run1();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                demo2.run2();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                demo1.run3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">1</span>);  <span class="comment">// 测试当前对象锁</span></span><br><span class="line">        <span class="comment">//test(2);  // 测试类锁</span></span><br><span class="line">        <span class="comment">//test(3);  // 测试任意对象锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：test(1)</p>
<p>可以用同步代码块对当前对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前对象锁测试...</span><br><span class="line">t1&gt;当前对象锁..</span><br><span class="line">t2&gt;当前对象锁..</span><br></pre></td></tr></table></figure>

<p>test(2)：</p>
<p>可以用同步代码块对类加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类锁测试...</span><br><span class="line">t1&gt;类锁..</span><br><span class="line">t2&gt;类锁..</span><br></pre></td></tr></table></figure>

<p>test(3):</p>
<p>可以用同步代码块对任意对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任意对象锁测试...</span><br><span class="line">t1&gt;任意对象锁..</span><br><span class="line">t2&gt;任意对象锁..</span><br></pre></td></tr></table></figure>

<p>我们测试一下当类锁和对象锁同时存在的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ThreadDemo08 demo1 = <span class="keyword">new</span> ThreadDemo08();</span><br><span class="line">     <span class="keyword">final</span> ThreadDemo08 demo2 = <span class="keyword">new</span> ThreadDemo08();</span><br><span class="line">     System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">     <span class="comment">// 加类锁</span></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(() -&gt; demo1.run2(), <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     t1.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加对象锁</span></span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(() -&gt; demo2.run1(), <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">     t2.start();</span><br><span class="line">     System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>从运行结果可以看到，在同一时间，两条线程并行执行了。并没有sleep2s，也就是说对象锁并不需要等待类锁释放才执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thu Jun <span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">t1&gt;类锁..</span><br><span class="line">Thu Jun <span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">t2&gt;当前对象锁..</span><br></pre></td></tr></table></figure>

<p>总结：<strong>同类型锁之间互坼，不同类型的锁之间互不干扰</strong></p>
<h3 id="synchronized使用的几种情况"><a href="#synchronized使用的几种情况" class="headerlink" title="synchronized使用的几种情况"></a>synchronized使用的几种情况</h3><ol>
<li>两个线程同时访问<strong>同一对象</strong>的synchronized方法<ul>
<li>同一时刻只有一个线程访问，另一个线程阻塞，对象锁</li>
</ul>
</li>
<li>两个线程同时访问<strong>不同对象</strong>的synchronized方法<ul>
<li>两个线程并行执行，互不影响</li>
</ul>
</li>
<li>两个线程访问的是synchronized的static方法<ul>
<li>同一时刻只有一个线程访问，另一个线程阻塞，类锁</li>
</ul>
</li>
<li>同时访问synchronized修饰的方法与没有sychronized修饰的方法<ul>
<li>synchronized修饰的方法同步执行，没有synchronized修饰的方法异步执行</li>
</ul>
</li>
<li>访问同一个对象实例的不同的非static的synchronized方法<ul>
<li>同步执行，因为synchronized修饰的非static方法默认使用synchronized(this)加对象锁的方式</li>
</ul>
</li>
<li>同时访问<strong>静态</strong>synchronized方法与<strong>非静态</strong>的synchronized方法<ul>
<li>不会影响。同种类型的锁会互坼，不同类型的锁互不干扰。因为静态synchronized方法对class加锁，非静态synchronized方法对this加锁，不是同一把锁</li>
</ul>
</li>
<li>方法抛出异常，释放锁</li>
</ol>
<p>总结(3个核心思想)：</p>
<ul>
<li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5的情况）</li>
<li>每个实例都对应自己的一把锁，不同实例之间互不影响。例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对应2、3、4、6的情况）</li>
<li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）</li>
</ul>
<h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><blockquote>
<p>加锁和释放锁的原理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized加锁的机制类似如下代码</span></span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 情况1：抛出异常释放锁的情况</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：正常结束释放锁的情况</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反编译查看monitor</p>
</blockquote>
<p>javap -verbose  SynchronizedLock.class 查看反编译文件。</p>
<p>一个monitorenter可以对应多个monitorexit，是因为进入之后度与退出的情况并不是一一对应的，多种退出方式使得exit数量可能大于enter的数量。</p>
<p>monitorenter使monitor计数器+1，monitorexit使计数器-1,如果变成没有变成0，说明之前是重入的，那么线程继续持有锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">4</span>: dup</span><br><span class="line">         <span class="number">5</span>: astore_1</span><br><span class="line">         <span class="number">6</span>: monitorenter	<span class="comment">// 重点</span></span><br><span class="line">         <span class="number">7</span>: aload_1</span><br><span class="line">         <span class="number">8</span>: monitorexit		<span class="comment">// 重点</span></span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit		<span class="comment">// 可能存在一个monitorenter对应着多个monitorexit,因为存在两种退出情况</span></span><br><span class="line">        <span class="number">15</span>: aload_2</span><br><span class="line">        <span class="number">16</span>: athrow</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="锁失效问题"><a href="#锁失效问题" class="headerlink" title="锁失效问题"></a>锁失效问题</h3><ul>
<li>不要在线程中修改对象锁的引用，引用被改变会导致锁失效。</li>
<li>在线程中修改了锁对象的属性，而不修改引用则不会引起锁失效，不会产生线程安全问题</li>
</ul>
<h4 id="栗子1：修改对象的引用会引起锁失效"><a href="#栗子1：修改对象的引用会引起锁失效" class="headerlink" title="栗子1：修改对象的引用会引起锁失效"></a>栗子1：修改对象的引用会引起锁失效</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo09</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lock = <span class="string">&quot;lock handler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程 : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程 : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ThreadDemo09 changeLock = <span class="keyword">new</span> ThreadDemo09();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; changeLock.method(), <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; changeLock.method(), <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>正常的执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前线程 : t1开始</span><br><span class="line">当前线程 : t1结束</span><br><span class="line">当前线程 : t2开始</span><br><span class="line">当前线程 : t2结束</span><br></pre></td></tr></table></figure>

<p>由于锁的引用被改变，所以t2线程也进入到method方法内执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程 : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                <span class="comment">//锁的引用被改变,则其他线程可获得锁，导致并发问题</span></span><br><span class="line">                lock = <span class="string">&quot;change lock handler&quot;</span>;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程 : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>从运行结果来看，synchronized同步代码块不能保证原子性了，同步失效了。这是因为在线程执行过程中，线程A修改了锁的引用，则线程B实际上得到了新的对象锁，而不是锁被释放了，因此引发了线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前线程 : t1开始</span><br><span class="line">当前线程 : t1结束</span><br><span class="line">当前线程 : t2开始</span><br><span class="line">当前线程 : t2结束</span><br></pre></td></tr></table></figure>

<h4 id="栗子2：修改对象属性不会引起锁失效"><a href="#栗子2：修改对象属性不会引起锁失效" class="headerlink" title="栗子2：修改对象属性不会引起锁失效"></a>栗子2：修改对象属性不会引起锁失效</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DemoThread10 [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo10</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeUser</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (person) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span> + person);</span><br><span class="line">            <span class="comment">// 修改对象的属性，不会引起锁失效</span></span><br><span class="line">            person.setAge(age);</span><br><span class="line">            person.setName(name);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;修改为&quot;</span> + person);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span> + person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDemo10 thread10 = <span class="keyword">new</span> ThreadDemo10();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; thread10.changeUser(<span class="string">&quot;小白&quot;</span>, <span class="number">99</span>), <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; thread10.changeUser(<span class="string">&quot;小黑&quot;</span>, <span class="number">100</span>), <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>synchronized加的对象锁没有失效，没有出现线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程t1开始DemoThread10 [name=<span class="keyword">null</span>, age=<span class="number">0</span>]</span><br><span class="line">线程t1修改为DemoThread10 [name=小白, age=<span class="number">99</span>]</span><br><span class="line">线程t1结束DemoThread10 [name=小白, age=<span class="number">99</span>]</span><br><span class="line">线程t2开始DemoThread10 [name=小白, age=<span class="number">99</span>]</span><br><span class="line">线程t2修改为DemoThread10 [name=小黑, age=<span class="number">100</span>]</span><br><span class="line">线程t2结束DemoThread10 [name=小黑, age=<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h3 id="一句话总结Synchronized"><a href="#一句话总结Synchronized" class="headerlink" title="一句话总结Synchronized"></a>一句话总结Synchronized</h3><p>JVM会自动通过使用monitor来加锁和解锁，保证了同一时刻只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
</search>
