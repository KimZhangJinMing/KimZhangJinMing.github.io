---
title: Mysql事务.md
date: 2020-08-23 12:31:35
categories: Mysql
tags: Mysql事务
---

### 事务隔离级别

* READ UNCOMMITED:读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
* READ COMMITED:读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
* REPEATABLE READ:可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的(一致性读)。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* SERIALIZALBE:串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

可以使用 select @@tx_isolation;或者show variables like 'tx_isolation';来查看当前的事务隔离级别。



### 事务隔离的实现

在实现上，数据库里面会创建一个一致性视图，访问的时候以视图的逻辑结果为准。

* 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图，就保证了可重复度的特性。
* 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的，因为读要求的特性是每次都读到最新已提交的值，就需要在每个SQL语句开始执行的时候创建视图。
* “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；
* “串行化”隔离级别下直接用加锁的方式来避免并行访问。

#### 此视图非彼视图

在Mysql中，有两个“视图”的概念：

* 一个是view，它是一个用查询语句定义的虚拟表，在调用的时候就执行查询语句并生成结果，创建视图的语法是create view ……，而它的查询方法和表一样
* 另一个是Innodb在实现MVCC时用到的一致性读视图(consistent read view)，用于支持Read Commited和Repeatbale Read隔离级别的实现。在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作（undo log）。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。它并不是物理上真实存在的，而是每次需要的时候，根据当前版本和undo log计算出来的。

#### 一致性视图不是物理真实存在的，那它什么时候被删除？

在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。



### 事务的启动方式

* 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
* set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。



### 长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。





### 一个栗子发现事务与行锁的关系

下面是一个只有两行的表的初始化语句。

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![事务A、B、C的执行流程](https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/823acf76e53c0bdba7beab45e72e90d6.png)

这里，我们需要注意的是事务的启动时机。

#### 事务的启动时机

* begin/start transaction命令并不是一个事务的起点，一致性视图是在执行第一个操作Innodb表时创建的；

* start transaction with consistent snapshot命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，对于其他事务的更新，有三种情况：

1. 其他事务版本未提交，对当前事务不可见；

2. 其他事务版本已提交，但是是在当前事务视图创建后提交的，不可见；

3. 其他事务版本已提交，而且是在当前事务视图创建前提交的，可见。

现在我们用这个规则来分析上图的执行结果。

最先提交的是事务C，事务C是自动提交的，提交过后k=2。

然后，事务B执行更新操作，由于事务C是在事务B之后创建的，对于 事务B不可见(第2点)，事务B读取到k=1，将其更新为k=2,又做了一次查询 k=2。

事务A先于事务B、事务C创建，即使事务C的事务已经提交，但对于事务A是不可见的（第2点），事务B还未提交，对于事务A不可见(第3点)。所以，事务A查询的k=1

上述分析过程，在实际 运行结果中，事务B的分析有误，原因是忽略了更新操作是“当前读”。

如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。

但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。

所以，这里就用到了这样一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。**

这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。

所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到事务B未提交的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。

```sql
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？

![事务C'的提交在事务B之后](https://jinming8.oss-cn-shenzhen.aliyuncs.com/img/20200826180008.png)

事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？

这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。

那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？

这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。

我们再来分析一下执行结果：

* 事务A、事务B、事务C'按顺序启动，事务C'最先更新k=2,对这一行加了写锁，但是未提交事务，锁未释放。
* 事务B更新k的值，需要获取锁，但是事务C'还未提交，事务B获取不到锁，只能等待事务C'提交完成后，才能继续事务B的当前读，当事务C'释放锁后，事务B更新k=3
* 事务A执行的时候，事务C'已经提交，但是事务C'是在事务A之后创建的，事务A不可见，所以 事务A查询的k=1。

**可见，在可重复读的隔离级别下，不管加锁与否，执行结果是一样的，区别只在于如果存在加锁的情况，要等其他事务释放锁才能继续往下执行。**

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
* 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

在读提交的隔离级别下，我们分析一下执行结果：

start transaction with consistent snapshot;相当于start transaction。在执行到操作表的语句时，事务才真正启动。

* 事务C’首先启动，更新k=2,对这一行加了写锁，但是未提交事务，锁未释放。
* 事务B更新k的值，需要获取锁，阻塞在当前读，等待C'释放锁后更新k，再次进行查询k=3
* 事务A执行的时候，事务C'已经提交，事务A可以获取事务C’更新的值，查询到k=2

#### 小结：

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。

普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。

**可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。**

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
* 对于读提交，查询只承认在语句启动前就已经提交完成的数据；

对于读提交，查询只承认在语句启动前就已经提交完成的数据；



### 问题1：读提交不创建一致性视图行不行？

不行。一致性视图的作用是规定哪些数据对于当前事务是可见的，哪些数据对于当前事务是不可见的。

读提交的隔离级别，要求当前事务读取的是别的事务提交后的数据。但是，以下两种“当前读”的情况，即使别的事务还没提交，当前事务就可以读取到其他事务未提交的值，这是违反了读提交隔离级别的特性的。

* update语句是当前读的
* select语句加锁是当前读的

所以，读提交的隔离级别需要一致性视图来判断哪些数据对于当前事务是可见的。



### 问题2:如何避免长事务？

首先，从应用开发端来看：

1. 确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。

2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。

其次，从数据库端来看：

1. 监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；
2. Percona 的 pt-kill 这个工具不错，推荐使用；
3. 在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；
4. 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。